From ebead4af1e8c4f54d2d05fe020195f11bfec6805 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ren=C3=A9=20van=20Dorst?= <opensource@vdorst.com>
Date: Thu, 26 Jul 2018 13:13:15 +0200
Subject: [PATCH 2000/2003] Patches for mt7623 tree

---
 drivers/clk/Makefile                        |    2 +-
 drivers/clk/clk.c                           |    2 +-
 drivers/clk/mediatek/Kconfig                |  145 +-
 drivers/clk/mediatek/Makefile               |   15 +-
 drivers/clk/mediatek/clk-mt2701.c           |    2 +
 drivers/clk/mediatek/clk-mt2712-bdp.c       |  102 +
 drivers/clk/mediatek/clk-mt2712-img.c       |   80 +
 drivers/clk/mediatek/clk-mt2712-jpgdec.c    |   76 +
 drivers/clk/mediatek/clk-mt2712-mfg.c       |   75 +
 drivers/clk/mediatek/clk-mt2712-mm.c        |  170 +
 drivers/clk/mediatek/clk-mt2712-vdec.c      |   94 +
 drivers/clk/mediatek/clk-mt2712-venc.c      |   77 +
 drivers/clk/mediatek/clk-mt2712.c           | 1435 ++++++++
 drivers/clk/mediatek/clk-mt7622-aud.c       |  200 ++
 drivers/clk/mediatek/clk-mt7622-eth.c       |  156 +
 drivers/clk/mediatek/clk-mt7622-hif.c       |  169 +
 drivers/clk/mediatek/clk-mt7622.c           |  780 +++++
 drivers/clk/mediatek/clk-mtk.h              |   10 +-
 drivers/clk/mediatek/clk-pll.c              |   13 +-
 drivers/net/dsa/mt7530.c                    |   65 +-
 drivers/net/dsa/mt7530.h                    |    4 +
 drivers/net/ethernet/mediatek/Kconfig       |   77 +-
 drivers/net/ethernet/mediatek/Makefile      |   21 +-
 drivers/net/ethernet/mediatek/esw_rt3050.c  | 1461 --------
 drivers/net/ethernet/mediatek/esw_rt3050.h  |   29 -
 drivers/net/ethernet/mediatek/ethtool.c     |  230 --
 drivers/net/ethernet/mediatek/ethtool.h     |   22 -
 drivers/net/ethernet/mediatek/gsw_mt7620.c  |  260 --
 drivers/net/ethernet/mediatek/gsw_mt7620.h  |  127 -
 drivers/net/ethernet/mediatek/gsw_mt7621.c  |  281 --
 drivers/net/ethernet/mediatek/mdio.c        |  260 --
 drivers/net/ethernet/mediatek/mdio.h        |   27 -
 drivers/net/ethernet/mediatek/mdio_mt7620.c |  168 -
 drivers/net/ethernet/mediatek/mdio_rt2880.c |  222 --
 drivers/net/ethernet/mediatek/mdio_rt2880.h |   23 -
 drivers/net/ethernet/mediatek/mt7530.c      |  979 ------
 drivers/net/ethernet/mediatek/mt7530.h      |  186 -
 drivers/net/ethernet/mediatek/mtk_debugfs.c |  115 -
 drivers/net/ethernet/mediatek/mtk_eth_soc.c | 3462 ++++++++++++-------
 drivers/net/ethernet/mediatek/mtk_eth_soc.h | 1104 +++---
 drivers/net/ethernet/mediatek/mtk_offload.c |  526 ---
 drivers/net/ethernet/mediatek/mtk_offload.h |  260 --
 drivers/net/ethernet/mediatek/soc_mt7620.c  |  335 --
 drivers/net/ethernet/mediatek/soc_mt7621.c  |  186 -
 drivers/net/ethernet/mediatek/soc_rt2880.c  |   76 -
 drivers/net/ethernet/mediatek/soc_rt3050.c  |  158 -
 drivers/net/ethernet/mediatek/soc_rt3883.c  |   75 -
 drivers/net/phy/phy.c                       |   15 +-
 drivers/net/phy/phy_device.c                |    2 +-
 49 files changed, 6511 insertions(+), 7848 deletions(-)
 create mode 100644 drivers/clk/mediatek/clk-mt2712-bdp.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712-img.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712-jpgdec.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712-mfg.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712-mm.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712-vdec.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712-venc.c
 create mode 100644 drivers/clk/mediatek/clk-mt2712.c
 create mode 100644 drivers/clk/mediatek/clk-mt7622-aud.c
 create mode 100644 drivers/clk/mediatek/clk-mt7622-eth.c
 create mode 100644 drivers/clk/mediatek/clk-mt7622-hif.c
 create mode 100644 drivers/clk/mediatek/clk-mt7622.c
 delete mode 100644 drivers/net/ethernet/mediatek/esw_rt3050.c
 delete mode 100644 drivers/net/ethernet/mediatek/esw_rt3050.h
 delete mode 100644 drivers/net/ethernet/mediatek/ethtool.c
 delete mode 100644 drivers/net/ethernet/mediatek/ethtool.h
 delete mode 100644 drivers/net/ethernet/mediatek/gsw_mt7620.c
 delete mode 100644 drivers/net/ethernet/mediatek/gsw_mt7620.h
 delete mode 100644 drivers/net/ethernet/mediatek/gsw_mt7621.c
 delete mode 100644 drivers/net/ethernet/mediatek/mdio.c
 delete mode 100644 drivers/net/ethernet/mediatek/mdio.h
 delete mode 100644 drivers/net/ethernet/mediatek/mdio_mt7620.c
 delete mode 100644 drivers/net/ethernet/mediatek/mdio_rt2880.c
 delete mode 100644 drivers/net/ethernet/mediatek/mdio_rt2880.h
 delete mode 100644 drivers/net/ethernet/mediatek/mt7530.c
 delete mode 100644 drivers/net/ethernet/mediatek/mt7530.h
 delete mode 100644 drivers/net/ethernet/mediatek/mtk_debugfs.c
 delete mode 100644 drivers/net/ethernet/mediatek/mtk_offload.c
 delete mode 100644 drivers/net/ethernet/mediatek/mtk_offload.h
 delete mode 100644 drivers/net/ethernet/mediatek/soc_mt7620.c
 delete mode 100644 drivers/net/ethernet/mediatek/soc_mt7621.c
 delete mode 100644 drivers/net/ethernet/mediatek/soc_rt2880.c
 delete mode 100644 drivers/net/ethernet/mediatek/soc_rt3050.c
 delete mode 100644 drivers/net/ethernet/mediatek/soc_rt3883.c

diff --git a/drivers/clk/Makefile b/drivers/clk/Makefile
index f7f761b02bed..2e3fb08352a7 100644
--- a/drivers/clk/Makefile
+++ b/drivers/clk/Makefile
@@ -67,7 +67,7 @@ obj-$(CONFIG_ARCH_MXC)			+= imx/
 obj-$(CONFIG_MACH_INGENIC)		+= ingenic/
 obj-$(CONFIG_ARCH_KEYSTONE)		+= keystone/
 obj-$(CONFIG_MACH_LOONGSON32)		+= loongson1/
-obj-$(CONFIG_ARCH_MEDIATEK)		+= mediatek/
+obj-y					+= mediatek/
 obj-$(CONFIG_COMMON_CLK_AMLOGIC)	+= meson/
 obj-$(CONFIG_MACH_PIC32)		+= microchip/
 ifeq ($(CONFIG_COMMON_CLK), y)
diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c
index 6f4c98ca6e50..09f157b0693b 100644
--- a/drivers/clk/clk.c
+++ b/drivers/clk/clk.c
@@ -797,7 +797,7 @@ static void clk_disable_unused_subtree(struct clk_core *core)
 		clk_core_disable_unprepare(core->parent);
 }
 
-static bool clk_ignore_unused;
+static bool clk_ignore_unused = true;
 static int __init clk_ignore_unused_setup(char *__unused)
 {
 	clk_ignore_unused = true;
diff --git a/drivers/clk/mediatek/Kconfig b/drivers/clk/mediatek/Kconfig
index 28739a9a6e37..1f9ea0f21df1 100644
--- a/drivers/clk/mediatek/Kconfig
+++ b/drivers/clk/mediatek/Kconfig
@@ -1,99 +1,184 @@
 #
-# MediaTek SoC drivers
+# MediaTek Clock Drivers
 #
+menu "Clock driver for MediaTek SoC"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+
 config COMMON_CLK_MEDIATEK
 	bool
+	select RESET_CONTROLLER
 	---help---
-	  Mediatek SoCs' clock support.
+	  MediaTek SoCs' clock support.
 
 config COMMON_CLK_MT2701
-	bool "Clock driver for Mediatek MT2701"
+	bool "Clock driver for MediaTek MT2701"
 	depends on (ARCH_MEDIATEK && ARM) || COMPILE_TEST
 	select COMMON_CLK_MEDIATEK
 	default ARCH_MEDIATEK && ARM
 	---help---
-	  This driver supports Mediatek MT2701 basic clocks.
+	  This driver supports MediaTek MT2701 basic clocks.
 
 config COMMON_CLK_MT2701_MMSYS
-	bool "Clock driver for Mediatek MT2701 mmsys"
+	bool "Clock driver for MediaTek MT2701 mmsys"
 	depends on COMMON_CLK_MT2701
 	---help---
-	  This driver supports Mediatek MT2701 mmsys clocks.
+	  This driver supports MediaTek MT2701 mmsys clocks.
 
 config COMMON_CLK_MT2701_IMGSYS
-	bool "Clock driver for Mediatek MT2701 imgsys"
+	bool "Clock driver for MediaTek MT2701 imgsys"
 	depends on COMMON_CLK_MT2701
 	---help---
-	  This driver supports Mediatek MT2701 imgsys clocks.
+	  This driver supports MediaTek MT2701 imgsys clocks.
 
 config COMMON_CLK_MT2701_VDECSYS
-	bool "Clock driver for Mediatek MT2701 vdecsys"
+	bool "Clock driver for MediaTek MT2701 vdecsys"
 	depends on COMMON_CLK_MT2701
 	---help---
-	  This driver supports Mediatek MT2701 vdecsys clocks.
+	  This driver supports MediaTek MT2701 vdecsys clocks.
 
 config COMMON_CLK_MT2701_HIFSYS
-	bool "Clock driver for Mediatek MT2701 hifsys"
+	bool "Clock driver for MediaTek MT2701 hifsys"
 	depends on COMMON_CLK_MT2701
 	---help---
-	  This driver supports Mediatek MT2701 hifsys clocks.
+	  This driver supports MediaTek MT2701 hifsys clocks.
 
 config COMMON_CLK_MT2701_ETHSYS
-	bool "Clock driver for Mediatek MT2701 ethsys"
+	bool "Clock driver for MediaTek MT2701 ethsys"
 	depends on COMMON_CLK_MT2701
 	---help---
-	  This driver supports Mediatek MT2701 ethsys clocks.
+	  This driver supports MediaTek MT2701 ethsys clocks.
 
 config COMMON_CLK_MT2701_BDPSYS
-	bool "Clock driver for Mediatek MT2701 bdpsys"
+	bool "Clock driver for MediaTek MT2701 bdpsys"
 	depends on COMMON_CLK_MT2701
 	---help---
-	  This driver supports Mediatek MT2701 bdpsys clocks.
+	  This driver supports MediaTek MT2701 bdpsys clocks.
+
+config COMMON_CLK_MT2712
+	bool "Clock driver for MediaTek MT2712"
+	depends on (ARCH_MEDIATEK && ARM64) || COMPILE_TEST
+	select COMMON_CLK_MEDIATEK
+	default ARCH_MEDIATEK && ARM64
+	---help---
+	  This driver supports MediaTek MT2712 basic clocks.
+
+config COMMON_CLK_MT2712_BDPSYS
+	bool "Clock driver for MediaTek MT2712 bdpsys"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 bdpsys clocks.
+
+config COMMON_CLK_MT2712_IMGSYS
+	bool "Clock driver for MediaTek MT2712 imgsys"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 imgsys clocks.
+
+config COMMON_CLK_MT2712_JPGDECSYS
+	bool "Clock driver for MediaTek MT2712 jpgdecsys"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 jpgdecsys clocks.
+
+config COMMON_CLK_MT2712_MFGCFG
+	bool "Clock driver for MediaTek MT2712 mfgcfg"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 mfgcfg clocks.
+
+config COMMON_CLK_MT2712_MMSYS
+	bool "Clock driver for MediaTek MT2712 mmsys"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 mmsys clocks.
+
+config COMMON_CLK_MT2712_VDECSYS
+	bool "Clock driver for MediaTek MT2712 vdecsys"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 vdecsys clocks.
+
+config COMMON_CLK_MT2712_VENCSYS
+	bool "Clock driver for MediaTek MT2712 vencsys"
+	depends on COMMON_CLK_MT2712
+	---help---
+	  This driver supports MediaTek MT2712 vencsys clocks.
 
 config COMMON_CLK_MT6797
-       bool "Clock driver for Mediatek MT6797"
+       bool "Clock driver for MediaTek MT6797"
        depends on (ARCH_MEDIATEK && ARM64) || COMPILE_TEST
        select COMMON_CLK_MEDIATEK
        default ARCH_MEDIATEK && ARM64
        ---help---
-         This driver supports Mediatek MT6797 basic clocks.
+         This driver supports MediaTek MT6797 basic clocks.
 
 config COMMON_CLK_MT6797_MMSYS
-       bool "Clock driver for Mediatek MT6797 mmsys"
+       bool "Clock driver for MediaTek MT6797 mmsys"
        depends on COMMON_CLK_MT6797
        ---help---
-         This driver supports Mediatek MT6797 mmsys clocks.
+         This driver supports MediaTek MT6797 mmsys clocks.
 
 config COMMON_CLK_MT6797_IMGSYS
-       bool "Clock driver for Mediatek MT6797 imgsys"
+       bool "Clock driver for MediaTek MT6797 imgsys"
        depends on COMMON_CLK_MT6797
        ---help---
-         This driver supports Mediatek MT6797 imgsys clocks.
+         This driver supports MediaTek MT6797 imgsys clocks.
 
 config COMMON_CLK_MT6797_VDECSYS
-       bool "Clock driver for Mediatek MT6797 vdecsys"
+       bool "Clock driver for MediaTek MT6797 vdecsys"
        depends on COMMON_CLK_MT6797
        ---help---
-         This driver supports Mediatek MT6797 vdecsys clocks.
+         This driver supports MediaTek MT6797 vdecsys clocks.
 
 config COMMON_CLK_MT6797_VENCSYS
-       bool "Clock driver for Mediatek MT6797 vencsys"
+       bool "Clock driver for MediaTek MT6797 vencsys"
        depends on COMMON_CLK_MT6797
        ---help---
-         This driver supports Mediatek MT6797 vencsys clocks.
+         This driver supports MediaTek MT6797 vencsys clocks.
+
+config COMMON_CLK_MT7622
+	bool "Clock driver for MediaTek MT7622"
+	depends on ARCH_MEDIATEK || COMPILE_TEST
+	select COMMON_CLK_MEDIATEK
+	default ARCH_MEDIATEK
+	---help---
+	  This driver supports MediaTek MT7622 basic clocks and clocks
+	  required for various periperals found on MediaTek.
+
+config COMMON_CLK_MT7622_ETHSYS
+	bool "Clock driver for MediaTek MT7622 ETHSYS"
+	depends on COMMON_CLK_MT7622
+	---help---
+	  This driver add support for clocks for Ethernet and SGMII
+	  required on MediaTek MT7622 SoC.
+
+config COMMON_CLK_MT7622_HIFSYS
+	bool "Clock driver for MediaTek MT7622 HIFSYS"
+	depends on COMMON_CLK_MT7622
+	---help---
+	  This driver supports MediaTek MT7622 HIFSYS clocks providing
+	  to PCI-E and USB.
+
+config COMMON_CLK_MT7622_AUDSYS
+	bool "Clock driver for MediaTek MT7622 AUDSYS"
+	depends on COMMON_CLK_MT7622
+	---help---
+	  This driver supports MediaTek MT7622 AUDSYS clocks providing
+	  to audio consumers such as I2S and TDM.
 
 config COMMON_CLK_MT8135
-	bool "Clock driver for Mediatek MT8135"
+	bool "Clock driver for MediaTek MT8135"
 	depends on (ARCH_MEDIATEK && ARM) || COMPILE_TEST
 	select COMMON_CLK_MEDIATEK
 	default ARCH_MEDIATEK && ARM
 	---help---
-	  This driver supports Mediatek MT8135 clocks.
+	  This driver supports MediaTek MT8135 clocks.
 
 config COMMON_CLK_MT8173
-	bool "Clock driver for Mediatek MT8173"
+	bool "Clock driver for MediaTek MT8173"
 	depends on ARCH_MEDIATEK || COMPILE_TEST
 	select COMMON_CLK_MEDIATEK
 	default ARCH_MEDIATEK
 	---help---
-	  This driver supports Mediatek MT8173 clocks.
+	  This driver supports MediaTek MT8173 clocks.
+endmenu
diff --git a/drivers/clk/mediatek/Makefile b/drivers/clk/mediatek/Makefile
index ba2a070765f0..5160fdc4bbb8 100644
--- a/drivers/clk/mediatek/Makefile
+++ b/drivers/clk/mediatek/Makefile
@@ -1,6 +1,5 @@
 # SPDX-License-Identifier: GPL-2.0
-obj-$(CONFIG_COMMON_CLK_MEDIATEK) += clk-mtk.o clk-pll.o clk-gate.o clk-apmixed.o clk-cpumux.o
-obj-$(CONFIG_RESET_CONTROLLER) += reset.o
+obj-$(CONFIG_COMMON_CLK_MEDIATEK) += clk-mtk.o clk-pll.o clk-gate.o clk-apmixed.o clk-cpumux.o reset.o
 obj-$(CONFIG_COMMON_CLK_MT6797) += clk-mt6797.o
 obj-$(CONFIG_COMMON_CLK_MT6797_IMGSYS) += clk-mt6797-img.o
 obj-$(CONFIG_COMMON_CLK_MT6797_MMSYS) += clk-mt6797-mm.o
@@ -13,5 +12,17 @@ obj-$(CONFIG_COMMON_CLK_MT2701_HIFSYS) += clk-mt2701-hif.o
 obj-$(CONFIG_COMMON_CLK_MT2701_IMGSYS) += clk-mt2701-img.o
 obj-$(CONFIG_COMMON_CLK_MT2701_MMSYS) += clk-mt2701-mm.o
 obj-$(CONFIG_COMMON_CLK_MT2701_VDECSYS) += clk-mt2701-vdec.o
+obj-$(CONFIG_COMMON_CLK_MT2712) += clk-mt2712.o
+obj-$(CONFIG_COMMON_CLK_MT2712_BDPSYS) += clk-mt2712-bdp.o
+obj-$(CONFIG_COMMON_CLK_MT2712_IMGSYS) += clk-mt2712-img.o
+obj-$(CONFIG_COMMON_CLK_MT2712_JPGDECSYS) += clk-mt2712-jpgdec.o
+obj-$(CONFIG_COMMON_CLK_MT2712_MFGCFG) += clk-mt2712-mfg.o
+obj-$(CONFIG_COMMON_CLK_MT2712_MMSYS) += clk-mt2712-mm.o
+obj-$(CONFIG_COMMON_CLK_MT2712_VDECSYS) += clk-mt2712-vdec.o
+obj-$(CONFIG_COMMON_CLK_MT2712_VENCSYS) += clk-mt2712-venc.o
+obj-$(CONFIG_COMMON_CLK_MT7622) += clk-mt7622.o
+obj-$(CONFIG_COMMON_CLK_MT7622_ETHSYS) += clk-mt7622-eth.o
+obj-$(CONFIG_COMMON_CLK_MT7622_HIFSYS) += clk-mt7622-hif.o
+obj-$(CONFIG_COMMON_CLK_MT7622_AUDSYS) += clk-mt7622-aud.o
 obj-$(CONFIG_COMMON_CLK_MT8135) += clk-mt8135.o
 obj-$(CONFIG_COMMON_CLK_MT8173) += clk-mt8173.o
diff --git a/drivers/clk/mediatek/clk-mt2701.c b/drivers/clk/mediatek/clk-mt2701.c
index ccfe5d30fe10..72d4e21da7a9 100644
--- a/drivers/clk/mediatek/clk-mt2701.c
+++ b/drivers/clk/mediatek/clk-mt2701.c
@@ -772,6 +772,8 @@ static void mtk_infrasys_init_early(struct device_node *node)
 	if (r)
 		pr_err("%s(): could not register clock provider: %d\n",
 			__func__, r);
+
+	mtk_register_reset_controller(node, 2, 0x30);
 }
 CLK_OF_DECLARE_DRIVER(mtk_infra, "mediatek,mt2701-infracfg",
 			mtk_infrasys_init_early);
diff --git a/drivers/clk/mediatek/clk-mt2712-bdp.c b/drivers/clk/mediatek/clk-mt2712-bdp.c
new file mode 100644
index 000000000000..5fe4728c076e
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-bdp.c
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs bdp_cg_regs = {
+	.set_ofs = 0x100,
+	.clr_ofs = 0x100,
+	.sta_ofs = 0x100,
+};
+
+#define GATE_BDP(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &bdp_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+static const struct mtk_gate bdp_clks[] = {
+	GATE_BDP(CLK_BDP_BRIDGE_B, "bdp_bridge_b", "mm_sel", 0),
+	GATE_BDP(CLK_BDP_BRIDGE_DRAM, "bdp_bridge_d", "mm_sel", 1),
+	GATE_BDP(CLK_BDP_LARB_DRAM, "bdp_larb_d", "mm_sel", 2),
+	GATE_BDP(CLK_BDP_WR_CHANNEL_VDI_PXL, "bdp_vdi_pxl", "tvd_sel", 3),
+	GATE_BDP(CLK_BDP_WR_CHANNEL_VDI_DRAM, "bdp_vdi_d", "mm_sel", 4),
+	GATE_BDP(CLK_BDP_WR_CHANNEL_VDI_B, "bdp_vdi_b", "mm_sel", 5),
+	GATE_BDP(CLK_BDP_MT_B, "bdp_fmt_b", "mm_sel", 9),
+	GATE_BDP(CLK_BDP_DISPFMT_27M, "bdp_27m", "di_sel", 10),
+	GATE_BDP(CLK_BDP_DISPFMT_27M_VDOUT, "bdp_27m_vdout", "di_sel", 11),
+	GATE_BDP(CLK_BDP_DISPFMT_27_74_74, "bdp_27_74_74", "di_sel", 12),
+	GATE_BDP(CLK_BDP_DISPFMT_2FS, "bdp_2fs", "di_sel", 13),
+	GATE_BDP(CLK_BDP_DISPFMT_2FS_2FS74_148, "bdp_2fs74_148", "di_sel", 14),
+	GATE_BDP(CLK_BDP_DISPFMT_B, "bdp_b", "mm_sel", 15),
+	GATE_BDP(CLK_BDP_VDO_DRAM, "bdp_vdo_d", "mm_sel", 16),
+	GATE_BDP(CLK_BDP_VDO_2FS, "bdp_vdo_2fs", "di_sel", 17),
+	GATE_BDP(CLK_BDP_VDO_B, "bdp_vdo_b", "mm_sel", 18),
+	GATE_BDP(CLK_BDP_WR_CHANNEL_DI_PXL, "bdp_di_pxl", "di_sel", 19),
+	GATE_BDP(CLK_BDP_WR_CHANNEL_DI_DRAM, "bdp_di_d", "mm_sel", 20),
+	GATE_BDP(CLK_BDP_WR_CHANNEL_DI_B, "bdp_di_b", "mm_sel", 21),
+	GATE_BDP(CLK_BDP_NR_AGENT, "bdp_nr_agent", "nr_sel", 22),
+	GATE_BDP(CLK_BDP_NR_DRAM, "bdp_nr_d", "mm_sel", 23),
+	GATE_BDP(CLK_BDP_NR_B, "bdp_nr_b", "mm_sel", 24),
+	GATE_BDP(CLK_BDP_BRIDGE_RT_B, "bdp_bridge_rt_b", "mm_sel", 25),
+	GATE_BDP(CLK_BDP_BRIDGE_RT_DRAM, "bdp_bridge_rt_d", "mm_sel", 26),
+	GATE_BDP(CLK_BDP_LARB_RT_DRAM, "bdp_larb_rt_d", "mm_sel", 27),
+	GATE_BDP(CLK_BDP_TVD_TDC, "bdp_tvd_tdc", "mm_sel", 28),
+	GATE_BDP(CLK_BDP_TVD_54, "bdp_tvd_clk_54", "tvd_sel", 29),
+	GATE_BDP(CLK_BDP_TVD_CBUS, "bdp_tvd_cbus", "mm_sel", 30),
+};
+
+static int clk_mt2712_bdp_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_BDP_NR_CLK);
+
+	mtk_clk_register_gates(node, bdp_clks, ARRAY_SIZE(bdp_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_bdp[] = {
+	{ .compatible = "mediatek,mt2712-bdpsys", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_bdp_drv = {
+	.probe = clk_mt2712_bdp_probe,
+	.driver = {
+		.name = "clk-mt2712-bdp",
+		.of_match_table = of_match_clk_mt2712_bdp,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_bdp_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712-img.c b/drivers/clk/mediatek/clk-mt2712-img.c
new file mode 100644
index 000000000000..139ff55d495e
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-img.c
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs img_cg_regs = {
+	.set_ofs = 0x0,
+	.clr_ofs = 0x0,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_IMG(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &img_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+static const struct mtk_gate img_clks[] = {
+	GATE_IMG(CLK_IMG_SMI_LARB2, "img_smi_larb2", "mm_sel", 0),
+	GATE_IMG(CLK_IMG_SENINF_SCAM_EN, "img_scam_en", "csi0", 3),
+	GATE_IMG(CLK_IMG_SENINF_CAM_EN, "img_cam_en", "mm_sel", 8),
+	GATE_IMG(CLK_IMG_CAM_SV_EN, "img_cam_sv_en", "mm_sel", 9),
+	GATE_IMG(CLK_IMG_CAM_SV1_EN, "img_cam_sv1_en", "mm_sel", 10),
+	GATE_IMG(CLK_IMG_CAM_SV2_EN, "img_cam_sv2_en", "mm_sel", 11),
+};
+
+static int clk_mt2712_img_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_IMG_NR_CLK);
+
+	mtk_clk_register_gates(node, img_clks, ARRAY_SIZE(img_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_img[] = {
+	{ .compatible = "mediatek,mt2712-imgsys", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_img_drv = {
+	.probe = clk_mt2712_img_probe,
+	.driver = {
+		.name = "clk-mt2712-img",
+		.of_match_table = of_match_clk_mt2712_img,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_img_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712-jpgdec.c b/drivers/clk/mediatek/clk-mt2712-jpgdec.c
new file mode 100644
index 000000000000..c7d4aada4892
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-jpgdec.c
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs jpgdec_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_JPGDEC(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &jpgdec_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr_inv,	\
+	}
+
+static const struct mtk_gate jpgdec_clks[] = {
+	GATE_JPGDEC(CLK_JPGDEC_JPGDEC1, "jpgdec_jpgdec1", "jpgdec_sel", 0),
+	GATE_JPGDEC(CLK_JPGDEC_JPGDEC, "jpgdec_jpgdec", "jpgdec_sel", 4),
+};
+
+static int clk_mt2712_jpgdec_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_JPGDEC_NR_CLK);
+
+	mtk_clk_register_gates(node, jpgdec_clks, ARRAY_SIZE(jpgdec_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_jpgdec[] = {
+	{ .compatible = "mediatek,mt2712-jpgdecsys", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_jpgdec_drv = {
+	.probe = clk_mt2712_jpgdec_probe,
+	.driver = {
+		.name = "clk-mt2712-jpgdec",
+		.of_match_table = of_match_clk_mt2712_jpgdec,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_jpgdec_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712-mfg.c b/drivers/clk/mediatek/clk-mt2712-mfg.c
new file mode 100644
index 000000000000..570f72d48d4d
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-mfg.c
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs mfg_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_MFG(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &mfg_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+static const struct mtk_gate mfg_clks[] = {
+	GATE_MFG(CLK_MFG_BG3D, "mfg_bg3d", "mfg_sel", 0),
+};
+
+static int clk_mt2712_mfg_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_MFG_NR_CLK);
+
+	mtk_clk_register_gates(node, mfg_clks, ARRAY_SIZE(mfg_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_mfg[] = {
+	{ .compatible = "mediatek,mt2712-mfgcfg", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_mfg_drv = {
+	.probe = clk_mt2712_mfg_probe,
+	.driver = {
+		.name = "clk-mt2712-mfg",
+		.of_match_table = of_match_clk_mt2712_mfg,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_mfg_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712-mm.c b/drivers/clk/mediatek/clk-mt2712-mm.c
new file mode 100644
index 000000000000..a8b4b6d42488
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-mm.c
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs mm0_cg_regs = {
+	.set_ofs = 0x104,
+	.clr_ofs = 0x108,
+	.sta_ofs = 0x100,
+};
+
+static const struct mtk_gate_regs mm1_cg_regs = {
+	.set_ofs = 0x114,
+	.clr_ofs = 0x118,
+	.sta_ofs = 0x110,
+};
+
+static const struct mtk_gate_regs mm2_cg_regs = {
+	.set_ofs = 0x224,
+	.clr_ofs = 0x228,
+	.sta_ofs = 0x220,
+};
+
+#define GATE_MM0(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &mm0_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+#define GATE_MM1(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &mm1_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+#define GATE_MM2(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &mm2_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+static const struct mtk_gate mm_clks[] = {
+	/* MM0 */
+	GATE_MM0(CLK_MM_SMI_COMMON, "mm_smi_common", "mm_sel", 0),
+	GATE_MM0(CLK_MM_SMI_LARB0, "mm_smi_larb0", "mm_sel", 1),
+	GATE_MM0(CLK_MM_CAM_MDP, "mm_cam_mdp", "mm_sel", 2),
+	GATE_MM0(CLK_MM_MDP_RDMA0, "mm_mdp_rdma0", "mm_sel", 3),
+	GATE_MM0(CLK_MM_MDP_RDMA1, "mm_mdp_rdma1", "mm_sel", 4),
+	GATE_MM0(CLK_MM_MDP_RSZ0, "mm_mdp_rsz0", "mm_sel", 5),
+	GATE_MM0(CLK_MM_MDP_RSZ1, "mm_mdp_rsz1", "mm_sel", 6),
+	GATE_MM0(CLK_MM_MDP_RSZ2, "mm_mdp_rsz2", "mm_sel", 7),
+	GATE_MM0(CLK_MM_MDP_TDSHP0, "mm_mdp_tdshp0", "mm_sel", 8),
+	GATE_MM0(CLK_MM_MDP_TDSHP1, "mm_mdp_tdshp1", "mm_sel", 9),
+	GATE_MM0(CLK_MM_MDP_CROP, "mm_mdp_crop", "mm_sel", 10),
+	GATE_MM0(CLK_MM_MDP_WDMA, "mm_mdp_wdma", "mm_sel", 11),
+	GATE_MM0(CLK_MM_MDP_WROT0, "mm_mdp_wrot0", "mm_sel", 12),
+	GATE_MM0(CLK_MM_MDP_WROT1, "mm_mdp_wrot1", "mm_sel", 13),
+	GATE_MM0(CLK_MM_FAKE_ENG, "mm_fake_eng", "mm_sel", 14),
+	GATE_MM0(CLK_MM_MUTEX_32K, "mm_mutex_32k", "clk32k", 15),
+	GATE_MM0(CLK_MM_DISP_OVL0, "mm_disp_ovl0", "mm_sel", 16),
+	GATE_MM0(CLK_MM_DISP_OVL1, "mm_disp_ovl1", "mm_sel", 17),
+	GATE_MM0(CLK_MM_DISP_RDMA0, "mm_disp_rdma0", "mm_sel", 18),
+	GATE_MM0(CLK_MM_DISP_RDMA1, "mm_disp_rdma1", "mm_sel", 19),
+	GATE_MM0(CLK_MM_DISP_RDMA2, "mm_disp_rdma2", "mm_sel", 20),
+	GATE_MM0(CLK_MM_DISP_WDMA0, "mm_disp_wdma0", "mm_sel", 21),
+	GATE_MM0(CLK_MM_DISP_WDMA1, "mm_disp_wdma1", "mm_sel", 22),
+	GATE_MM0(CLK_MM_DISP_COLOR0, "mm_disp_color0", "mm_sel", 23),
+	GATE_MM0(CLK_MM_DISP_COLOR1, "mm_disp_color1", "mm_sel", 24),
+	GATE_MM0(CLK_MM_DISP_AAL, "mm_disp_aal", "mm_sel", 25),
+	GATE_MM0(CLK_MM_DISP_GAMMA, "mm_disp_gamma", "mm_sel", 26),
+	GATE_MM0(CLK_MM_DISP_UFOE, "mm_disp_ufoe", "mm_sel", 27),
+	GATE_MM0(CLK_MM_DISP_SPLIT0, "mm_disp_split0", "mm_sel", 28),
+	GATE_MM0(CLK_MM_DISP_OD, "mm_disp_od", "mm_sel", 31),
+	/* MM1 */
+	GATE_MM1(CLK_MM_DISP_PWM0_MM, "mm_pwm0_mm", "mm_sel", 0),
+	GATE_MM1(CLK_MM_DISP_PWM0_26M, "mm_pwm0_26m", "pwm_sel", 1),
+	GATE_MM1(CLK_MM_DISP_PWM1_MM, "mm_pwm1_mm", "mm_sel", 2),
+	GATE_MM1(CLK_MM_DISP_PWM1_26M, "mm_pwm1_26m", "pwm_sel", 3),
+	GATE_MM1(CLK_MM_DSI0_ENGINE, "mm_dsi0_engine", "mm_sel", 4),
+	GATE_MM1(CLK_MM_DSI0_DIGITAL, "mm_dsi0_digital", "dsi0_lntc", 5),
+	GATE_MM1(CLK_MM_DSI1_ENGINE, "mm_dsi1_engine", "mm_sel", 6),
+	GATE_MM1(CLK_MM_DSI1_DIGITAL, "mm_dsi1_digital", "dsi1_lntc", 7),
+	GATE_MM1(CLK_MM_DPI_PIXEL, "mm_dpi_pixel", "vpll_dpix", 8),
+	GATE_MM1(CLK_MM_DPI_ENGINE, "mm_dpi_engine", "mm_sel", 9),
+	GATE_MM1(CLK_MM_DPI1_PIXEL, "mm_dpi1_pixel", "vpll3_dpix", 10),
+	GATE_MM1(CLK_MM_DPI1_ENGINE, "mm_dpi1_engine", "mm_sel", 11),
+	GATE_MM1(CLK_MM_LVDS_PIXEL, "mm_lvds_pixel", "vpll_dpix", 16),
+	GATE_MM1(CLK_MM_LVDS_CTS, "mm_lvds_cts", "lvdstx", 17),
+	GATE_MM1(CLK_MM_SMI_LARB4, "mm_smi_larb4", "mm_sel", 18),
+	GATE_MM1(CLK_MM_SMI_COMMON1, "mm_smi_common1", "mm_sel", 21),
+	GATE_MM1(CLK_MM_SMI_LARB5, "mm_smi_larb5", "mm_sel", 22),
+	GATE_MM1(CLK_MM_MDP_RDMA2, "mm_mdp_rdma2", "mm_sel", 23),
+	GATE_MM1(CLK_MM_MDP_TDSHP2, "mm_mdp_tdshp2", "mm_sel", 24),
+	GATE_MM1(CLK_MM_DISP_OVL2, "mm_disp_ovl2", "mm_sel", 25),
+	GATE_MM1(CLK_MM_DISP_WDMA2, "mm_disp_wdma2", "mm_sel", 26),
+	GATE_MM1(CLK_MM_DISP_COLOR2, "mm_disp_color2", "mm_sel", 27),
+	GATE_MM1(CLK_MM_DISP_AAL1, "mm_disp_aal1", "mm_sel", 28),
+	GATE_MM1(CLK_MM_DISP_OD1, "mm_disp_od1", "mm_sel", 29),
+	GATE_MM1(CLK_MM_LVDS1_PIXEL, "mm_lvds1_pixel", "vpll3_dpix", 30),
+	GATE_MM1(CLK_MM_LVDS1_CTS, "mm_lvds1_cts", "lvdstx3", 31),
+	/* MM2 */
+	GATE_MM2(CLK_MM_SMI_LARB7, "mm_smi_larb7", "mm_sel", 0),
+	GATE_MM2(CLK_MM_MDP_RDMA3, "mm_mdp_rdma3", "mm_sel", 1),
+	GATE_MM2(CLK_MM_MDP_WROT2, "mm_mdp_wrot2", "mm_sel", 2),
+	GATE_MM2(CLK_MM_DSI2, "mm_dsi2", "mm_sel", 3),
+	GATE_MM2(CLK_MM_DSI2_DIGITAL, "mm_dsi2_digital", "dsi0_lntc", 4),
+	GATE_MM2(CLK_MM_DSI3, "mm_dsi3", "mm_sel", 5),
+	GATE_MM2(CLK_MM_DSI3_DIGITAL, "mm_dsi3_digital", "dsi1_lntc", 6),
+};
+
+static int clk_mt2712_mm_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_MM_NR_CLK);
+
+	mtk_clk_register_gates(node, mm_clks, ARRAY_SIZE(mm_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_mm[] = {
+	{ .compatible = "mediatek,mt2712-mmsys", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_mm_drv = {
+	.probe = clk_mt2712_mm_probe,
+	.driver = {
+		.name = "clk-mt2712-mm",
+		.of_match_table = of_match_clk_mt2712_mm,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_mm_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712-vdec.c b/drivers/clk/mediatek/clk-mt2712-vdec.c
new file mode 100644
index 000000000000..55c64ee8cc91
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-vdec.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs vdec0_cg_regs = {
+	.set_ofs = 0x0,
+	.clr_ofs = 0x4,
+	.sta_ofs = 0x0,
+};
+
+static const struct mtk_gate_regs vdec1_cg_regs = {
+	.set_ofs = 0x8,
+	.clr_ofs = 0xc,
+	.sta_ofs = 0x8,
+};
+
+#define GATE_VDEC0(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &vdec0_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr_inv,	\
+	}
+
+#define GATE_VDEC1(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &vdec1_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr_inv,	\
+	}
+
+static const struct mtk_gate vdec_clks[] = {
+	/* VDEC0 */
+	GATE_VDEC0(CLK_VDEC_CKEN, "vdec_cken", "vdec_sel", 0),
+	/* VDEC1 */
+	GATE_VDEC1(CLK_VDEC_LARB1_CKEN, "vdec_larb1_cken", "vdec_sel", 0),
+	GATE_VDEC1(CLK_VDEC_IMGRZ_CKEN, "vdec_imgrz_cken", "vdec_sel", 1),
+};
+
+static int clk_mt2712_vdec_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_VDEC_NR_CLK);
+
+	mtk_clk_register_gates(node, vdec_clks, ARRAY_SIZE(vdec_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_vdec[] = {
+	{ .compatible = "mediatek,mt2712-vdecsys", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_vdec_drv = {
+	.probe = clk_mt2712_vdec_probe,
+	.driver = {
+		.name = "clk-mt2712-vdec",
+		.of_match_table = of_match_clk_mt2712_vdec,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_vdec_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712-venc.c b/drivers/clk/mediatek/clk-mt2712-venc.c
new file mode 100644
index 000000000000..ccbfe98777c8
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712-venc.c
@@ -0,0 +1,77 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static const struct mtk_gate_regs venc_cg_regs = {
+	.set_ofs = 0x4,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x0,
+};
+
+#define GATE_VENC(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &venc_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr_inv,	\
+	}
+
+static const struct mtk_gate venc_clks[] = {
+	GATE_VENC(CLK_VENC_SMI_COMMON_CON, "venc_smi", "mm_sel", 0),
+	GATE_VENC(CLK_VENC_VENC, "venc_venc", "venc_sel", 4),
+	GATE_VENC(CLK_VENC_SMI_LARB6, "venc_smi_larb6", "jpgdec_sel", 12),
+};
+
+static int clk_mt2712_venc_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_VENC_NR_CLK);
+
+	mtk_clk_register_gates(node, venc_clks, ARRAY_SIZE(venc_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712_venc[] = {
+	{ .compatible = "mediatek,mt2712-vencsys", },
+	{}
+};
+
+static struct platform_driver clk_mt2712_venc_drv = {
+	.probe = clk_mt2712_venc_probe,
+	.driver = {
+		.name = "clk-mt2712-venc",
+		.of_match_table = of_match_clk_mt2712_venc,
+	},
+};
+
+builtin_platform_driver(clk_mt2712_venc_drv);
diff --git a/drivers/clk/mediatek/clk-mt2712.c b/drivers/clk/mediatek/clk-mt2712.c
new file mode 100644
index 000000000000..498d13799388
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt2712.c
@@ -0,0 +1,1435 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Weiyi Lu <weiyi.lu@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/mfd/syscon.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt2712-clk.h>
+
+static DEFINE_SPINLOCK(mt2712_clk_lock);
+
+static const struct mtk_fixed_clk top_fixed_clks[] = {
+	FIXED_CLK(CLK_TOP_VPLL3_DPIX, "vpll3_dpix", NULL, 200000000),
+	FIXED_CLK(CLK_TOP_VPLL_DPIX, "vpll_dpix", NULL, 200000000),
+	FIXED_CLK(CLK_TOP_LTEPLL_FS26M, "ltepll_fs26m", NULL, 26000000),
+	FIXED_CLK(CLK_TOP_DMPLL, "dmpll_ck", NULL, 350000000),
+	FIXED_CLK(CLK_TOP_DSI0_LNTC, "dsi0_lntc", NULL, 143000000),
+	FIXED_CLK(CLK_TOP_DSI1_LNTC, "dsi1_lntc", NULL, 143000000),
+	FIXED_CLK(CLK_TOP_LVDSTX3_CLKDIG_CTS, "lvdstx3", NULL, 140000000),
+	FIXED_CLK(CLK_TOP_LVDSTX_CLKDIG_CTS, "lvdstx", NULL, 140000000),
+	FIXED_CLK(CLK_TOP_CLKRTC_EXT, "clkrtc_ext", NULL, 32768),
+	FIXED_CLK(CLK_TOP_CLKRTC_INT, "clkrtc_int", NULL, 32747),
+	FIXED_CLK(CLK_TOP_CSI0, "csi0", NULL, 26000000),
+	FIXED_CLK(CLK_TOP_CVBSPLL, "cvbspll", NULL, 108000000),
+};
+
+static const struct mtk_fixed_factor top_early_divs[] = {
+	FACTOR(CLK_TOP_SYS_26M, "sys_26m", "clk26m", 1,
+		1),
+	FACTOR(CLK_TOP_CLK26M_D2, "clk26m_d2", "sys_26m", 1,
+		2),
+};
+
+static const struct mtk_fixed_factor top_divs[] = {
+	FACTOR(CLK_TOP_ARMCA35PLL, "armca35pll_ck", "armca35pll", 1,
+		1),
+	FACTOR(CLK_TOP_ARMCA35PLL_600M, "armca35pll_600m", "armca35pll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_ARMCA35PLL_400M, "armca35pll_400m", "armca35pll_ck", 1,
+		3),
+	FACTOR(CLK_TOP_ARMCA72PLL, "armca72pll_ck", "armca72pll", 1,
+		1),
+	FACTOR(CLK_TOP_SYSPLL, "syspll_ck", "mainpll", 1,
+		1),
+	FACTOR(CLK_TOP_SYSPLL_D2, "syspll_d2", "syspll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_SYSPLL1_D2, "syspll1_d2", "syspll_d2", 1,
+		2),
+	FACTOR(CLK_TOP_SYSPLL1_D4, "syspll1_d4", "syspll_d2", 1,
+		4),
+	FACTOR(CLK_TOP_SYSPLL1_D8, "syspll1_d8", "syspll_d2", 1,
+		8),
+	FACTOR(CLK_TOP_SYSPLL1_D16, "syspll1_d16", "syspll_d2", 1,
+		16),
+	FACTOR(CLK_TOP_SYSPLL_D3, "syspll_d3", "syspll_ck", 1,
+		3),
+	FACTOR(CLK_TOP_SYSPLL2_D2, "syspll2_d2", "syspll_d3", 1,
+		2),
+	FACTOR(CLK_TOP_SYSPLL2_D4, "syspll2_d4", "syspll_d3", 1,
+		4),
+	FACTOR(CLK_TOP_SYSPLL_D5, "syspll_d5", "syspll_ck", 1,
+		5),
+	FACTOR(CLK_TOP_SYSPLL3_D2, "syspll3_d2", "syspll_d5", 1,
+		2),
+	FACTOR(CLK_TOP_SYSPLL3_D4, "syspll3_d4", "syspll_d5", 1,
+		4),
+	FACTOR(CLK_TOP_SYSPLL_D7, "syspll_d7", "syspll_ck", 1,
+		7),
+	FACTOR(CLK_TOP_SYSPLL4_D2, "syspll4_d2", "syspll_d7", 1,
+		2),
+	FACTOR(CLK_TOP_SYSPLL4_D4, "syspll4_d4", "syspll_d7", 1,
+		4),
+	FACTOR(CLK_TOP_UNIVPLL, "univpll_ck", "univpll", 1,
+		1),
+	FACTOR(CLK_TOP_UNIVPLL_D7, "univpll_d7", "univpll_ck", 1,
+		7),
+	FACTOR(CLK_TOP_UNIVPLL_D26, "univpll_d26", "univpll_ck", 1,
+		26),
+	FACTOR(CLK_TOP_UNIVPLL_D52, "univpll_d52", "univpll_ck", 1,
+		52),
+	FACTOR(CLK_TOP_UNIVPLL_D104, "univpll_d104", "univpll_ck", 1,
+		104),
+	FACTOR(CLK_TOP_UNIVPLL_D208, "univpll_d208", "univpll_ck", 1,
+		208),
+	FACTOR(CLK_TOP_UNIVPLL_D2, "univpll_d2", "univpll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_UNIVPLL1_D2, "univpll1_d2", "univpll_d2", 1,
+		2),
+	FACTOR(CLK_TOP_UNIVPLL1_D4, "univpll1_d4", "univpll_d2", 1,
+		4),
+	FACTOR(CLK_TOP_UNIVPLL1_D8, "univpll1_d8", "univpll_d2", 1,
+		8),
+	FACTOR(CLK_TOP_UNIVPLL_D3, "univpll_d3", "univpll_ck", 1,
+		3),
+	FACTOR(CLK_TOP_UNIVPLL2_D2, "univpll2_d2", "univpll_d3", 1,
+		2),
+	FACTOR(CLK_TOP_UNIVPLL2_D4, "univpll2_d4", "univpll_d3", 1,
+		4),
+	FACTOR(CLK_TOP_UNIVPLL2_D8, "univpll2_d8", "univpll_d3", 1,
+		8),
+	FACTOR(CLK_TOP_UNIVPLL_D5, "univpll_d5", "univpll_ck", 1,
+		5),
+	FACTOR(CLK_TOP_UNIVPLL3_D2, "univpll3_d2", "univpll_d5", 1,
+		2),
+	FACTOR(CLK_TOP_UNIVPLL3_D4, "univpll3_d4", "univpll_d5", 1,
+		4),
+	FACTOR(CLK_TOP_UNIVPLL3_D8, "univpll3_d8", "univpll_d5", 1,
+		8),
+	FACTOR(CLK_TOP_F_MP0_PLL1, "f_mp0_pll1_ck", "univpll_d2", 1,
+		1),
+	FACTOR(CLK_TOP_F_MP0_PLL2, "f_mp0_pll2_ck", "univpll1_d2", 1,
+		1),
+	FACTOR(CLK_TOP_F_BIG_PLL1, "f_big_pll1_ck", "univpll_d2", 1,
+		1),
+	FACTOR(CLK_TOP_F_BIG_PLL2, "f_big_pll2_ck", "univpll1_d2", 1,
+		1),
+	FACTOR(CLK_TOP_F_BUS_PLL1, "f_bus_pll1_ck", "univpll_d2", 1,
+		1),
+	FACTOR(CLK_TOP_F_BUS_PLL2, "f_bus_pll2_ck", "univpll1_d2", 1,
+		1),
+	FACTOR(CLK_TOP_APLL1, "apll1_ck", "apll1", 1,
+		1),
+	FACTOR(CLK_TOP_APLL1_D2, "apll1_d2", "apll1_ck", 1,
+		2),
+	FACTOR(CLK_TOP_APLL1_D4, "apll1_d4", "apll1_ck", 1,
+		4),
+	FACTOR(CLK_TOP_APLL1_D8, "apll1_d8", "apll1_ck", 1,
+		8),
+	FACTOR(CLK_TOP_APLL1_D16, "apll1_d16", "apll1_ck", 1,
+		16),
+	FACTOR(CLK_TOP_APLL2, "apll2_ck", "apll2", 1,
+		1),
+	FACTOR(CLK_TOP_APLL2_D2, "apll2_d2", "apll2_ck", 1,
+		2),
+	FACTOR(CLK_TOP_APLL2_D4, "apll2_d4", "apll2_ck", 1,
+		4),
+	FACTOR(CLK_TOP_APLL2_D8, "apll2_d8", "apll2_ck", 1,
+		8),
+	FACTOR(CLK_TOP_APLL2_D16, "apll2_d16", "apll2_ck", 1,
+		16),
+	FACTOR(CLK_TOP_LVDSPLL, "lvdspll_ck", "lvdspll", 1,
+		1),
+	FACTOR(CLK_TOP_LVDSPLL_D2, "lvdspll_d2", "lvdspll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_LVDSPLL_D4, "lvdspll_d4", "lvdspll_ck", 1,
+		4),
+	FACTOR(CLK_TOP_LVDSPLL_D8, "lvdspll_d8", "lvdspll_ck", 1,
+		8),
+	FACTOR(CLK_TOP_LVDSPLL2, "lvdspll2_ck", "lvdspll2", 1,
+		1),
+	FACTOR(CLK_TOP_LVDSPLL2_D2, "lvdspll2_d2", "lvdspll2_ck", 1,
+		2),
+	FACTOR(CLK_TOP_LVDSPLL2_D4, "lvdspll2_d4", "lvdspll2_ck", 1,
+		4),
+	FACTOR(CLK_TOP_LVDSPLL2_D8, "lvdspll2_d8", "lvdspll2_ck", 1,
+		8),
+	FACTOR(CLK_TOP_ETHERPLL_125M, "etherpll_125m", "etherpll", 1,
+		1),
+	FACTOR(CLK_TOP_ETHERPLL_50M, "etherpll_50m", "etherpll", 1,
+		1),
+	FACTOR(CLK_TOP_CVBS, "cvbs", "cvbspll", 1,
+		1),
+	FACTOR(CLK_TOP_CVBS_D2, "cvbs_d2", "cvbs", 1,
+		2),
+	FACTOR(CLK_TOP_MMPLL, "mmpll_ck", "mmpll", 1,
+		1),
+	FACTOR(CLK_TOP_MMPLL_D2, "mmpll_d2", "mmpll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_VENCPLL, "vencpll_ck", "vencpll", 1,
+		1),
+	FACTOR(CLK_TOP_VENCPLL_D2, "vencpll_d2", "vencpll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_VCODECPLL, "vcodecpll_ck", "vcodecpll", 1,
+		1),
+	FACTOR(CLK_TOP_VCODECPLL_D2, "vcodecpll_d2", "vcodecpll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_TVDPLL, "tvdpll_ck", "tvdpll", 1,
+		1),
+	FACTOR(CLK_TOP_TVDPLL_D2, "tvdpll_d2", "tvdpll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_TVDPLL_D4, "tvdpll_d4", "tvdpll_ck", 1,
+		4),
+	FACTOR(CLK_TOP_TVDPLL_D8, "tvdpll_d8", "tvdpll_ck", 1,
+		8),
+	FACTOR(CLK_TOP_TVDPLL_429M, "tvdpll_429m", "tvdpll", 1,
+		1),
+	FACTOR(CLK_TOP_TVDPLL_429M_D2, "tvdpll_429m_d2", "tvdpll_429m", 1,
+		2),
+	FACTOR(CLK_TOP_TVDPLL_429M_D4, "tvdpll_429m_d4", "tvdpll_429m", 1,
+		4),
+	FACTOR(CLK_TOP_MSDCPLL, "msdcpll_ck", "msdcpll", 1,
+		1),
+	FACTOR(CLK_TOP_MSDCPLL_D2, "msdcpll_d2", "msdcpll_ck", 1,
+		2),
+	FACTOR(CLK_TOP_MSDCPLL_D4, "msdcpll_d4", "msdcpll_ck", 1,
+		4),
+	FACTOR(CLK_TOP_MSDCPLL2, "msdcpll2_ck", "msdcpll2", 1,
+		1),
+	FACTOR(CLK_TOP_MSDCPLL2_D2, "msdcpll2_d2", "msdcpll2_ck", 1,
+		2),
+	FACTOR(CLK_TOP_MSDCPLL2_D4, "msdcpll2_d4", "msdcpll2_ck", 1,
+		4),
+	FACTOR(CLK_TOP_D2A_ULCLK_6P5M, "d2a_ulclk_6p5m", "clk26m", 1,
+		4),
+};
+
+static const char * const axi_parents[] = {
+	"clk26m",
+	"syspll1_d2",
+	"syspll_d5",
+	"syspll1_d4",
+	"univpll_d5",
+	"univpll2_d2",
+	"msdcpll2_ck"
+};
+
+static const char * const mem_parents[] = {
+	"clk26m",
+	"dmpll_ck"
+};
+
+static const char * const mm_parents[] = {
+	"clk26m",
+	"vencpll_ck",
+	"syspll_d3",
+	"syspll1_d2",
+	"syspll_d5",
+	"syspll1_d4",
+	"univpll1_d2",
+	"univpll2_d2"
+};
+
+static const char * const pwm_parents[] = {
+	"clk26m",
+	"univpll2_d4",
+	"univpll3_d2",
+	"univpll1_d4"
+};
+
+static const char * const vdec_parents[] = {
+	"clk26m",
+	"vcodecpll_ck",
+	"tvdpll_429m",
+	"univpll_d3",
+	"vencpll_ck",
+	"syspll_d3",
+	"univpll1_d2",
+	"mmpll_d2",
+	"syspll3_d2",
+	"tvdpll_ck"
+};
+
+static const char * const venc_parents[] = {
+	"clk26m",
+	"univpll1_d2",
+	"mmpll_d2",
+	"tvdpll_d2",
+	"syspll1_d2",
+	"univpll_d5",
+	"vcodecpll_d2",
+	"univpll2_d2",
+	"syspll3_d2"
+};
+
+static const char * const mfg_parents[] = {
+	"clk26m",
+	"mmpll_ck",
+	"univpll_d3",
+	"clk26m",
+	"clk26m",
+	"clk26m",
+	"clk26m",
+	"clk26m",
+	"clk26m",
+	"syspll_d3",
+	"syspll1_d2",
+	"syspll_d5",
+	"univpll_d3",
+	"univpll1_d2",
+	"univpll_d5",
+	"univpll2_d2"
+};
+
+static const char * const camtg_parents[] = {
+	"clk26m",
+	"univpll_d52",
+	"univpll_d208",
+	"univpll_d104",
+	"clk26m_d2",
+	"univpll_d26",
+	"univpll2_d8",
+	"syspll3_d4",
+	"syspll3_d2",
+	"univpll1_d4",
+	"univpll2_d2"
+};
+
+static const char * const uart_parents[] = {
+	"clk26m",
+	"univpll2_d8"
+};
+
+static const char * const spi_parents[] = {
+	"clk26m",
+	"univpll2_d4",
+	"univpll1_d4",
+	"univpll2_d2",
+	"univpll3_d2",
+	"univpll1_d8"
+};
+
+static const char * const usb20_parents[] = {
+	"clk26m",
+	"univpll1_d8",
+	"univpll3_d4"
+};
+
+static const char * const usb30_parents[] = {
+	"clk26m",
+	"univpll3_d2",
+	"univpll3_d4",
+	"univpll2_d4"
+};
+
+static const char * const msdc50_0_h_parents[] = {
+	"clk26m",
+	"syspll1_d2",
+	"syspll2_d2",
+	"syspll4_d2",
+	"univpll_d5",
+	"univpll1_d4"
+};
+
+static const char * const msdc50_0_parents[] = {
+	"clk26m",
+	"msdcpll_ck",
+	"msdcpll_d2",
+	"univpll1_d4",
+	"syspll2_d2",
+	"msdcpll_d4",
+	"vencpll_d2",
+	"univpll1_d2",
+	"msdcpll2_ck",
+	"msdcpll2_d2",
+	"msdcpll2_d4"
+};
+
+static const char * const msdc30_1_parents[] = {
+	"clk26m",
+	"univpll2_d2",
+	"msdcpll_d2",
+	"univpll1_d4",
+	"syspll2_d2",
+	"univpll_d7",
+	"vencpll_d2"
+};
+
+static const char * const msdc30_3_parents[] = {
+	"clk26m",
+	"msdcpll2_ck",
+	"msdcpll2_d2",
+	"univpll2_d2",
+	"msdcpll2_d4",
+	"univpll1_d4",
+	"syspll2_d2",
+	"syspll_d7",
+	"univpll_d7",
+	"vencpll_d2",
+	"msdcpll_ck",
+	"msdcpll_d2",
+	"msdcpll_d4"
+};
+
+static const char * const audio_parents[] = {
+	"clk26m",
+	"syspll3_d4",
+	"syspll4_d4",
+	"syspll1_d16"
+};
+
+static const char * const aud_intbus_parents[] = {
+	"clk26m",
+	"syspll1_d4",
+	"syspll4_d2",
+	"univpll3_d2",
+	"univpll2_d8",
+	"syspll3_d2",
+	"syspll3_d4"
+};
+
+static const char * const pmicspi_parents[] = {
+	"clk26m",
+	"syspll1_d8",
+	"syspll3_d4",
+	"syspll1_d16",
+	"univpll3_d4",
+	"univpll_d26",
+	"syspll3_d4"
+};
+
+static const char * const dpilvds1_parents[] = {
+	"clk26m",
+	"lvdspll2_ck",
+	"lvdspll2_d2",
+	"lvdspll2_d4",
+	"lvdspll2_d8",
+	"clkfpc"
+};
+
+static const char * const atb_parents[] = {
+	"clk26m",
+	"syspll1_d2",
+	"univpll_d5",
+	"syspll_d5"
+};
+
+static const char * const nr_parents[] = {
+	"clk26m",
+	"univpll1_d4",
+	"syspll2_d2",
+	"syspll1_d4",
+	"univpll1_d8",
+	"univpll3_d2",
+	"univpll2_d2",
+	"syspll_d5"
+};
+
+static const char * const nfi2x_parents[] = {
+	"clk26m",
+	"syspll4_d4",
+	"univpll3_d4",
+	"univpll1_d8",
+	"syspll2_d4",
+	"univpll3_d2",
+	"syspll_d7",
+	"syspll2_d2",
+	"univpll2_d2",
+	"syspll_d5",
+	"syspll1_d2"
+};
+
+static const char * const irda_parents[] = {
+	"clk26m",
+	"univpll2_d4",
+	"syspll2_d4",
+	"univpll2_d8"
+};
+
+static const char * const cci400_parents[] = {
+	"clk26m",
+	"vencpll_ck",
+	"armca35pll_600m",
+	"armca35pll_400m",
+	"univpll_d2",
+	"syspll_d2",
+	"msdcpll_ck",
+	"univpll_d3"
+};
+
+static const char * const aud_1_parents[] = {
+	"clk26m",
+	"apll1_ck",
+	"univpll2_d4",
+	"univpll2_d8"
+};
+
+static const char * const aud_2_parents[] = {
+	"clk26m",
+	"apll2_ck",
+	"univpll2_d4",
+	"univpll2_d8"
+};
+
+static const char * const mem_mfg_parents[] = {
+	"clk26m",
+	"mmpll_ck",
+	"univpll_d3"
+};
+
+static const char * const axi_mfg_parents[] = {
+	"clk26m",
+	"axi_sel",
+	"univpll_d5"
+};
+
+static const char * const scam_parents[] = {
+	"clk26m",
+	"syspll3_d2",
+	"univpll2_d4",
+	"syspll2_d4"
+};
+
+static const char * const nfiecc_parents[] = {
+	"clk26m",
+	"nfi2x_sel",
+	"syspll_d7",
+	"syspll2_d2",
+	"univpll2_d2",
+	"univpll_d5",
+	"syspll1_d2"
+};
+
+static const char * const pe2_mac_p0_parents[] = {
+	"clk26m",
+	"syspll1_d8",
+	"syspll4_d2",
+	"syspll2_d4",
+	"univpll2_d4",
+	"syspll3_d2"
+};
+
+static const char * const dpilvds_parents[] = {
+	"clk26m",
+	"lvdspll_ck",
+	"lvdspll_d2",
+	"lvdspll_d4",
+	"lvdspll_d8",
+	"clkfpc"
+};
+
+static const char * const hdcp_parents[] = {
+	"clk26m",
+	"syspll4_d2",
+	"syspll3_d4",
+	"univpll2_d4"
+};
+
+static const char * const hdcp_24m_parents[] = {
+	"clk26m",
+	"univpll_d26",
+	"univpll_d52",
+	"univpll2_d8"
+};
+
+static const char * const rtc_parents[] = {
+	"clkrtc_int",
+	"clkrtc_ext",
+	"clk26m",
+	"univpll3_d8"
+};
+
+static const char * const spinor_parents[] = {
+	"clk26m",
+	"clk26m_d2",
+	"syspll4_d4",
+	"univpll2_d8",
+	"univpll3_d4",
+	"syspll4_d2",
+	"syspll2_d4",
+	"univpll2_d4",
+	"etherpll_125m",
+	"syspll1_d4"
+};
+
+static const char * const apll_parents[] = {
+	"clk26m",
+	"apll1_ck",
+	"apll1_d2",
+	"apll1_d4",
+	"apll1_d8",
+	"apll1_d16",
+	"apll2_ck",
+	"apll2_d2",
+	"apll2_d4",
+	"apll2_d8",
+	"apll2_d16",
+	"clk26m",
+	"clk26m"
+};
+
+static const char * const a1sys_hp_parents[] = {
+	"clk26m",
+	"apll1_ck",
+	"apll1_d2",
+	"apll1_d4",
+	"apll1_d8"
+};
+
+static const char * const a2sys_hp_parents[] = {
+	"clk26m",
+	"apll2_ck",
+	"apll2_d2",
+	"apll2_d4",
+	"apll2_d8"
+};
+
+static const char * const asm_l_parents[] = {
+	"clk26m",
+	"univpll2_d4",
+	"univpll2_d2",
+	"syspll_d5"
+};
+
+static const char * const i2so1_parents[] = {
+	"clk26m",
+	"apll1_ck",
+	"apll2_ck"
+};
+
+static const char * const ether_125m_parents[] = {
+	"clk26m",
+	"etherpll_125m",
+	"univpll3_d2"
+};
+
+static const char * const ether_50m_parents[] = {
+	"clk26m",
+	"etherpll_50m",
+	"univpll_d26",
+	"univpll3_d4"
+};
+
+static const char * const jpgdec_parents[] = {
+	"clk26m",
+	"univpll_d3",
+	"tvdpll_429m",
+	"vencpll_ck",
+	"syspll_d3",
+	"vcodecpll_ck",
+	"univpll1_d2",
+	"armca35pll_400m",
+	"tvdpll_429m_d2",
+	"tvdpll_429m_d4"
+};
+
+static const char * const spislv_parents[] = {
+	"clk26m",
+	"univpll2_d4",
+	"univpll1_d4",
+	"univpll2_d2",
+	"univpll3_d2",
+	"univpll1_d8",
+	"univpll1_d2",
+	"univpll_d5"
+};
+
+static const char * const ether_parents[] = {
+	"clk26m",
+	"etherpll_50m",
+	"univpll_d26"
+};
+
+static const char * const di_parents[] = {
+	"clk26m",
+	"tvdpll_d2",
+	"tvdpll_d4",
+	"tvdpll_d8",
+	"vencpll_ck",
+	"vencpll_d2",
+	"cvbs",
+	"cvbs_d2"
+};
+
+static const char * const tvd_parents[] = {
+	"clk26m",
+	"cvbs_d2",
+	"univpll2_d8"
+};
+
+static const char * const i2c_parents[] = {
+	"clk26m",
+	"univpll_d26",
+	"univpll2_d4",
+	"univpll3_d2",
+	"univpll1_d4"
+};
+
+static const char * const msdc0p_aes_parents[] = {
+	"clk26m",
+	"msdcpll_ck",
+	"univpll_d3",
+	"vcodecpll_ck"
+};
+
+static const char * const cmsys_parents[] = {
+	"clk26m",
+	"univpll_d3",
+	"syspll_d3",
+	"syspll1_d2",
+	"syspll2_d2"
+};
+
+static const char * const gcpu_parents[] = {
+	"clk26m",
+	"syspll_d3",
+	"syspll1_d2",
+	"univpll1_d2",
+	"univpll_d5",
+	"univpll3_d2",
+	"univpll_d3"
+};
+
+static const char * const aud_apll1_parents[] = {
+	"apll1",
+	"clkaud_ext_i_1"
+};
+
+static const char * const aud_apll2_parents[] = {
+	"apll2",
+	"clkaud_ext_i_2"
+};
+
+static const char * const audull_vtx_parents[] = {
+	"d2a_ulclk_6p5m",
+	"clkaud_ext_i_0"
+};
+
+static struct mtk_composite top_muxes[] = {
+	/* CLK_CFG_0 */
+	MUX_GATE_FLAGS(CLK_TOP_AXI_SEL, "axi_sel", axi_parents, 0x040, 0, 3,
+		7, CLK_IS_CRITICAL),
+	MUX_GATE_FLAGS(CLK_TOP_MEM_SEL, "mem_sel", mem_parents, 0x040, 8, 1,
+		15, CLK_IS_CRITICAL),
+	MUX_GATE(CLK_TOP_MM_SEL, "mm_sel",
+		mm_parents, 0x040, 24, 3, 31),
+	/* CLK_CFG_1 */
+	MUX_GATE(CLK_TOP_PWM_SEL, "pwm_sel",
+		pwm_parents, 0x050, 0, 2, 7),
+	MUX_GATE(CLK_TOP_VDEC_SEL, "vdec_sel",
+		vdec_parents, 0x050, 8, 4, 15),
+	MUX_GATE(CLK_TOP_VENC_SEL, "venc_sel",
+		venc_parents, 0x050, 16, 4, 23),
+	MUX_GATE(CLK_TOP_MFG_SEL, "mfg_sel",
+		mfg_parents, 0x050, 24, 4, 31),
+	/* CLK_CFG_2 */
+	MUX_GATE(CLK_TOP_CAMTG_SEL, "camtg_sel",
+		camtg_parents, 0x060, 0, 4, 7),
+	MUX_GATE(CLK_TOP_UART_SEL, "uart_sel",
+		uart_parents, 0x060, 8, 1, 15),
+	MUX_GATE(CLK_TOP_SPI_SEL, "spi_sel",
+		spi_parents, 0x060, 16, 3, 23),
+	MUX_GATE(CLK_TOP_USB20_SEL, "usb20_sel",
+		usb20_parents, 0x060, 24, 2, 31),
+	/* CLK_CFG_3 */
+	MUX_GATE(CLK_TOP_USB30_SEL, "usb30_sel",
+		usb30_parents, 0x070, 0, 2, 7),
+	MUX_GATE(CLK_TOP_MSDC50_0_HCLK_SEL, "msdc50_0_h_sel",
+		msdc50_0_h_parents, 0x070, 8, 3, 15),
+	MUX_GATE(CLK_TOP_MSDC50_0_SEL, "msdc50_0_sel",
+		msdc50_0_parents, 0x070, 16, 4, 23),
+	MUX_GATE(CLK_TOP_MSDC30_1_SEL, "msdc30_1_sel",
+		msdc30_1_parents, 0x070, 24, 3, 31),
+	/* CLK_CFG_4 */
+	MUX_GATE(CLK_TOP_MSDC30_2_SEL, "msdc30_2_sel",
+		msdc30_1_parents, 0x080, 0, 3, 7),
+	MUX_GATE(CLK_TOP_MSDC30_3_SEL, "msdc30_3_sel",
+		msdc30_3_parents, 0x080, 8, 4, 15),
+	MUX_GATE(CLK_TOP_AUDIO_SEL, "audio_sel",
+		audio_parents, 0x080, 16, 2, 23),
+	MUX_GATE(CLK_TOP_AUD_INTBUS_SEL, "aud_intbus_sel",
+		aud_intbus_parents, 0x080, 24, 3, 31),
+	/* CLK_CFG_5 */
+	MUX_GATE(CLK_TOP_PMICSPI_SEL, "pmicspi_sel",
+		pmicspi_parents, 0x090, 0, 3, 7),
+	MUX_GATE(CLK_TOP_DPILVDS1_SEL, "dpilvds1_sel",
+		dpilvds1_parents, 0x090, 8, 3, 15),
+	MUX_GATE(CLK_TOP_ATB_SEL, "atb_sel",
+		atb_parents, 0x090, 16, 2, 23),
+	MUX_GATE(CLK_TOP_NR_SEL, "nr_sel",
+		nr_parents, 0x090, 24, 3, 31),
+	/* CLK_CFG_6 */
+	MUX_GATE(CLK_TOP_NFI2X_SEL, "nfi2x_sel",
+		nfi2x_parents, 0x0a0, 0, 4, 7),
+	MUX_GATE(CLK_TOP_IRDA_SEL, "irda_sel",
+		irda_parents, 0x0a0, 8, 2, 15),
+	MUX_GATE(CLK_TOP_CCI400_SEL, "cci400_sel",
+		cci400_parents, 0x0a0, 16, 3, 23),
+	MUX_GATE(CLK_TOP_AUD_1_SEL, "aud_1_sel",
+		aud_1_parents, 0x0a0, 24, 2, 31),
+	/* CLK_CFG_7 */
+	MUX_GATE(CLK_TOP_AUD_2_SEL, "aud_2_sel",
+		aud_2_parents, 0x0b0, 0, 2, 7),
+	MUX_GATE(CLK_TOP_MEM_MFG_IN_AS_SEL, "mem_mfg_sel",
+		mem_mfg_parents, 0x0b0, 8, 2, 15),
+	MUX_GATE(CLK_TOP_AXI_MFG_IN_AS_SEL, "axi_mfg_sel",
+		axi_mfg_parents, 0x0b0, 16, 2, 23),
+	MUX_GATE(CLK_TOP_SCAM_SEL, "scam_sel",
+		scam_parents, 0x0b0, 24, 2, 31),
+	/* CLK_CFG_8 */
+	MUX_GATE(CLK_TOP_NFIECC_SEL, "nfiecc_sel",
+		nfiecc_parents, 0x0c0, 0, 3, 7),
+	MUX_GATE(CLK_TOP_PE2_MAC_P0_SEL, "pe2_mac_p0_sel",
+		pe2_mac_p0_parents, 0x0c0, 8, 3, 15),
+	MUX_GATE(CLK_TOP_PE2_MAC_P1_SEL, "pe2_mac_p1_sel",
+		pe2_mac_p0_parents, 0x0c0, 16, 3, 23),
+	MUX_GATE(CLK_TOP_DPILVDS_SEL, "dpilvds_sel",
+		dpilvds_parents, 0x0c0, 24, 3, 31),
+	/* CLK_CFG_9 */
+	MUX_GATE(CLK_TOP_MSDC50_3_HCLK_SEL, "msdc50_3_h_sel",
+		msdc50_0_h_parents, 0x0d0, 0, 3, 7),
+	MUX_GATE(CLK_TOP_HDCP_SEL, "hdcp_sel",
+		hdcp_parents, 0x0d0, 8, 2, 15),
+	MUX_GATE(CLK_TOP_HDCP_24M_SEL, "hdcp_24m_sel",
+		hdcp_24m_parents, 0x0d0, 16, 2, 23),
+	MUX_GATE_FLAGS(CLK_TOP_RTC_SEL, "rtc_sel", rtc_parents, 0x0d0, 24, 2,
+		31, CLK_IS_CRITICAL),
+	/* CLK_CFG_10 */
+	MUX_GATE(CLK_TOP_SPINOR_SEL, "spinor_sel",
+		spinor_parents, 0x500, 0, 4, 7),
+	MUX_GATE(CLK_TOP_APLL_SEL, "apll_sel",
+		apll_parents, 0x500, 8, 4, 15),
+	MUX_GATE(CLK_TOP_APLL2_SEL, "apll2_sel",
+		apll_parents, 0x500, 16, 4, 23),
+	MUX_GATE(CLK_TOP_A1SYS_HP_SEL, "a1sys_hp_sel",
+		a1sys_hp_parents, 0x500, 24, 3, 31),
+	/* CLK_CFG_11 */
+	MUX_GATE(CLK_TOP_A2SYS_HP_SEL, "a2sys_hp_sel",
+		a2sys_hp_parents, 0x510, 0, 3, 7),
+	MUX_GATE(CLK_TOP_ASM_L_SEL, "asm_l_sel",
+		asm_l_parents, 0x510, 8, 2, 15),
+	MUX_GATE(CLK_TOP_ASM_M_SEL, "asm_m_sel",
+		asm_l_parents, 0x510, 16, 2, 23),
+	MUX_GATE(CLK_TOP_ASM_H_SEL, "asm_h_sel",
+		asm_l_parents, 0x510, 24, 2, 31),
+	/* CLK_CFG_12 */
+	MUX_GATE(CLK_TOP_I2SO1_SEL, "i2so1_sel",
+		i2so1_parents, 0x520, 0, 2, 7),
+	MUX_GATE(CLK_TOP_I2SO2_SEL, "i2so2_sel",
+		i2so1_parents, 0x520, 8, 2, 15),
+	MUX_GATE(CLK_TOP_I2SO3_SEL, "i2so3_sel",
+		i2so1_parents, 0x520, 16, 2, 23),
+	MUX_GATE(CLK_TOP_TDMO0_SEL, "tdmo0_sel",
+		i2so1_parents, 0x520, 24, 2, 31),
+	/* CLK_CFG_13 */
+	MUX_GATE(CLK_TOP_TDMO1_SEL, "tdmo1_sel",
+		i2so1_parents, 0x530, 0, 2, 7),
+	MUX_GATE(CLK_TOP_I2SI1_SEL, "i2si1_sel",
+		i2so1_parents, 0x530, 8, 2, 15),
+	MUX_GATE(CLK_TOP_I2SI2_SEL, "i2si2_sel",
+		i2so1_parents, 0x530, 16, 2, 23),
+	MUX_GATE(CLK_TOP_I2SI3_SEL, "i2si3_sel",
+		i2so1_parents, 0x530, 24, 2, 31),
+	/* CLK_CFG_14 */
+	MUX_GATE(CLK_TOP_ETHER_125M_SEL, "ether_125m_sel",
+		ether_125m_parents, 0x540, 0, 2, 7),
+	MUX_GATE(CLK_TOP_ETHER_50M_SEL, "ether_50m_sel",
+		ether_50m_parents, 0x540, 8, 2, 15),
+	MUX_GATE(CLK_TOP_JPGDEC_SEL, "jpgdec_sel",
+		jpgdec_parents, 0x540, 16, 4, 23),
+	MUX_GATE(CLK_TOP_SPISLV_SEL, "spislv_sel",
+		spislv_parents, 0x540, 24, 3, 31),
+	/* CLK_CFG_15 */
+	MUX_GATE(CLK_TOP_ETHER_50M_RMII_SEL, "ether_sel",
+		ether_parents, 0x550, 0, 2, 7),
+	MUX_GATE(CLK_TOP_CAM2TG_SEL, "cam2tg_sel",
+		camtg_parents, 0x550, 8, 4, 15),
+	MUX_GATE(CLK_TOP_DI_SEL, "di_sel",
+		di_parents, 0x550, 16, 3, 23),
+	MUX_GATE(CLK_TOP_TVD_SEL, "tvd_sel",
+		tvd_parents, 0x550, 24, 2, 31),
+	/* CLK_CFG_16 */
+	MUX_GATE(CLK_TOP_I2C_SEL, "i2c_sel",
+		i2c_parents, 0x560, 0, 3, 7),
+	MUX_GATE(CLK_TOP_PWM_INFRA_SEL, "pwm_infra_sel",
+		pwm_parents, 0x560, 8, 2, 15),
+	MUX_GATE(CLK_TOP_MSDC0P_AES_SEL, "msdc0p_aes_sel",
+		msdc0p_aes_parents, 0x560, 16, 2, 23),
+	MUX_GATE(CLK_TOP_CMSYS_SEL, "cmsys_sel",
+		cmsys_parents, 0x560, 24, 3, 31),
+	/* CLK_CFG_17 */
+	MUX_GATE(CLK_TOP_GCPU_SEL, "gcpu_sel",
+		gcpu_parents, 0x570, 0, 3, 7),
+	/* CLK_AUDDIV_4 */
+	MUX(CLK_TOP_AUD_APLL1_SEL, "aud_apll1_sel",
+		aud_apll1_parents, 0x134, 0, 1),
+	MUX(CLK_TOP_AUD_APLL2_SEL, "aud_apll2_sel",
+		aud_apll2_parents, 0x134, 1, 1),
+	MUX(CLK_TOP_DA_AUDULL_VTX_6P5M_SEL, "audull_vtx_sel",
+		audull_vtx_parents, 0x134, 31, 1),
+};
+
+static const char * const mcu_mp0_parents[] = {
+	"clk26m",
+	"armca35pll_ck",
+	"f_mp0_pll1_ck",
+	"f_mp0_pll2_ck"
+};
+
+static const char * const mcu_mp2_parents[] = {
+	"clk26m",
+	"armca72pll_ck",
+	"f_big_pll1_ck",
+	"f_big_pll2_ck"
+};
+
+static const char * const mcu_bus_parents[] = {
+	"clk26m",
+	"cci400_sel",
+	"f_bus_pll1_ck",
+	"f_bus_pll2_ck"
+};
+
+static struct mtk_composite mcu_muxes[] = {
+	/* mp0_pll_divider_cfg */
+	MUX_GATE_FLAGS(CLK_MCU_MP0_SEL, "mcu_mp0_sel", mcu_mp0_parents, 0x7A0,
+		9, 2, -1, CLK_IS_CRITICAL),
+	/* mp2_pll_divider_cfg */
+	MUX_GATE_FLAGS(CLK_MCU_MP2_SEL, "mcu_mp2_sel", mcu_mp2_parents, 0x7A8,
+		9, 2, -1, CLK_IS_CRITICAL),
+	/* bus_pll_divider_cfg */
+	MUX_GATE_FLAGS(CLK_MCU_BUS_SEL, "mcu_bus_sel", mcu_bus_parents, 0x7C0,
+		9, 2, -1, CLK_IS_CRITICAL),
+};
+
+static const struct mtk_clk_divider top_adj_divs[] = {
+	DIV_ADJ(CLK_TOP_APLL_DIV0, "apll_div0", "i2so1_sel", 0x124, 0, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV1, "apll_div1", "i2so2_sel", 0x124, 8, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV2, "apll_div2", "i2so3_sel", 0x124, 16, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV3, "apll_div3", "tdmo0_sel", 0x124, 24, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV4, "apll_div4", "tdmo1_sel", 0x128, 0, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV5, "apll_div5", "i2si1_sel", 0x128, 8, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV6, "apll_div6", "i2si2_sel", 0x128, 16, 8),
+	DIV_ADJ(CLK_TOP_APLL_DIV7, "apll_div7", "i2si3_sel", 0x128, 24, 8),
+};
+
+static const struct mtk_gate_regs top_cg_regs = {
+	.set_ofs = 0x120,
+	.clr_ofs = 0x120,
+	.sta_ofs = 0x120,
+};
+
+#define GATE_TOP(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &top_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+static const struct mtk_gate top_clks[] = {
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN0, "apll_div_pdn0", "i2so1_sel", 0),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN1, "apll_div_pdn1", "i2so2_sel", 1),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN2, "apll_div_pdn2", "i2so3_sel", 2),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN3, "apll_div_pdn3", "tdmo0_sel", 3),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN4, "apll_div_pdn4", "tdmo1_sel", 4),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN5, "apll_div_pdn5", "i2si1_sel", 5),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN6, "apll_div_pdn6", "i2si2_sel", 6),
+	GATE_TOP(CLK_TOP_APLL_DIV_PDN7, "apll_div_pdn7", "i2si3_sel", 7),
+};
+
+static const struct mtk_gate_regs infra_cg_regs = {
+	.set_ofs = 0x40,
+	.clr_ofs = 0x44,
+	.sta_ofs = 0x40,
+};
+
+#define GATE_INFRA(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &infra_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+static const struct mtk_gate infra_clks[] = {
+	GATE_INFRA(CLK_INFRA_DBGCLK, "infra_dbgclk", "axi_sel", 0),
+	GATE_INFRA(CLK_INFRA_GCE, "infra_gce", "axi_sel", 6),
+	GATE_INFRA(CLK_INFRA_M4U, "infra_m4u", "mem_sel", 8),
+	GATE_INFRA(CLK_INFRA_KP, "infra_kp", "axi_sel", 16),
+	GATE_INFRA(CLK_INFRA_AO_SPI0, "infra_ao_spi0", "spi_sel", 24),
+	GATE_INFRA(CLK_INFRA_AO_SPI1, "infra_ao_spi1", "spislv_sel", 25),
+	GATE_INFRA(CLK_INFRA_AO_UART5, "infra_ao_uart5", "axi_sel", 26),
+};
+
+static const struct mtk_gate_regs peri0_cg_regs = {
+	.set_ofs = 0x8,
+	.clr_ofs = 0x10,
+	.sta_ofs = 0x18,
+};
+
+static const struct mtk_gate_regs peri1_cg_regs = {
+	.set_ofs = 0xc,
+	.clr_ofs = 0x14,
+	.sta_ofs = 0x1c,
+};
+
+static const struct mtk_gate_regs peri2_cg_regs = {
+	.set_ofs = 0x42c,
+	.clr_ofs = 0x42c,
+	.sta_ofs = 0x42c,
+};
+
+#define GATE_PERI0(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &peri0_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+#define GATE_PERI1(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &peri1_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_setclr,	\
+	}
+
+#define GATE_PERI2(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &peri2_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
+	}
+
+static const struct mtk_gate peri_clks[] = {
+	/* PERI0 */
+	GATE_PERI0(CLK_PERI_NFI, "per_nfi",
+		"axi_sel", 0),
+	GATE_PERI0(CLK_PERI_THERM, "per_therm",
+		"axi_sel", 1),
+	GATE_PERI0(CLK_PERI_PWM0, "per_pwm0",
+		"pwm_sel", 2),
+	GATE_PERI0(CLK_PERI_PWM1, "per_pwm1",
+		"pwm_sel", 3),
+	GATE_PERI0(CLK_PERI_PWM2, "per_pwm2",
+		"pwm_sel", 4),
+	GATE_PERI0(CLK_PERI_PWM3, "per_pwm3",
+		"pwm_sel", 5),
+	GATE_PERI0(CLK_PERI_PWM4, "per_pwm4",
+		"pwm_sel", 6),
+	GATE_PERI0(CLK_PERI_PWM5, "per_pwm5",
+		"pwm_sel", 7),
+	GATE_PERI0(CLK_PERI_PWM6, "per_pwm6",
+		"pwm_sel", 8),
+	GATE_PERI0(CLK_PERI_PWM7, "per_pwm7",
+		"pwm_sel", 9),
+	GATE_PERI0(CLK_PERI_PWM, "per_pwm",
+		"pwm_sel", 10),
+	GATE_PERI0(CLK_PERI_AP_DMA, "per_ap_dma",
+		"axi_sel", 13),
+	GATE_PERI0(CLK_PERI_MSDC30_0, "per_msdc30_0",
+		"msdc50_0_sel", 14),
+	GATE_PERI0(CLK_PERI_MSDC30_1, "per_msdc30_1",
+		"msdc30_1_sel", 15),
+	GATE_PERI0(CLK_PERI_MSDC30_2, "per_msdc30_2",
+		"msdc30_2_sel", 16),
+	GATE_PERI0(CLK_PERI_MSDC30_3, "per_msdc30_3",
+		"msdc30_3_sel", 17),
+	GATE_PERI0(CLK_PERI_UART0, "per_uart0",
+		"uart_sel", 20),
+	GATE_PERI0(CLK_PERI_UART1, "per_uart1",
+		"uart_sel", 21),
+	GATE_PERI0(CLK_PERI_UART2, "per_uart2",
+		"uart_sel", 22),
+	GATE_PERI0(CLK_PERI_UART3, "per_uart3",
+		"uart_sel", 23),
+	GATE_PERI0(CLK_PERI_I2C0, "per_i2c0",
+		"axi_sel", 24),
+	GATE_PERI0(CLK_PERI_I2C1, "per_i2c1",
+		"axi_sel", 25),
+	GATE_PERI0(CLK_PERI_I2C2, "per_i2c2",
+		"axi_sel", 26),
+	GATE_PERI0(CLK_PERI_I2C3, "per_i2c3",
+		"axi_sel", 27),
+	GATE_PERI0(CLK_PERI_I2C4, "per_i2c4",
+		"axi_sel", 28),
+	GATE_PERI0(CLK_PERI_AUXADC, "per_auxadc",
+		"ltepll_fs26m", 29),
+	GATE_PERI0(CLK_PERI_SPI0, "per_spi0",
+		"spi_sel", 30),
+	/* PERI1 */
+	GATE_PERI1(CLK_PERI_SPI, "per_spi",
+		"spinor_sel", 1),
+	GATE_PERI1(CLK_PERI_I2C5, "per_i2c5",
+		"axi_sel", 3),
+	GATE_PERI1(CLK_PERI_SPI2, "per_spi2",
+		"spi_sel", 5),
+	GATE_PERI1(CLK_PERI_SPI3, "per_spi3",
+		"spi_sel", 6),
+	GATE_PERI1(CLK_PERI_SPI5, "per_spi5",
+		"spi_sel", 8),
+	GATE_PERI1(CLK_PERI_UART4, "per_uart4",
+		"uart_sel", 9),
+	GATE_PERI1(CLK_PERI_SFLASH, "per_sflash",
+		"uart_sel", 11),
+	GATE_PERI1(CLK_PERI_GMAC, "per_gmac",
+		"uart_sel", 12),
+	GATE_PERI1(CLK_PERI_PCIE0, "per_pcie0",
+		"uart_sel", 14),
+	GATE_PERI1(CLK_PERI_PCIE1, "per_pcie1",
+		"uart_sel", 15),
+	GATE_PERI1(CLK_PERI_GMAC_PCLK, "per_gmac_pclk",
+		"uart_sel", 16),
+	/* PERI2 */
+	GATE_PERI2(CLK_PERI_MSDC50_0_EN, "per_msdc50_0_en",
+		"msdc50_0_sel", 0),
+	GATE_PERI2(CLK_PERI_MSDC30_1_EN, "per_msdc30_1_en",
+		"msdc30_1_sel", 1),
+	GATE_PERI2(CLK_PERI_MSDC30_2_EN, "per_msdc30_2_en",
+		"msdc30_2_sel", 2),
+	GATE_PERI2(CLK_PERI_MSDC30_3_EN, "per_msdc30_3_en",
+		"msdc30_3_sel", 3),
+	GATE_PERI2(CLK_PERI_MSDC50_0_HCLK_EN, "per_msdc50_0_h",
+		"msdc50_0_h_sel", 4),
+	GATE_PERI2(CLK_PERI_MSDC50_3_HCLK_EN, "per_msdc50_3_h",
+		"msdc50_3_h_sel", 5),
+};
+
+#define MT2712_PLL_FMAX		(3000UL * MHZ)
+
+#define CON0_MT2712_RST_BAR	BIT(24)
+
+#define PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
+			_pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,	\
+			_tuner_en_bit, _pcw_reg, _pcw_shift,		\
+			_div_table) {					\
+		.id = _id,						\
+		.name = _name,						\
+		.reg = _reg,						\
+		.pwr_reg = _pwr_reg,					\
+		.en_mask = _en_mask,					\
+		.flags = _flags,					\
+		.rst_bar_mask = CON0_MT2712_RST_BAR,			\
+		.fmax = MT2712_PLL_FMAX,				\
+		.pcwbits = _pcwbits,					\
+		.pd_reg = _pd_reg,					\
+		.pd_shift = _pd_shift,					\
+		.tuner_reg = _tuner_reg,				\
+		.tuner_en_reg = _tuner_en_reg,				\
+		.tuner_en_bit = _tuner_en_bit,				\
+		.pcw_reg = _pcw_reg,					\
+		.pcw_shift = _pcw_shift,				\
+		.div_table = _div_table,				\
+	}
+
+#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
+			_pd_reg, _pd_shift, _tuner_reg, _tuner_en_reg,	\
+			_tuner_en_bit, _pcw_reg, _pcw_shift)		\
+		PLL_B(_id, _name, _reg, _pwr_reg, _en_mask, _flags,	\
+			_pcwbits, _pd_reg, _pd_shift, _tuner_reg,	\
+			_tuner_en_reg, _tuner_en_bit, _pcw_reg,		\
+			_pcw_shift, NULL)
+
+static const struct mtk_pll_div_table armca35pll_div_table[] = {
+	{ .div = 0, .freq = MT2712_PLL_FMAX },
+	{ .div = 1, .freq = 1202500000 },
+	{ .div = 2, .freq = 500500000 },
+	{ .div = 3, .freq = 315250000 },
+	{ .div = 4, .freq = 157625000 },
+	{ } /* sentinel */
+};
+
+static const struct mtk_pll_div_table armca72pll_div_table[] = {
+	{ .div = 0, .freq = MT2712_PLL_FMAX },
+	{ .div = 1, .freq = 994500000 },
+	{ .div = 2, .freq = 520000000 },
+	{ .div = 3, .freq = 315250000 },
+	{ .div = 4, .freq = 157625000 },
+	{ } /* sentinel */
+};
+
+static const struct mtk_pll_div_table mmpll_div_table[] = {
+	{ .div = 0, .freq = MT2712_PLL_FMAX },
+	{ .div = 1, .freq = 1001000000 },
+	{ .div = 2, .freq = 601250000 },
+	{ .div = 3, .freq = 250250000 },
+	{ .div = 4, .freq = 125125000 },
+	{ } /* sentinel */
+};
+
+static const struct mtk_pll_data plls[] = {
+	PLL(CLK_APMIXED_MAINPLL, "mainpll", 0x0230, 0x023C, 0xf0000101,
+		HAVE_RST_BAR, 31, 0x0230, 4, 0, 0, 0, 0x0234, 0),
+	PLL(CLK_APMIXED_UNIVPLL, "univpll", 0x0240, 0x024C, 0xfe000101,
+		HAVE_RST_BAR, 31, 0x0240, 4, 0, 0, 0, 0x0244, 0),
+	PLL(CLK_APMIXED_VCODECPLL, "vcodecpll", 0x0320, 0x032C, 0xc0000101,
+		0, 31, 0x0320, 4, 0, 0, 0, 0x0324, 0),
+	PLL(CLK_APMIXED_VENCPLL, "vencpll", 0x0280, 0x028C, 0x00000101,
+		0, 31, 0x0280, 4, 0, 0, 0, 0x0284, 0),
+	PLL(CLK_APMIXED_APLL1, "apll1", 0x0330, 0x0340, 0x00000101,
+		0, 31, 0x0330, 4, 0x0338, 0x0014, 0, 0x0334, 0),
+	PLL(CLK_APMIXED_APLL2, "apll2", 0x0350, 0x0360, 0x00000101,
+		0, 31, 0x0350, 4, 0x0358, 0x0014, 1, 0x0354, 0),
+	PLL(CLK_APMIXED_LVDSPLL, "lvdspll", 0x0370, 0x037c, 0x00000101,
+		0, 31, 0x0370, 4, 0, 0, 0, 0x0374, 0),
+	PLL(CLK_APMIXED_LVDSPLL2, "lvdspll2", 0x0390, 0x039C, 0x00000101,
+		0, 31, 0x0390, 4, 0, 0, 0, 0x0394, 0),
+	PLL(CLK_APMIXED_MSDCPLL, "msdcpll", 0x0270, 0x027C, 0x00000101,
+		0, 31, 0x0270, 4, 0, 0, 0, 0x0274, 0),
+	PLL(CLK_APMIXED_MSDCPLL2, "msdcpll2", 0x0410, 0x041C, 0x00000101,
+		0, 31, 0x0410, 4, 0, 0, 0, 0x0414, 0),
+	PLL(CLK_APMIXED_TVDPLL, "tvdpll", 0x0290, 0x029C, 0xc0000101,
+		0, 31, 0x0290, 4, 0, 0, 0, 0x0294, 0),
+	PLL_B(CLK_APMIXED_MMPLL, "mmpll", 0x0250, 0x0260, 0x00000101,
+		0, 31, 0x0250, 4, 0, 0, 0, 0x0254, 0,
+		mmpll_div_table),
+	PLL_B(CLK_APMIXED_ARMCA35PLL, "armca35pll", 0x0100, 0x0110, 0xf0000101,
+		HAVE_RST_BAR, 31, 0x0100, 4, 0, 0, 0, 0x0104, 0,
+		armca35pll_div_table),
+	PLL_B(CLK_APMIXED_ARMCA72PLL, "armca72pll", 0x0210, 0x0220, 0x00000101,
+		0, 31, 0x0210, 4, 0, 0, 0, 0x0214, 0,
+		armca72pll_div_table),
+	PLL(CLK_APMIXED_ETHERPLL, "etherpll", 0x0300, 0x030C, 0xc0000101,
+		0, 31, 0x0300, 4, 0, 0, 0, 0x0304, 0),
+};
+
+static int clk_mt2712_apmixed_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);
+
+	mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls), clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static struct clk_onecell_data *top_clk_data;
+
+static void clk_mt2712_top_init_early(struct device_node *node)
+{
+	int r, i;
+
+	if (!top_clk_data) {
+		top_clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
+
+		for (i = 0; i < CLK_TOP_NR_CLK; i++)
+			top_clk_data->clks[i] = ERR_PTR(-EPROBE_DEFER);
+	}
+
+	mtk_clk_register_factors(top_early_divs, ARRAY_SIZE(top_early_divs),
+			top_clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, top_clk_data);
+	if (r)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+}
+
+CLK_OF_DECLARE_DRIVER(mt2712_topckgen, "mediatek,mt2712-topckgen",
+			clk_mt2712_top_init_early);
+
+static int clk_mt2712_top_probe(struct platform_device *pdev)
+{
+	int r, i;
+	struct device_node *node = pdev->dev.of_node;
+	void __iomem *base;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		pr_err("%s(): ioremap failed\n", __func__);
+		return PTR_ERR(base);
+	}
+
+	if (!top_clk_data) {
+		top_clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
+	} else {
+		for (i = 0; i < CLK_TOP_NR_CLK; i++) {
+			if (top_clk_data->clks[i] == ERR_PTR(-EPROBE_DEFER))
+				top_clk_data->clks[i] = ERR_PTR(-ENOENT);
+		}
+	}
+
+	mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
+			top_clk_data);
+	mtk_clk_register_factors(top_early_divs, ARRAY_SIZE(top_early_divs),
+			top_clk_data);
+	mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs), top_clk_data);
+	mtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes), base,
+			&mt2712_clk_lock, top_clk_data);
+	mtk_clk_register_dividers(top_adj_divs, ARRAY_SIZE(top_adj_divs), base,
+			&mt2712_clk_lock, top_clk_data);
+	mtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks),
+			top_clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, top_clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static int clk_mt2712_infra_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_INFRA_NR_CLK);
+
+	mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	mtk_register_reset_controller(node, 2, 0x30);
+
+	return r;
+}
+
+static int clk_mt2712_peri_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);
+
+	mtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),
+			clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	mtk_register_reset_controller(node, 2, 0);
+
+	return r;
+}
+
+static int clk_mt2712_mcu_probe(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+	void __iomem *base;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base)) {
+		pr_err("%s(): ioremap failed\n", __func__);
+		return PTR_ERR(base);
+	}
+
+	clk_data = mtk_alloc_clk_data(CLK_MCU_NR_CLK);
+
+	mtk_clk_register_composites(mcu_muxes, ARRAY_SIZE(mcu_muxes), base,
+			&mt2712_clk_lock, clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+
+	if (r != 0)
+		pr_err("%s(): could not register clock provider: %d\n",
+			__func__, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt2712[] = {
+	{
+		.compatible = "mediatek,mt2712-apmixedsys",
+		.data = clk_mt2712_apmixed_probe,
+	}, {
+		.compatible = "mediatek,mt2712-topckgen",
+		.data = clk_mt2712_top_probe,
+	}, {
+		.compatible = "mediatek,mt2712-infracfg",
+		.data = clk_mt2712_infra_probe,
+	}, {
+		.compatible = "mediatek,mt2712-pericfg",
+		.data = clk_mt2712_peri_probe,
+	}, {
+		.compatible = "mediatek,mt2712-mcucfg",
+		.data = clk_mt2712_mcu_probe,
+	}, {
+		/* sentinel */
+	}
+};
+
+static int clk_mt2712_probe(struct platform_device *pdev)
+{
+	int (*clk_probe)(struct platform_device *);
+	int r;
+
+	clk_probe = of_device_get_match_data(&pdev->dev);
+	if (!clk_probe)
+		return -EINVAL;
+
+	r = clk_probe(pdev);
+	if (r != 0)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	return r;
+}
+
+static struct platform_driver clk_mt2712_drv = {
+	.probe = clk_mt2712_probe,
+	.driver = {
+		.name = "clk-mt2712",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_clk_mt2712,
+	},
+};
+
+static int __init clk_mt2712_init(void)
+{
+	return platform_driver_register(&clk_mt2712_drv);
+}
+
+arch_initcall(clk_mt2712_init);
diff --git a/drivers/clk/mediatek/clk-mt7622-aud.c b/drivers/clk/mediatek/clk-mt7622-aud.c
new file mode 100644
index 000000000000..0a1109ff65b9
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt7622-aud.c
@@ -0,0 +1,200 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Chen Zhong <chen.zhong@mediatek.com>
+ *	   Sean Wang <sean.wang@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt7622-clk.h>
+
+#define GATE_AUDIO0(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &audio0_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+#define GATE_AUDIO1(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &audio1_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+#define GATE_AUDIO2(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &audio2_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+#define GATE_AUDIO3(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &audio3_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr,	\
+	}
+
+static const struct mtk_gate_regs audio0_cg_regs = {
+	.set_ofs = 0x0,
+	.clr_ofs = 0x0,
+	.sta_ofs = 0x0,
+};
+
+static const struct mtk_gate_regs audio1_cg_regs = {
+	.set_ofs = 0x10,
+	.clr_ofs = 0x10,
+	.sta_ofs = 0x10,
+};
+
+static const struct mtk_gate_regs audio2_cg_regs = {
+	.set_ofs = 0x14,
+	.clr_ofs = 0x14,
+	.sta_ofs = 0x14,
+};
+
+static const struct mtk_gate_regs audio3_cg_regs = {
+	.set_ofs = 0x634,
+	.clr_ofs = 0x634,
+	.sta_ofs = 0x634,
+};
+
+static const struct mtk_gate audio_clks[] = {
+	/* AUDIO0 */
+	GATE_AUDIO0(CLK_AUDIO_AFE, "audio_afe", "rtc", 2),
+	GATE_AUDIO0(CLK_AUDIO_HDMI, "audio_hdmi", "apll1_ck_sel", 20),
+	GATE_AUDIO0(CLK_AUDIO_SPDF, "audio_spdf", "apll1_ck_sel", 21),
+	GATE_AUDIO0(CLK_AUDIO_APLL, "audio_apll", "apll1_ck_sel", 23),
+	/* AUDIO1 */
+	GATE_AUDIO1(CLK_AUDIO_I2SIN1, "audio_i2sin1", "a1sys_hp_sel", 0),
+	GATE_AUDIO1(CLK_AUDIO_I2SIN2, "audio_i2sin2", "a1sys_hp_sel", 1),
+	GATE_AUDIO1(CLK_AUDIO_I2SIN3, "audio_i2sin3", "a1sys_hp_sel", 2),
+	GATE_AUDIO1(CLK_AUDIO_I2SIN4, "audio_i2sin4", "a1sys_hp_sel", 3),
+	GATE_AUDIO1(CLK_AUDIO_I2SO1, "audio_i2so1", "a1sys_hp_sel", 6),
+	GATE_AUDIO1(CLK_AUDIO_I2SO2, "audio_i2so2", "a1sys_hp_sel", 7),
+	GATE_AUDIO1(CLK_AUDIO_I2SO3, "audio_i2so3", "a1sys_hp_sel", 8),
+	GATE_AUDIO1(CLK_AUDIO_I2SO4, "audio_i2so4", "a1sys_hp_sel", 9),
+	GATE_AUDIO1(CLK_AUDIO_ASRCI1, "audio_asrci1", "asm_h_sel", 12),
+	GATE_AUDIO1(CLK_AUDIO_ASRCI2, "audio_asrci2", "asm_h_sel", 13),
+	GATE_AUDIO1(CLK_AUDIO_ASRCO1, "audio_asrco1", "asm_h_sel", 14),
+	GATE_AUDIO1(CLK_AUDIO_ASRCO2, "audio_asrco2", "asm_h_sel", 15),
+	GATE_AUDIO1(CLK_AUDIO_INTDIR, "audio_intdir", "intdir_sel", 20),
+	GATE_AUDIO1(CLK_AUDIO_A1SYS, "audio_a1sys", "a1sys_hp_sel", 21),
+	GATE_AUDIO1(CLK_AUDIO_A2SYS, "audio_a2sys", "a2sys_hp_sel", 22),
+	GATE_AUDIO1(CLK_AUDIO_AFE_CONN, "audio_afe_conn", "a1sys_hp_sel", 23),
+	/* AUDIO2 */
+	GATE_AUDIO2(CLK_AUDIO_UL1, "audio_ul1", "a1sys_hp_sel", 0),
+	GATE_AUDIO2(CLK_AUDIO_UL2, "audio_ul2", "a1sys_hp_sel", 1),
+	GATE_AUDIO2(CLK_AUDIO_UL3, "audio_ul3", "a1sys_hp_sel", 2),
+	GATE_AUDIO2(CLK_AUDIO_UL4, "audio_ul4", "a1sys_hp_sel", 3),
+	GATE_AUDIO2(CLK_AUDIO_UL5, "audio_ul5", "a1sys_hp_sel", 4),
+	GATE_AUDIO2(CLK_AUDIO_UL6, "audio_ul6", "a1sys_hp_sel", 5),
+	GATE_AUDIO2(CLK_AUDIO_DL1, "audio_dl1", "a1sys_hp_sel", 6),
+	GATE_AUDIO2(CLK_AUDIO_DL2, "audio_dl2", "a1sys_hp_sel", 7),
+	GATE_AUDIO2(CLK_AUDIO_DL3, "audio_dl3", "a1sys_hp_sel", 8),
+	GATE_AUDIO2(CLK_AUDIO_DL4, "audio_dl4", "a1sys_hp_sel", 9),
+	GATE_AUDIO2(CLK_AUDIO_DL5, "audio_dl5", "a1sys_hp_sel", 10),
+	GATE_AUDIO2(CLK_AUDIO_DL6, "audio_dl6", "a1sys_hp_sel", 11),
+	GATE_AUDIO2(CLK_AUDIO_DLMCH, "audio_dlmch", "a1sys_hp_sel", 12),
+	GATE_AUDIO2(CLK_AUDIO_ARB1, "audio_arb1", "a1sys_hp_sel", 13),
+	GATE_AUDIO2(CLK_AUDIO_AWB, "audio_awb", "a1sys_hp_sel", 14),
+	GATE_AUDIO2(CLK_AUDIO_AWB2, "audio_awb2", "a1sys_hp_sel", 15),
+	GATE_AUDIO2(CLK_AUDIO_DAI, "audio_dai", "a1sys_hp_sel", 16),
+	GATE_AUDIO2(CLK_AUDIO_MOD, "audio_mod", "a1sys_hp_sel", 17),
+	/* AUDIO3 */
+	GATE_AUDIO3(CLK_AUDIO_ASRCI3, "audio_asrci3", "asm_h_sel", 2),
+	GATE_AUDIO3(CLK_AUDIO_ASRCI4, "audio_asrci4", "asm_h_sel", 3),
+	GATE_AUDIO3(CLK_AUDIO_ASRCO3, "audio_asrco3", "asm_h_sel", 6),
+	GATE_AUDIO3(CLK_AUDIO_ASRCO4, "audio_asrco4", "asm_h_sel", 7),
+	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC1, "audio_mem_asrc1", "asm_h_sel", 10),
+	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC2, "audio_mem_asrc2", "asm_h_sel", 11),
+	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC3, "audio_mem_asrc3", "asm_h_sel", 12),
+	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC4, "audio_mem_asrc4", "asm_h_sel", 13),
+	GATE_AUDIO3(CLK_AUDIO_MEM_ASRC5, "audio_mem_asrc5", "asm_h_sel", 14),
+};
+
+static int clk_mt7622_audiosys_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_AUDIO_NR_CLK);
+
+	mtk_clk_register_gates(node, audio_clks, ARRAY_SIZE(audio_clks),
+			       clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r) {
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+		return r;
+	}
+
+	return devm_of_platform_populate(&pdev->dev);
+}
+
+static const struct of_device_id of_match_clk_mt7622_aud[] = {
+	{
+		.compatible = "mediatek,mt7622-audsys",
+		.data = clk_mt7622_audiosys_init,
+	}, {
+		/* sentinel */
+	}
+};
+
+static int clk_mt7622_aud_probe(struct platform_device *pdev)
+{
+	int (*clk_init)(struct platform_device *);
+	int r;
+
+	clk_init = of_device_get_match_data(&pdev->dev);
+	if (!clk_init)
+		return -EINVAL;
+
+	r = clk_init(pdev);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	return r;
+}
+
+static struct platform_driver clk_mt7622_aud_drv = {
+	.probe = clk_mt7622_aud_probe,
+	.driver = {
+		.name = "clk-mt7622-aud",
+		.of_match_table = of_match_clk_mt7622_aud,
+	},
+};
+
+builtin_platform_driver(clk_mt7622_aud_drv);
diff --git a/drivers/clk/mediatek/clk-mt7622-eth.c b/drivers/clk/mediatek/clk-mt7622-eth.c
new file mode 100644
index 000000000000..6328127bbb3c
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt7622-eth.c
@@ -0,0 +1,156 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Chen Zhong <chen.zhong@mediatek.com>
+ *	   Sean Wang <sean.wang@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt7622-clk.h>
+
+#define GATE_ETH(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &eth_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
+	}
+
+static const struct mtk_gate_regs eth_cg_regs = {
+	.set_ofs = 0x30,
+	.clr_ofs = 0x30,
+	.sta_ofs = 0x30,
+};
+
+static const struct mtk_gate eth_clks[] = {
+	GATE_ETH(CLK_ETH_HSDMA_EN, "eth_hsdma_en", "eth_sel", 5),
+	GATE_ETH(CLK_ETH_ESW_EN, "eth_esw_en", "eth_500m", 6),
+	GATE_ETH(CLK_ETH_GP2_EN, "eth_gp2_en", "txclk_src_pre", 7),
+	GATE_ETH(CLK_ETH_GP1_EN, "eth_gp1_en", "txclk_src_pre", 8),
+	GATE_ETH(CLK_ETH_GP0_EN, "eth_gp0_en", "txclk_src_pre", 9),
+};
+
+static const struct mtk_gate_regs sgmii_cg_regs = {
+	.set_ofs = 0xE4,
+	.clr_ofs = 0xE4,
+	.sta_ofs = 0xE4,
+};
+
+#define GATE_SGMII(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &sgmii_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
+	}
+
+static const struct mtk_gate sgmii_clks[] = {
+	GATE_SGMII(CLK_SGMII_TX250M_EN, "sgmii_tx250m_en",
+		   "ssusb_tx250m", 2),
+	GATE_SGMII(CLK_SGMII_RX250M_EN, "sgmii_rx250m_en",
+		   "ssusb_eq_rx250m", 3),
+	GATE_SGMII(CLK_SGMII_CDR_REF, "sgmii_cdr_ref",
+		   "ssusb_cdr_ref", 4),
+	GATE_SGMII(CLK_SGMII_CDR_FB, "sgmii_cdr_fb",
+		   "ssusb_cdr_fb", 5),
+};
+
+static int clk_mt7622_ethsys_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_ETH_NR_CLK);
+
+	mtk_clk_register_gates(node, eth_clks, ARRAY_SIZE(eth_clks),
+			       clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	mtk_register_reset_controller(node, 1, 0x34);
+
+	return r;
+}
+
+static int clk_mt7622_sgmiisys_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_SGMII_NR_CLK);
+
+	mtk_clk_register_gates(node, sgmii_clks, ARRAY_SIZE(sgmii_clks),
+			       clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt7622_eth[] = {
+	{
+		.compatible = "mediatek,mt7622-ethsys",
+		.data = clk_mt7622_ethsys_init,
+	}, {
+		.compatible = "mediatek,mt7622-sgmiisys",
+		.data = clk_mt7622_sgmiisys_init,
+	}, {
+		/* sentinel */
+	}
+};
+
+static int clk_mt7622_eth_probe(struct platform_device *pdev)
+{
+	int (*clk_init)(struct platform_device *);
+	int r;
+
+	clk_init = of_device_get_match_data(&pdev->dev);
+	if (!clk_init)
+		return -EINVAL;
+
+	r = clk_init(pdev);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	return r;
+}
+
+static struct platform_driver clk_mt7622_eth_drv = {
+	.probe = clk_mt7622_eth_probe,
+	.driver = {
+		.name = "clk-mt7622-eth",
+		.of_match_table = of_match_clk_mt7622_eth,
+	},
+};
+
+builtin_platform_driver(clk_mt7622_eth_drv);
diff --git a/drivers/clk/mediatek/clk-mt7622-hif.c b/drivers/clk/mediatek/clk-mt7622-hif.c
new file mode 100644
index 000000000000..a6e8534276c6
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt7622-hif.c
@@ -0,0 +1,169 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Chen Zhong <chen.zhong@mediatek.com>
+ *	   Sean Wang <sean.wang@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+
+#include <dt-bindings/clock/mt7622-clk.h>
+
+#define GATE_PCIE(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &pcie_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
+	}
+
+#define GATE_SSUSB(_id, _name, _parent, _shift) {	\
+		.id = _id,				\
+		.name = _name,				\
+		.parent_name = _parent,			\
+		.regs = &ssusb_cg_regs,			\
+		.shift = _shift,			\
+		.ops = &mtk_clk_gate_ops_no_setclr_inv,	\
+	}
+
+static const struct mtk_gate_regs pcie_cg_regs = {
+	.set_ofs = 0x30,
+	.clr_ofs = 0x30,
+	.sta_ofs = 0x30,
+};
+
+static const struct mtk_gate_regs ssusb_cg_regs = {
+	.set_ofs = 0x30,
+	.clr_ofs = 0x30,
+	.sta_ofs = 0x30,
+};
+
+static const struct mtk_gate ssusb_clks[] = {
+	GATE_SSUSB(CLK_SSUSB_U2_PHY_1P_EN, "ssusb_u2_phy_1p",
+		   "to_u2_phy_1p", 0),
+	GATE_SSUSB(CLK_SSUSB_U2_PHY_EN, "ssusb_u2_phy_en", "to_u2_phy", 1),
+	GATE_SSUSB(CLK_SSUSB_REF_EN, "ssusb_ref_en", "to_usb3_ref", 5),
+	GATE_SSUSB(CLK_SSUSB_SYS_EN, "ssusb_sys_en", "to_usb3_sys", 6),
+	GATE_SSUSB(CLK_SSUSB_MCU_EN, "ssusb_mcu_en", "axi_sel", 7),
+	GATE_SSUSB(CLK_SSUSB_DMA_EN, "ssusb_dma_en", "hif_sel", 8),
+};
+
+static const struct mtk_gate pcie_clks[] = {
+	GATE_PCIE(CLK_PCIE_P1_AUX_EN, "pcie_p1_aux_en", "p1_1mhz", 12),
+	GATE_PCIE(CLK_PCIE_P1_OBFF_EN, "pcie_p1_obff_en", "free_run_4mhz", 13),
+	GATE_PCIE(CLK_PCIE_P1_AHB_EN, "pcie_p1_ahb_en", "axi_sel", 14),
+	GATE_PCIE(CLK_PCIE_P1_AXI_EN, "pcie_p1_axi_en", "hif_sel", 15),
+	GATE_PCIE(CLK_PCIE_P1_MAC_EN, "pcie_p1_mac_en", "pcie1_mac_en", 16),
+	GATE_PCIE(CLK_PCIE_P1_PIPE_EN, "pcie_p1_pipe_en", "pcie1_pipe_en", 17),
+	GATE_PCIE(CLK_PCIE_P0_AUX_EN, "pcie_p0_aux_en", "p0_1mhz", 18),
+	GATE_PCIE(CLK_PCIE_P0_OBFF_EN, "pcie_p0_obff_en", "free_run_4mhz", 19),
+	GATE_PCIE(CLK_PCIE_P0_AHB_EN, "pcie_p0_ahb_en", "axi_sel", 20),
+	GATE_PCIE(CLK_PCIE_P0_AXI_EN, "pcie_p0_axi_en", "hif_sel", 21),
+	GATE_PCIE(CLK_PCIE_P0_MAC_EN, "pcie_p0_mac_en", "pcie0_mac_en", 22),
+	GATE_PCIE(CLK_PCIE_P0_PIPE_EN, "pcie_p0_pipe_en", "pcie0_pipe_en", 23),
+	GATE_PCIE(CLK_SATA_AHB_EN, "sata_ahb_en", "axi_sel", 26),
+	GATE_PCIE(CLK_SATA_AXI_EN, "sata_axi_en", "hif_sel", 27),
+	GATE_PCIE(CLK_SATA_ASIC_EN, "sata_asic_en", "sata_asic", 28),
+	GATE_PCIE(CLK_SATA_RBC_EN, "sata_rbc_en", "sata_rbc", 29),
+	GATE_PCIE(CLK_SATA_PM_EN, "sata_pm_en", "univpll2_d4", 30),
+};
+
+static int clk_mt7622_ssusbsys_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_SSUSB_NR_CLK);
+
+	mtk_clk_register_gates(node, ssusb_clks, ARRAY_SIZE(ssusb_clks),
+			       clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	mtk_register_reset_controller(node, 1, 0x34);
+
+	return r;
+}
+
+static int clk_mt7622_pciesys_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_PCIE_NR_CLK);
+
+	mtk_clk_register_gates(node, pcie_clks, ARRAY_SIZE(pcie_clks),
+			       clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	mtk_register_reset_controller(node, 1, 0x34);
+
+	return r;
+}
+
+static const struct of_device_id of_match_clk_mt7622_hif[] = {
+	{
+		.compatible = "mediatek,mt7622-pciesys",
+		.data = clk_mt7622_pciesys_init,
+	}, {
+		.compatible = "mediatek,mt7622-ssusbsys",
+		.data = clk_mt7622_ssusbsys_init,
+	}, {
+		/* sentinel */
+	}
+};
+
+static int clk_mt7622_hif_probe(struct platform_device *pdev)
+{
+	int (*clk_init)(struct platform_device *);
+	int r;
+
+	clk_init = of_device_get_match_data(&pdev->dev);
+	if (!clk_init)
+		return -EINVAL;
+
+	r = clk_init(pdev);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	return r;
+}
+
+static struct platform_driver clk_mt7622_hif_drv = {
+	.probe = clk_mt7622_hif_probe,
+	.driver = {
+		.name = "clk-mt7622-hif",
+		.of_match_table = of_match_clk_mt7622_hif,
+	},
+};
+
+builtin_platform_driver(clk_mt7622_hif_drv);
diff --git a/drivers/clk/mediatek/clk-mt7622.c b/drivers/clk/mediatek/clk-mt7622.c
new file mode 100644
index 000000000000..92f7e32770c6
--- /dev/null
+++ b/drivers/clk/mediatek/clk-mt7622.c
@@ -0,0 +1,780 @@
+/*
+ * Copyright (c) 2017 MediaTek Inc.
+ * Author: Chen Zhong <chen.zhong@mediatek.com>
+ *	   Sean Wang <sean.wang@mediatek.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/clk-provider.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+
+#include "clk-mtk.h"
+#include "clk-gate.h"
+#include "clk-cpumux.h"
+
+#include <dt-bindings/clock/mt7622-clk.h>
+#include <linux/clk.h> /* for consumer */
+
+#define MT7622_PLL_FMAX		(2500UL * MHZ)
+#define CON0_MT7622_RST_BAR	BIT(27)
+
+#define PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,\
+			_pd_reg, _pd_shift, _tuner_reg, _pcw_reg,	\
+			_pcw_shift, _div_table, _parent_name) {		\
+		.id = _id,						\
+		.name = _name,						\
+		.reg = _reg,						\
+		.pwr_reg = _pwr_reg,					\
+		.en_mask = _en_mask,					\
+		.flags = _flags,					\
+		.rst_bar_mask = CON0_MT7622_RST_BAR,			\
+		.fmax = MT7622_PLL_FMAX,				\
+		.pcwbits = _pcwbits,					\
+		.pd_reg = _pd_reg,					\
+		.pd_shift = _pd_shift,					\
+		.tuner_reg = _tuner_reg,				\
+		.pcw_reg = _pcw_reg,					\
+		.pcw_shift = _pcw_shift,				\
+		.div_table = _div_table,				\
+		.parent_name = _parent_name,				\
+	}
+
+#define PLL(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,	\
+			_pd_reg, _pd_shift, _tuner_reg, _pcw_reg,	\
+			_pcw_shift)					\
+	PLL_xtal(_id, _name, _reg, _pwr_reg, _en_mask, _flags, _pcwbits,\
+		 _pd_reg, _pd_shift, _tuner_reg, _pcw_reg, _pcw_shift,  \
+		 NULL, "clkxtal")
+
+#define GATE_APMIXED(_id, _name, _parent, _shift) {			\
+		.id = _id,						\
+		.name = _name,						\
+		.parent_name = _parent,					\
+		.regs = &apmixed_cg_regs,				\
+		.shift = _shift,					\
+		.ops = &mtk_clk_gate_ops_no_setclr_inv,			\
+	}
+
+#define GATE_INFRA(_id, _name, _parent, _shift) {			\
+		.id = _id,						\
+		.name = _name,						\
+		.parent_name = _parent,					\
+		.regs = &infra_cg_regs,					\
+		.shift = _shift,					\
+		.ops = &mtk_clk_gate_ops_setclr,			\
+	}
+
+#define GATE_TOP0(_id, _name, _parent, _shift) {			\
+		.id = _id,						\
+		.name = _name,						\
+		.parent_name = _parent,					\
+		.regs = &top0_cg_regs,					\
+		.shift = _shift,					\
+		.ops = &mtk_clk_gate_ops_no_setclr,			\
+	}
+
+#define GATE_TOP1(_id, _name, _parent, _shift) {			\
+		.id = _id,						\
+		.name = _name,						\
+		.parent_name = _parent,					\
+		.regs = &top1_cg_regs,					\
+		.shift = _shift,					\
+		.ops = &mtk_clk_gate_ops_no_setclr,			\
+	}
+
+#define GATE_PERI0(_id, _name, _parent, _shift) {			\
+		.id = _id,						\
+		.name = _name,						\
+		.parent_name = _parent,					\
+		.regs = &peri0_cg_regs,					\
+		.shift = _shift,					\
+		.ops = &mtk_clk_gate_ops_setclr,			\
+	}
+
+#define GATE_PERI1(_id, _name, _parent, _shift) {			\
+		.id = _id,						\
+		.name = _name,						\
+		.parent_name = _parent,					\
+		.regs = &peri1_cg_regs,					\
+		.shift = _shift,					\
+		.ops = &mtk_clk_gate_ops_setclr,			\
+	}
+
+static DEFINE_SPINLOCK(mt7622_clk_lock);
+
+static const char * const infra_mux1_parents[] = {
+	"clkxtal",
+	"armpll",
+	"main_core_en",
+	"armpll"
+};
+
+static const char * const axi_parents[] = {
+	"clkxtal",
+	"syspll1_d2",
+	"syspll_d5",
+	"syspll1_d4",
+	"univpll_d5",
+	"univpll2_d2",
+	"univpll_d7"
+};
+
+static const char * const mem_parents[] = {
+	"clkxtal",
+	"dmpll_ck"
+};
+
+static const char * const ddrphycfg_parents[] = {
+	"clkxtal",
+	"syspll1_d8"
+};
+
+static const char * const eth_parents[] = {
+	"clkxtal",
+	"syspll1_d2",
+	"univpll1_d2",
+	"syspll1_d4",
+	"univpll_d5",
+	"clk_null",
+	"univpll_d7"
+};
+
+static const char * const pwm_parents[] = {
+	"clkxtal",
+	"univpll2_d4"
+};
+
+static const char * const f10m_ref_parents[] = {
+	"clkxtal",
+	"syspll4_d16"
+};
+
+static const char * const nfi_infra_parents[] = {
+	"clkxtal",
+	"clkxtal",
+	"clkxtal",
+	"clkxtal",
+	"clkxtal",
+	"clkxtal",
+	"clkxtal",
+	"clkxtal",
+	"univpll2_d8",
+	"syspll1_d8",
+	"univpll1_d8",
+	"syspll4_d2",
+	"univpll2_d4",
+	"univpll3_d2",
+	"syspll1_d4"
+};
+
+static const char * const flash_parents[] = {
+	"clkxtal",
+	"univpll_d80_d4",
+	"syspll2_d8",
+	"syspll3_d4",
+	"univpll3_d4",
+	"univpll1_d8",
+	"syspll2_d4",
+	"univpll2_d4"
+};
+
+static const char * const uart_parents[] = {
+	"clkxtal",
+	"univpll2_d8"
+};
+
+static const char * const spi0_parents[] = {
+	"clkxtal",
+	"syspll3_d2",
+	"clkxtal",
+	"syspll2_d4",
+	"syspll4_d2",
+	"univpll2_d4",
+	"univpll1_d8",
+	"clkxtal"
+};
+
+static const char * const spi1_parents[] = {
+	"clkxtal",
+	"syspll3_d2",
+	"clkxtal",
+	"syspll4_d4",
+	"syspll4_d2",
+	"univpll2_d4",
+	"univpll1_d8",
+	"clkxtal"
+};
+
+static const char * const msdc30_0_parents[] = {
+	"clkxtal",
+	"univpll2_d16",
+	"univ48m"
+};
+
+static const char * const a1sys_hp_parents[] = {
+	"clkxtal",
+	"aud1pll_ck",
+	"aud2pll_ck",
+	"clkxtal"
+};
+
+static const char * const intdir_parents[] = {
+	"clkxtal",
+	"syspll_d2",
+	"univpll_d2",
+	"sgmiipll_ck"
+};
+
+static const char * const aud_intbus_parents[] = {
+	"clkxtal",
+	"syspll1_d4",
+	"syspll4_d2",
+	"syspll3_d2"
+};
+
+static const char * const pmicspi_parents[] = {
+	"clkxtal",
+	"clk_null",
+	"clk_null",
+	"clk_null",
+	"clk_null",
+	"univpll2_d16"
+};
+
+static const char * const atb_parents[] = {
+	"clkxtal",
+	"syspll1_d2",
+	"syspll_d5"
+};
+
+static const char * const audio_parents[] = {
+	"clkxtal",
+	"syspll3_d4",
+	"syspll4_d4",
+	"univpll1_d16"
+};
+
+static const char * const usb20_parents[] = {
+	"clkxtal",
+	"univpll3_d4",
+	"syspll1_d8",
+	"clkxtal"
+};
+
+static const char * const aud1_parents[] = {
+	"clkxtal",
+	"aud1pll_ck"
+};
+
+static const char * const aud2_parents[] = {
+	"clkxtal",
+	"aud2pll_ck"
+};
+
+static const char * const asm_l_parents[] = {
+	"clkxtal",
+	"syspll_d5",
+	"univpll2_d2",
+	"univpll2_d4"
+};
+
+static const char * const apll1_ck_parents[] = {
+	"aud1_sel",
+	"aud2_sel"
+};
+
+static const char * const peribus_ck_parents[] = {
+	"syspll1_d8",
+	"syspll1_d4"
+};
+
+static const struct mtk_gate_regs apmixed_cg_regs = {
+	.set_ofs = 0x8,
+	.clr_ofs = 0x8,
+	.sta_ofs = 0x8,
+};
+
+static const struct mtk_gate_regs infra_cg_regs = {
+	.set_ofs = 0x40,
+	.clr_ofs = 0x44,
+	.sta_ofs = 0x48,
+};
+
+static const struct mtk_gate_regs top0_cg_regs = {
+	.set_ofs = 0x120,
+	.clr_ofs = 0x120,
+	.sta_ofs = 0x120,
+};
+
+static const struct mtk_gate_regs top1_cg_regs = {
+	.set_ofs = 0x128,
+	.clr_ofs = 0x128,
+	.sta_ofs = 0x128,
+};
+
+static const struct mtk_gate_regs peri0_cg_regs = {
+	.set_ofs = 0x8,
+	.clr_ofs = 0x10,
+	.sta_ofs = 0x18,
+};
+
+static const struct mtk_gate_regs peri1_cg_regs = {
+	.set_ofs = 0xC,
+	.clr_ofs = 0x14,
+	.sta_ofs = 0x1C,
+};
+
+static const struct mtk_pll_data plls[] = {
+	PLL(CLK_APMIXED_ARMPLL, "armpll", 0x0200, 0x020C, 0x00000001,
+	    PLL_AO, 21, 0x0204, 24, 0, 0x0204, 0),
+	PLL(CLK_APMIXED_MAINPLL, "mainpll", 0x0210, 0x021C, 0x00000001,
+	    HAVE_RST_BAR, 21, 0x0214, 24, 0, 0x0214, 0),
+	PLL(CLK_APMIXED_UNIV2PLL, "univ2pll", 0x0220, 0x022C, 0x00000001,
+	    HAVE_RST_BAR, 7, 0x0224, 24, 0, 0x0224, 14),
+	PLL(CLK_APMIXED_ETH1PLL, "eth1pll", 0x0300, 0x0310, 0x00000001,
+	    0, 21, 0x0300, 1, 0, 0x0304, 0),
+	PLL(CLK_APMIXED_ETH2PLL, "eth2pll", 0x0314, 0x0320, 0x00000001,
+	    0, 21, 0x0314, 1, 0, 0x0318, 0),
+	PLL(CLK_APMIXED_AUD1PLL, "aud1pll", 0x0324, 0x0330, 0x00000001,
+	    0, 31, 0x0324, 1, 0, 0x0328, 0),
+	PLL(CLK_APMIXED_AUD2PLL, "aud2pll", 0x0334, 0x0340, 0x00000001,
+	    0, 31, 0x0334, 1, 0, 0x0338, 0),
+	PLL(CLK_APMIXED_TRGPLL, "trgpll", 0x0344, 0x0354, 0x00000001,
+	    0, 21, 0x0344, 1, 0, 0x0348, 0),
+	PLL(CLK_APMIXED_SGMIPLL, "sgmipll", 0x0358, 0x0368, 0x00000001,
+	    0, 21, 0x0358, 1, 0, 0x035C, 0),
+};
+
+static const struct mtk_gate apmixed_clks[] = {
+	GATE_APMIXED(CLK_APMIXED_MAIN_CORE_EN, "main_core_en", "mainpll", 5),
+};
+
+static const struct mtk_gate infra_clks[] = {
+	GATE_INFRA(CLK_INFRA_DBGCLK_PD, "infra_dbgclk_pd", "axi_sel", 0),
+	GATE_INFRA(CLK_INFRA_TRNG, "trng_ck", "axi_sel", 2),
+	GATE_INFRA(CLK_INFRA_AUDIO_PD, "infra_audio_pd", "aud_intbus_sel", 5),
+	GATE_INFRA(CLK_INFRA_IRRX_PD, "infra_irrx_pd", "irrx_sel", 16),
+	GATE_INFRA(CLK_INFRA_APXGPT_PD, "infra_apxgpt_pd", "f10m_ref_sel", 18),
+	GATE_INFRA(CLK_INFRA_PMIC_PD, "infra_pmic_pd", "pmicspi_sel", 22),
+};
+
+static const struct mtk_fixed_clk top_fixed_clks[] = {
+	FIXED_CLK(CLK_TOP_TO_U2_PHY, "to_u2_phy", "clkxtal",
+		  31250000),
+	FIXED_CLK(CLK_TOP_TO_U2_PHY_1P, "to_u2_phy_1p", "clkxtal",
+		  31250000),
+	FIXED_CLK(CLK_TOP_PCIE0_PIPE_EN, "pcie0_pipe_en", "clkxtal",
+		  125000000),
+	FIXED_CLK(CLK_TOP_PCIE1_PIPE_EN, "pcie1_pipe_en", "clkxtal",
+		  125000000),
+	FIXED_CLK(CLK_TOP_SSUSB_TX250M, "ssusb_tx250m", "clkxtal",
+		  250000000),
+	FIXED_CLK(CLK_TOP_SSUSB_EQ_RX250M, "ssusb_eq_rx250m", "clkxtal",
+		  250000000),
+	FIXED_CLK(CLK_TOP_SSUSB_CDR_REF, "ssusb_cdr_ref", "clkxtal",
+		  33333333),
+	FIXED_CLK(CLK_TOP_SSUSB_CDR_FB, "ssusb_cdr_fb", "clkxtal",
+		  50000000),
+	FIXED_CLK(CLK_TOP_SATA_ASIC, "sata_asic", "clkxtal",
+		  50000000),
+	FIXED_CLK(CLK_TOP_SATA_RBC, "sata_rbc", "clkxtal",
+		  50000000),
+};
+
+static const struct mtk_fixed_factor top_divs[] = {
+	FACTOR(CLK_TOP_TO_USB3_SYS, "to_usb3_sys", "eth1pll", 1, 4),
+	FACTOR(CLK_TOP_P1_1MHZ, "p1_1mhz", "eth1pll", 1, 500),
+	FACTOR(CLK_TOP_4MHZ, "free_run_4mhz", "eth1pll", 1, 125),
+	FACTOR(CLK_TOP_P0_1MHZ, "p0_1mhz", "eth1pll", 1, 500),
+	FACTOR(CLK_TOP_TXCLK_SRC_PRE, "txclk_src_pre", "sgmiipll_d2", 1, 1),
+	FACTOR(CLK_TOP_RTC, "rtc", "clkxtal", 1, 1024),
+	FACTOR(CLK_TOP_MEMPLL, "mempll", "clkxtal", 32, 1),
+	FACTOR(CLK_TOP_DMPLL, "dmpll_ck", "mempll", 1, 1),
+	FACTOR(CLK_TOP_SYSPLL_D2, "syspll_d2", "mainpll", 1, 2),
+	FACTOR(CLK_TOP_SYSPLL1_D2, "syspll1_d2", "mainpll", 1, 4),
+	FACTOR(CLK_TOP_SYSPLL1_D4, "syspll1_d4", "mainpll", 1, 8),
+	FACTOR(CLK_TOP_SYSPLL1_D8, "syspll1_d8", "mainpll", 1, 16),
+	FACTOR(CLK_TOP_SYSPLL2_D4, "syspll2_d4", "mainpll", 1, 12),
+	FACTOR(CLK_TOP_SYSPLL2_D8, "syspll2_d8", "mainpll", 1, 24),
+	FACTOR(CLK_TOP_SYSPLL_D5, "syspll_d5", "mainpll", 1, 5),
+	FACTOR(CLK_TOP_SYSPLL3_D2, "syspll3_d2", "mainpll", 1, 10),
+	FACTOR(CLK_TOP_SYSPLL3_D4, "syspll3_d4", "mainpll", 1, 20),
+	FACTOR(CLK_TOP_SYSPLL4_D2, "syspll4_d2", "mainpll", 1, 14),
+	FACTOR(CLK_TOP_SYSPLL4_D4, "syspll4_d4", "mainpll", 1, 28),
+	FACTOR(CLK_TOP_SYSPLL4_D16, "syspll4_d16", "mainpll", 1, 112),
+	FACTOR(CLK_TOP_UNIVPLL, "univpll", "univ2pll", 1, 2),
+	FACTOR(CLK_TOP_UNIVPLL_D2, "univpll_d2", "univpll", 1, 2),
+	FACTOR(CLK_TOP_UNIVPLL1_D2, "univpll1_d2", "univpll", 1, 4),
+	FACTOR(CLK_TOP_UNIVPLL1_D4, "univpll1_d4", "univpll", 1, 8),
+	FACTOR(CLK_TOP_UNIVPLL1_D8, "univpll1_d8", "univpll", 1, 16),
+	FACTOR(CLK_TOP_UNIVPLL1_D16, "univpll1_d16", "univpll", 1, 32),
+	FACTOR(CLK_TOP_UNIVPLL2_D2, "univpll2_d2", "univpll", 1, 6),
+	FACTOR(CLK_TOP_UNIVPLL2_D4, "univpll2_d4", "univpll", 1, 12),
+	FACTOR(CLK_TOP_UNIVPLL2_D8, "univpll2_d8", "univpll", 1, 24),
+	FACTOR(CLK_TOP_UNIVPLL2_D16, "univpll2_d16", "univpll", 1, 48),
+	FACTOR(CLK_TOP_UNIVPLL_D5, "univpll_d5", "univpll", 1, 5),
+	FACTOR(CLK_TOP_UNIVPLL3_D2, "univpll3_d2", "univpll", 1, 10),
+	FACTOR(CLK_TOP_UNIVPLL3_D4, "univpll3_d4", "univpll", 1, 20),
+	FACTOR(CLK_TOP_UNIVPLL3_D16, "univpll3_d16", "univpll", 1, 80),
+	FACTOR(CLK_TOP_UNIVPLL_D7, "univpll_d7", "univpll", 1, 7),
+	FACTOR(CLK_TOP_UNIVPLL_D80_D4, "univpll_d80_d4", "univpll", 1, 320),
+	FACTOR(CLK_TOP_UNIV48M, "univ48m", "univpll", 1, 25),
+	FACTOR(CLK_TOP_SGMIIPLL, "sgmiipll_ck", "sgmipll", 1, 1),
+	FACTOR(CLK_TOP_SGMIIPLL_D2, "sgmiipll_d2", "sgmipll", 1, 2),
+	FACTOR(CLK_TOP_AUD1PLL, "aud1pll_ck", "aud1pll", 1, 1),
+	FACTOR(CLK_TOP_AUD2PLL, "aud2pll_ck", "aud2pll", 1, 1),
+	FACTOR(CLK_TOP_AUD_I2S2_MCK, "aud_i2s2_mck", "i2s2_mck_sel", 1, 2),
+	FACTOR(CLK_TOP_TO_USB3_REF, "to_usb3_ref", "univpll2_d4", 1, 4),
+	FACTOR(CLK_TOP_PCIE1_MAC_EN, "pcie1_mac_en", "univpll1_d4", 1, 1),
+	FACTOR(CLK_TOP_PCIE0_MAC_EN, "pcie0_mac_en", "univpll1_d4", 1, 1),
+	FACTOR(CLK_TOP_ETH_500M, "eth_500m", "eth1pll", 1, 1),
+};
+
+static const struct mtk_gate top_clks[] = {
+	/* TOP0 */
+	GATE_TOP0(CLK_TOP_APLL1_DIV_PD, "apll1_ck_div_pd", "apll1_ck_div", 0),
+	GATE_TOP0(CLK_TOP_APLL2_DIV_PD, "apll2_ck_div_pd", "apll2_ck_div", 1),
+	GATE_TOP0(CLK_TOP_I2S0_MCK_DIV_PD, "i2s0_mck_div_pd", "i2s0_mck_div",
+		  2),
+	GATE_TOP0(CLK_TOP_I2S1_MCK_DIV_PD, "i2s1_mck_div_pd", "i2s1_mck_div",
+		  3),
+	GATE_TOP0(CLK_TOP_I2S2_MCK_DIV_PD, "i2s2_mck_div_pd", "i2s2_mck_div",
+		  4),
+	GATE_TOP0(CLK_TOP_I2S3_MCK_DIV_PD, "i2s3_mck_div_pd", "i2s3_mck_div",
+		  5),
+
+	/* TOP1 */
+	GATE_TOP1(CLK_TOP_A1SYS_HP_DIV_PD, "a1sys_div_pd", "a1sys_div", 0),
+	GATE_TOP1(CLK_TOP_A2SYS_HP_DIV_PD, "a2sys_div_pd", "a2sys_div", 16),
+};
+
+static const struct mtk_clk_divider top_adj_divs[] = {
+	DIV_ADJ(CLK_TOP_APLL1_DIV, "apll1_ck_div", "apll1_ck_sel",
+		0x120, 24, 3),
+	DIV_ADJ(CLK_TOP_APLL2_DIV, "apll2_ck_div", "apll2_ck_sel",
+		0x120, 28, 3),
+	DIV_ADJ(CLK_TOP_I2S0_MCK_DIV, "i2s0_mck_div", "i2s0_mck_sel",
+		0x124, 0, 7),
+	DIV_ADJ(CLK_TOP_I2S1_MCK_DIV, "i2s1_mck_div", "i2s1_mck_sel",
+		0x124, 8, 7),
+	DIV_ADJ(CLK_TOP_I2S2_MCK_DIV, "i2s2_mck_div", "aud_i2s2_mck",
+		0x124, 16, 7),
+	DIV_ADJ(CLK_TOP_I2S3_MCK_DIV, "i2s3_mck_div", "i2s3_mck_sel",
+		0x124, 24, 7),
+	DIV_ADJ(CLK_TOP_A1SYS_HP_DIV, "a1sys_div", "a1sys_hp_sel",
+		0x128, 8, 7),
+	DIV_ADJ(CLK_TOP_A2SYS_HP_DIV, "a2sys_div", "a2sys_hp_sel",
+		0x128, 24, 7),
+};
+
+static const struct mtk_gate peri_clks[] = {
+	/* PERI0 */
+	GATE_PERI0(CLK_PERI_THERM_PD, "peri_therm_pd", "axi_sel", 1),
+	GATE_PERI0(CLK_PERI_PWM1_PD, "peri_pwm1_pd", "clkxtal", 2),
+	GATE_PERI0(CLK_PERI_PWM2_PD, "peri_pwm2_pd", "clkxtal", 3),
+	GATE_PERI0(CLK_PERI_PWM3_PD, "peri_pwm3_pd", "clkxtal", 4),
+	GATE_PERI0(CLK_PERI_PWM4_PD, "peri_pwm4_pd", "clkxtal", 5),
+	GATE_PERI0(CLK_PERI_PWM5_PD, "peri_pwm5_pd", "clkxtal", 6),
+	GATE_PERI0(CLK_PERI_PWM6_PD, "peri_pwm6_pd", "clkxtal", 7),
+	GATE_PERI0(CLK_PERI_PWM7_PD, "peri_pwm7_pd", "clkxtal", 8),
+	GATE_PERI0(CLK_PERI_PWM_PD, "peri_pwm_pd", "clkxtal", 9),
+	GATE_PERI0(CLK_PERI_AP_DMA_PD, "peri_ap_dma_pd", "axi_sel", 12),
+	GATE_PERI0(CLK_PERI_MSDC30_0_PD, "peri_msdc30_0", "msdc30_0_sel", 13),
+	GATE_PERI0(CLK_PERI_MSDC30_1_PD, "peri_msdc30_1", "msdc30_1_sel", 14),
+	GATE_PERI0(CLK_PERI_UART0_PD, "peri_uart0_pd", "axi_sel", 17),
+	GATE_PERI0(CLK_PERI_UART1_PD, "peri_uart1_pd", "axi_sel", 18),
+	GATE_PERI0(CLK_PERI_UART2_PD, "peri_uart2_pd", "axi_sel", 19),
+	GATE_PERI0(CLK_PERI_UART3_PD, "peri_uart3_pd", "axi_sel", 20),
+	GATE_PERI0(CLK_PERI_UART4_PD, "peri_uart4_pd", "axi_sel", 21),
+	GATE_PERI0(CLK_PERI_BTIF_PD, "peri_btif_pd", "axi_sel", 22),
+	GATE_PERI0(CLK_PERI_I2C0_PD, "peri_i2c0_pd", "axi_sel", 23),
+	GATE_PERI0(CLK_PERI_I2C1_PD, "peri_i2c1_pd", "axi_sel", 24),
+	GATE_PERI0(CLK_PERI_I2C2_PD, "peri_i2c2_pd", "axi_sel", 25),
+	GATE_PERI0(CLK_PERI_SPI1_PD, "peri_spi1_pd", "spi1_sel", 26),
+	GATE_PERI0(CLK_PERI_AUXADC_PD, "peri_auxadc_pd", "clkxtal", 27),
+	GATE_PERI0(CLK_PERI_SPI0_PD, "peri_spi0_pd", "spi0_sel", 28),
+	GATE_PERI0(CLK_PERI_SNFI_PD, "peri_snfi_pd", "nfi_infra_sel", 29),
+	GATE_PERI0(CLK_PERI_NFI_PD, "peri_nfi_pd", "axi_sel", 30),
+	GATE_PERI0(CLK_PERI_NFIECC_PD, "peri_nfiecc_pd", "axi_sel", 31),
+
+	/* PERI1 */
+	GATE_PERI1(CLK_PERI_FLASH_PD, "peri_flash_pd", "flash_sel", 1),
+	GATE_PERI1(CLK_PERI_IRTX_PD, "peri_irtx_pd", "irtx_sel", 2),
+};
+
+static struct mtk_composite infra_muxes[] __initdata = {
+	MUX(CLK_INFRA_MUX1_SEL, "infra_mux1_sel", infra_mux1_parents,
+	    0x000, 2, 2),
+};
+
+static struct mtk_composite top_muxes[] = {
+	/* CLK_CFG_0 */
+	MUX_GATE(CLK_TOP_AXI_SEL, "axi_sel", axi_parents,
+		 0x040, 0, 3, 7),
+	MUX_GATE(CLK_TOP_MEM_SEL, "mem_sel", mem_parents,
+		 0x040, 8, 1, 15),
+	MUX_GATE(CLK_TOP_DDRPHYCFG_SEL, "ddrphycfg_sel", ddrphycfg_parents,
+		 0x040, 16, 1, 23),
+	MUX_GATE(CLK_TOP_ETH_SEL, "eth_sel", eth_parents,
+		 0x040, 24, 3, 31),
+
+	/* CLK_CFG_1 */
+	MUX_GATE(CLK_TOP_PWM_SEL, "pwm_sel", pwm_parents,
+		 0x050, 0, 2, 7),
+	MUX_GATE(CLK_TOP_F10M_REF_SEL, "f10m_ref_sel", f10m_ref_parents,
+		 0x050, 8, 1, 15),
+	MUX_GATE(CLK_TOP_NFI_INFRA_SEL, "nfi_infra_sel", nfi_infra_parents,
+		 0x050, 16, 4, 23),
+	MUX_GATE(CLK_TOP_FLASH_SEL, "flash_sel", flash_parents,
+		 0x050, 24, 3, 31),
+
+	/* CLK_CFG_2 */
+	MUX_GATE(CLK_TOP_UART_SEL, "uart_sel", uart_parents,
+		 0x060, 0, 1, 7),
+	MUX_GATE(CLK_TOP_SPI0_SEL, "spi0_sel", spi0_parents,
+		 0x060, 8, 3, 15),
+	MUX_GATE(CLK_TOP_SPI1_SEL, "spi1_sel", spi1_parents,
+		 0x060, 16, 3, 23),
+	MUX_GATE(CLK_TOP_MSDC50_0_SEL, "msdc50_0_sel", uart_parents,
+		 0x060, 24, 3, 31),
+
+	/* CLK_CFG_3 */
+	MUX_GATE(CLK_TOP_MSDC30_0_SEL, "msdc30_0_sel", msdc30_0_parents,
+		 0x070, 0, 3, 7),
+	MUX_GATE(CLK_TOP_MSDC30_1_SEL, "msdc30_1_sel", msdc30_0_parents,
+		 0x070, 8, 3, 15),
+	MUX_GATE(CLK_TOP_A1SYS_HP_SEL, "a1sys_hp_sel", a1sys_hp_parents,
+		 0x070, 16, 2, 23),
+	MUX_GATE(CLK_TOP_A2SYS_HP_SEL, "a2sys_hp_sel", a1sys_hp_parents,
+		 0x070, 24, 2, 31),
+
+	/* CLK_CFG_4 */
+	MUX_GATE(CLK_TOP_INTDIR_SEL, "intdir_sel", intdir_parents,
+		 0x080, 0, 2, 7),
+	MUX_GATE(CLK_TOP_AUD_INTBUS_SEL, "aud_intbus_sel", aud_intbus_parents,
+		 0x080, 8, 2, 15),
+	MUX_GATE(CLK_TOP_PMICSPI_SEL, "pmicspi_sel", pmicspi_parents,
+		 0x080, 16, 3, 23),
+	MUX_GATE(CLK_TOP_SCP_SEL, "scp_sel", ddrphycfg_parents,
+		 0x080, 24, 2, 31),
+
+	/* CLK_CFG_5 */
+	MUX_GATE(CLK_TOP_ATB_SEL, "atb_sel", atb_parents,
+		 0x090, 0, 2, 7),
+	MUX_GATE(CLK_TOP_HIF_SEL, "hif_sel", eth_parents,
+		 0x090, 8, 3, 15),
+	MUX_GATE(CLK_TOP_AUDIO_SEL, "audio_sel", audio_parents,
+		 0x090, 16, 2, 23),
+	MUX_GATE(CLK_TOP_U2_SEL, "usb20_sel", usb20_parents,
+		 0x090, 24, 2, 31),
+
+	/* CLK_CFG_6 */
+	MUX_GATE(CLK_TOP_AUD1_SEL, "aud1_sel", aud1_parents,
+		 0x0A0, 0, 1, 7),
+	MUX_GATE(CLK_TOP_AUD2_SEL, "aud2_sel", aud2_parents,
+		 0x0A0, 8, 1, 15),
+	MUX_GATE(CLK_TOP_IRRX_SEL, "irrx_sel", f10m_ref_parents,
+		 0x0A0, 16, 1, 23),
+	MUX_GATE(CLK_TOP_IRTX_SEL, "irtx_sel", f10m_ref_parents,
+		 0x0A0, 24, 1, 31),
+
+	/* CLK_CFG_7 */
+	MUX_GATE(CLK_TOP_ASM_L_SEL, "asm_l_sel", asm_l_parents,
+		 0x0B0, 0, 2, 7),
+	MUX_GATE(CLK_TOP_ASM_M_SEL, "asm_m_sel", asm_l_parents,
+		 0x0B0, 8, 2, 15),
+	MUX_GATE(CLK_TOP_ASM_H_SEL, "asm_h_sel", asm_l_parents,
+		 0x0B0, 16, 2, 23),
+
+	/* CLK_AUDDIV_0 */
+	MUX(CLK_TOP_APLL1_SEL, "apll1_ck_sel", apll1_ck_parents,
+	    0x120, 6, 1),
+	MUX(CLK_TOP_APLL2_SEL, "apll2_ck_sel", apll1_ck_parents,
+	    0x120, 7, 1),
+	MUX(CLK_TOP_I2S0_MCK_SEL, "i2s0_mck_sel", apll1_ck_parents,
+	    0x120, 8, 1),
+	MUX(CLK_TOP_I2S1_MCK_SEL, "i2s1_mck_sel", apll1_ck_parents,
+	    0x120, 9, 1),
+	MUX(CLK_TOP_I2S2_MCK_SEL, "i2s2_mck_sel", apll1_ck_parents,
+	    0x120, 10, 1),
+	MUX(CLK_TOP_I2S3_MCK_SEL, "i2s3_mck_sel", apll1_ck_parents,
+	    0x120, 11, 1),
+};
+
+static struct mtk_composite peri_muxes[] = {
+	/* PERI_GLOBALCON_CKSEL */
+	MUX(CLK_PERIBUS_SEL, "peribus_ck_sel", peribus_ck_parents, 0x05C, 0, 1),
+};
+
+static int mtk_topckgen_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	void __iomem *base;
+	struct device_node *node = pdev->dev.of_node;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	clk_data = mtk_alloc_clk_data(CLK_TOP_NR_CLK);
+
+	mtk_clk_register_fixed_clks(top_fixed_clks, ARRAY_SIZE(top_fixed_clks),
+				    clk_data);
+
+	mtk_clk_register_factors(top_divs, ARRAY_SIZE(top_divs),
+				 clk_data);
+
+	mtk_clk_register_composites(top_muxes, ARRAY_SIZE(top_muxes),
+				    base, &mt7622_clk_lock, clk_data);
+
+	mtk_clk_register_dividers(top_adj_divs, ARRAY_SIZE(top_adj_divs),
+				  base, &mt7622_clk_lock, clk_data);
+
+	mtk_clk_register_gates(node, top_clks, ARRAY_SIZE(top_clks),
+			       clk_data);
+
+	clk_prepare_enable(clk_data->clks[CLK_TOP_AXI_SEL]);
+	clk_prepare_enable(clk_data->clks[CLK_TOP_MEM_SEL]);
+	clk_prepare_enable(clk_data->clks[CLK_TOP_DDRPHYCFG_SEL]);
+
+	return of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+}
+
+static int __init mtk_infrasys_init(struct platform_device *pdev)
+{
+	struct device_node *node = pdev->dev.of_node;
+	struct clk_onecell_data *clk_data;
+	int r;
+
+	clk_data = mtk_alloc_clk_data(CLK_INFRA_NR_CLK);
+
+	mtk_clk_register_gates(node, infra_clks, ARRAY_SIZE(infra_clks),
+			       clk_data);
+
+	mtk_clk_register_cpumuxes(node, infra_muxes, ARRAY_SIZE(infra_muxes),
+				  clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get,
+				clk_data);
+	if (r)
+		return r;
+
+	mtk_register_reset_controller(node, 1, 0x30);
+
+	return 0;
+}
+
+static int mtk_apmixedsys_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	struct device_node *node = pdev->dev.of_node;
+
+	clk_data = mtk_alloc_clk_data(CLK_APMIXED_NR_CLK);
+	if (!clk_data)
+		return -ENOMEM;
+
+	mtk_clk_register_plls(node, plls, ARRAY_SIZE(plls),
+			      clk_data);
+
+	mtk_clk_register_gates(node, apmixed_clks,
+			       ARRAY_SIZE(apmixed_clks), clk_data);
+
+	clk_prepare_enable(clk_data->clks[CLK_APMIXED_ARMPLL]);
+	clk_prepare_enable(clk_data->clks[CLK_APMIXED_MAIN_CORE_EN]);
+
+	return of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+}
+
+static int mtk_pericfg_init(struct platform_device *pdev)
+{
+	struct clk_onecell_data *clk_data;
+	void __iomem *base;
+	int r;
+	struct device_node *node = pdev->dev.of_node;
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	clk_data = mtk_alloc_clk_data(CLK_PERI_NR_CLK);
+
+	mtk_clk_register_gates(node, peri_clks, ARRAY_SIZE(peri_clks),
+			       clk_data);
+
+	mtk_clk_register_composites(peri_muxes, ARRAY_SIZE(peri_muxes), base,
+				    &mt7622_clk_lock, clk_data);
+
+	r = of_clk_add_provider(node, of_clk_src_onecell_get, clk_data);
+	if (r)
+		return r;
+
+	clk_prepare_enable(clk_data->clks[CLK_PERI_UART0_PD]);
+
+	mtk_register_reset_controller(node, 2, 0x0);
+
+	return 0;
+}
+
+static const struct of_device_id of_match_clk_mt7622[] = {
+	{
+		.compatible = "mediatek,mt7622-apmixedsys",
+		.data = mtk_apmixedsys_init,
+	}, {
+		.compatible = "mediatek,mt7622-infracfg",
+		.data = mtk_infrasys_init,
+	}, {
+		.compatible = "mediatek,mt7622-topckgen",
+		.data = mtk_topckgen_init,
+	}, {
+		.compatible = "mediatek,mt7622-pericfg",
+		.data = mtk_pericfg_init,
+	}, {
+		/* sentinel */
+	}
+};
+
+static int clk_mt7622_probe(struct platform_device *pdev)
+{
+	int (*clk_init)(struct platform_device *);
+	int r;
+
+	clk_init = of_device_get_match_data(&pdev->dev);
+	if (!clk_init)
+		return -EINVAL;
+
+	r = clk_init(pdev);
+	if (r)
+		dev_err(&pdev->dev,
+			"could not register clock provider: %s: %d\n",
+			pdev->name, r);
+
+	return r;
+}
+
+static struct platform_driver clk_mt7622_drv = {
+	.probe = clk_mt7622_probe,
+	.driver = {
+		.name = "clk-mt7622",
+		.of_match_table = of_match_clk_mt7622,
+	},
+};
+
+static int clk_mt7622_init(void)
+{
+	return platform_driver_register(&clk_mt7622_drv);
+}
+
+arch_initcall(clk_mt7622_init);
diff --git a/drivers/clk/mediatek/clk-mtk.h b/drivers/clk/mediatek/clk-mtk.h
index 210ce8e8025e..f83c2bbb677e 100644
--- a/drivers/clk/mediatek/clk-mtk.h
+++ b/drivers/clk/mediatek/clk-mtk.h
@@ -20,6 +20,7 @@
 #include <linux/clk-provider.h>
 
 struct clk;
+struct clk_onecell_data;
 
 #define MAX_MUX_GATE_BIT	31
 #define INVALID_MUX_GATE_BIT	(MAX_MUX_GATE_BIT + 1)
@@ -207,6 +208,8 @@ struct mtk_pll_data {
 	uint32_t en_mask;
 	uint32_t pd_reg;
 	uint32_t tuner_reg;
+	uint32_t tuner_en_reg;
+	uint8_t tuner_en_bit;
 	int pd_shift;
 	unsigned int flags;
 	const struct clk_ops *ops;
@@ -226,14 +229,7 @@ void mtk_clk_register_plls(struct device_node *node,
 struct clk *mtk_clk_register_ref2usb_tx(const char *name,
 			const char *parent_name, void __iomem *reg);
 
-#ifdef CONFIG_RESET_CONTROLLER
 void mtk_register_reset_controller(struct device_node *np,
 			unsigned int num_regs, int regofs);
-#else
-static inline void mtk_register_reset_controller(struct device_node *np,
-			unsigned int num_regs, int regofs)
-{
-}
-#endif
 
 #endif /* __DRV_CLK_MTK_H */
diff --git a/drivers/clk/mediatek/clk-pll.c b/drivers/clk/mediatek/clk-pll.c
index 7598477ff60f..f54e4015b0b1 100644
--- a/drivers/clk/mediatek/clk-pll.c
+++ b/drivers/clk/mediatek/clk-pll.c
@@ -47,6 +47,7 @@ struct mtk_clk_pll {
 	void __iomem	*pd_addr;
 	void __iomem	*pwr_addr;
 	void __iomem	*tuner_addr;
+	void __iomem	*tuner_en_addr;
 	void __iomem	*pcw_addr;
 	const struct mtk_pll_data *data;
 };
@@ -227,7 +228,10 @@ static int mtk_pll_prepare(struct clk_hw *hw)
 	r |= pll->data->en_mask;
 	writel(r, pll->base_addr + REG_CON0);
 
-	if (pll->tuner_addr) {
+	if (pll->tuner_en_addr) {
+		r = readl(pll->tuner_en_addr) | BIT(pll->data->tuner_en_bit);
+		writel(r, pll->tuner_en_addr);
+	} else if (pll->tuner_addr) {
 		r = readl(pll->tuner_addr) | AUDPLL_TUNER_EN;
 		writel(r, pll->tuner_addr);
 	}
@@ -254,7 +258,10 @@ static void mtk_pll_unprepare(struct clk_hw *hw)
 		writel(r, pll->base_addr + REG_CON0);
 	}
 
-	if (pll->tuner_addr) {
+	if (pll->tuner_en_addr) {
+		r = readl(pll->tuner_en_addr) & ~BIT(pll->data->tuner_en_bit);
+		writel(r, pll->tuner_en_addr);
+	} else if (pll->tuner_addr) {
 		r = readl(pll->tuner_addr) & ~AUDPLL_TUNER_EN;
 		writel(r, pll->tuner_addr);
 	}
@@ -297,6 +304,8 @@ static struct clk *mtk_clk_register_pll(const struct mtk_pll_data *data,
 	pll->pcw_addr = base + data->pcw_reg;
 	if (data->tuner_reg)
 		pll->tuner_addr = base + data->tuner_reg;
+	if (data->tuner_en_reg)
+		pll->tuner_en_addr = base + data->tuner_en_reg;
 	pll->hw.init = &init;
 	pll->data = data;
 
diff --git a/drivers/net/dsa/mt7530.c b/drivers/net/dsa/mt7530.c
index 3b073e152237..d8407a72d676 100644
--- a/drivers/net/dsa/mt7530.c
+++ b/drivers/net/dsa/mt7530.c
@@ -670,10 +670,18 @@ static int
 mt7530_cpu_port_enable(struct mt7530_priv *priv,
 		       int port)
 {
+	u8 port_mask = 0;
+	int i;
+
 	/* Enable Mediatek header mode on the cpu port */
 	mt7530_write(priv, MT7530_PVC_P(port),
 		     PORT_SPEC_TAG);
 
+	/* Enable Mediatek header mode on the GMAC that the cpu port
+	 * connects to */
+	regmap_write_bits(priv->ethernet, MTK_GDMA_FWD_CFG(port),
+			  GDMA_SPEC_TAG, GDMA_SPEC_TAG);
+
 	/* Setup the MAC by default for the cpu port */
 	mt7530_write(priv, MT7530_PMCR_P(port), PMCR_CPUP_LINK);
 
@@ -686,8 +694,12 @@ mt7530_cpu_port_enable(struct mt7530_priv *priv,
 	/* CPU port gets connected to all user ports of
 	 * the switch
 	 */
+	for (i = 0; i < MT7530_NUM_PORTS; i++)
+		if ((priv->ds->enabled_port_mask & BIT(i)) &&
+		    (dsa_port_upstream_port(priv->ds, i) == port))
+			port_mask |= BIT(i);
 	mt7530_write(priv, MT7530_PCR_P(port),
-		     PCR_MATRIX(priv->ds->enabled_port_mask));
+		     PCR_MATRIX(port_mask));
 
 	return 0;
 }
@@ -697,6 +709,7 @@ mt7530_port_enable(struct dsa_switch *ds, int port,
 		   struct phy_device *phy)
 {
 	struct mt7530_priv *priv = ds->priv;
+	u8 upstream = dsa_port_upstream_port(ds, port);
 
 	mutex_lock(&priv->reg_mutex);
 
@@ -707,7 +720,7 @@ mt7530_port_enable(struct dsa_switch *ds, int port,
 	 * restore the port matrix if the port is the member of a certain
 	 * bridge.
 	 */
-	priv->ports[port].pm |= PCR_MATRIX(BIT(MT7530_CPU_PORT));
+	priv->ports[port].pm |= PCR_MATRIX(BIT(upstream));
 	priv->ports[port].enable = true;
 	mt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,
 		   priv->ports[port].pm);
@@ -770,7 +783,8 @@ mt7530_port_bridge_join(struct dsa_switch *ds, int port,
 			struct net_device *bridge)
 {
 	struct mt7530_priv *priv = ds->priv;
-	u32 port_bitmap = BIT(MT7530_CPU_PORT);
+	u8 upstream = dsa_port_upstream_port(ds, port);
+	u32 port_bitmap = BIT(upstream);
 	int i;
 
 	mutex_lock(&priv->reg_mutex);
@@ -808,6 +822,7 @@ mt7530_port_bridge_leave(struct dsa_switch *ds, int port,
 			 struct net_device *bridge)
 {
 	struct mt7530_priv *priv = ds->priv;
+	u8 upstream = dsa_port_upstream_port(ds, port);
 	int i;
 
 	mutex_lock(&priv->reg_mutex);
@@ -832,8 +847,8 @@ mt7530_port_bridge_leave(struct dsa_switch *ds, int port,
 	 */
 	if (priv->ports[port].enable)
 		mt7530_rmw(priv, MT7530_PCR_P(port), PCR_MATRIX_MASK,
-			   PCR_MATRIX(BIT(MT7530_CPU_PORT)));
-	priv->ports[port].pm = PCR_MATRIX(BIT(MT7530_CPU_PORT));
+			   PCR_MATRIX(BIT(upstream)));
+	priv->ports[port].pm = PCR_MATRIX(BIT(upstream));
 
 	mutex_unlock(&priv->reg_mutex);
 }
@@ -908,15 +923,7 @@ mt7530_port_fdb_dump(struct dsa_switch *ds, int port,
 static enum dsa_tag_protocol
 mtk_get_tag_protocol(struct dsa_switch *ds)
 {
-	struct mt7530_priv *priv = ds->priv;
-
-	if (!dsa_is_cpu_port(ds, MT7530_CPU_PORT)) {
-		dev_warn(priv->dev,
-			 "port not matched with tagging CPU port\n");
-		return DSA_TAG_PROTO_NONE;
-	} else {
-		return DSA_TAG_PROTO_MTK;
-	}
+	return DSA_TAG_PROTO_MTK;
 }
 
 static int
@@ -989,8 +996,13 @@ mt7530_setup(struct dsa_switch *ds)
 
 	/* Enable Port 6 only; P5 as GMAC5 which currently is not supported */
 	val = mt7530_read(priv, MT7530_MHWTRAP);
-	val &= ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
+	val &= ~MHWTRAP_P5_DIS & ~MHWTRAP_P6_DIS & ~MHWTRAP_PHY_ACCESS;
 	val |= MHWTRAP_MANUAL;
+	if (!dsa_is_cpu_port(ds, 5)) {
+		val |= MHWTRAP_P5_DIS;
+		val |= MHWTRAP_P5_MAC_SEL;
+		val |= MHWTRAP_P5_RGMII_MODE;
+	}
 	mt7530_write(priv, MT7530_MHWTRAP, val);
 
 	/* Enable and reset MIB counters */
@@ -1037,10 +1049,10 @@ static const struct dsa_switch_ops mt7530_switch_ops = {
 };
 
 static int
-mt7530_probe(struct mdio_device *mdiodev)
+mt7530_probe(struct platform_device *mdiodev)
 {
 	struct mt7530_priv *priv;
-	struct device_node *dn;
+	struct device_node *dn, *mdio;
 
 	dn = mdiodev->dev.of_node;
 
@@ -1088,7 +1100,12 @@ mt7530_probe(struct mdio_device *mdiodev)
 		}
 	}
 
-	priv->bus = mdiodev->bus;
+	mdio = of_parse_phandle(dn, "dsa,mii-bus", 0);
+	if (!mdio)
+		return -EINVAL;
+	priv->bus = of_mdio_find_bus(mdio);
+	if (!priv->bus)
+		return -EPROBE_DEFER;
 	priv->dev = &mdiodev->dev;
 	priv->ds->priv = priv;
 	priv->ds->ops = &mt7530_switch_ops;
@@ -1098,8 +1115,8 @@ mt7530_probe(struct mdio_device *mdiodev)
 	return dsa_register_switch(priv->ds);
 }
 
-static void
-mt7530_remove(struct mdio_device *mdiodev)
+static int
+mt7530_remove(struct platform_device *mdiodev)
 {
 	struct mt7530_priv *priv = dev_get_drvdata(&mdiodev->dev);
 	int ret = 0;
@@ -1116,6 +1133,8 @@ mt7530_remove(struct mdio_device *mdiodev)
 
 	dsa_unregister_switch(priv->ds);
 	mutex_destroy(&priv->reg_mutex);
+
+	return 0;
 }
 
 static const struct of_device_id mt7530_of_match[] = {
@@ -1124,16 +1143,16 @@ static const struct of_device_id mt7530_of_match[] = {
 };
 MODULE_DEVICE_TABLE(of, mt7530_of_match);
 
-static struct mdio_driver mt7530_mdio_driver = {
+static struct platform_driver mtk_mt7530_driver = {
 	.probe  = mt7530_probe,
 	.remove = mt7530_remove,
-	.mdiodrv.driver = {
+	.driver = {
 		.name = "mt7530",
 		.of_match_table = mt7530_of_match,
 	},
 };
+module_platform_driver(mtk_mt7530_driver);
 
-mdio_module_driver(mt7530_mdio_driver);
 
 MODULE_AUTHOR("Sean Wang <sean.wang@mediatek.com>");
 MODULE_DESCRIPTION("Driver for Mediatek MT7530 Switch");
diff --git a/drivers/net/dsa/mt7530.h b/drivers/net/dsa/mt7530.h
index 74db9822eb40..8fd7d78d785a 100644
--- a/drivers/net/dsa/mt7530.h
+++ b/drivers/net/dsa/mt7530.h
@@ -22,6 +22,10 @@
 
 #define TRGMII_BASE(x)			(0x10000 + (x))
 
+/* Registers for GDMA configuration access */
+#define MTK_GDMA_FWD_CFG(x)		(0x500 + (x * 0x1000))
+#define GDMA_SPEC_TAG			BIT(24)
+
 /* Registers to ethsys access */
 #define ETHSYS_CLKCFG0			0x2c
 #define  ETHSYS_TRGMII_CLK_SEL362_5	BIT(11)
diff --git a/drivers/net/ethernet/mediatek/Kconfig b/drivers/net/ethernet/mediatek/Kconfig
index 822806fd856f..f9149d2a4694 100644
--- a/drivers/net/ethernet/mediatek/Kconfig
+++ b/drivers/net/ethernet/mediatek/Kconfig
@@ -1,70 +1,17 @@
 config NET_VENDOR_MEDIATEK
-	tristate "Mediatek/Ralink ethernet driver"
-	depends on RALINK
-	help
-	  This driver supports the ethernet mac inside the Mediatek and Ralink WiSoCs
+	bool "MediaTek ethernet driver"
+	depends on ARCH_MEDIATEK
+	---help---
+	  If you have a Mediatek SoC with ethernet, say Y.
 
-config NET_MEDIATEK_SOC
-	def_tristate NET_VENDOR_MEDIATEK
-
-if NET_MEDIATEK_SOC
-choice
-	prompt "MAC type"
-
-config NET_MEDIATEK_RT2880
-	bool "RT2882"
-	depends on MIPS && SOC_RT288X
-
-config NET_MEDIATEK_RT3050
-	bool "RT3050/MT7628"
-	depends on MIPS && (SOC_RT305X || SOC_MT7620)
-
-config NET_MEDIATEK_RT3883
-	bool "RT3883"
-	depends on MIPS && SOC_RT3883
-
-config NET_MEDIATEK_MT7620
-	bool "MT7620"
-	depends on MIPS && SOC_MT7620
-
-config NET_MEDIATEK_MT7621
-	bool "MT7621"
-	depends on MIPS && SOC_MT7621
-
-endchoice
+if NET_VENDOR_MEDIATEK
 
-config NET_MEDIATEK_OFFLOAD
-	def_bool NET_MEDIATEK_SOC
-	depends on NET_MEDIATEK_MT7621
-
-config NET_MEDIATEK_HW_QOS
-	def_bool NET_MEDIATEK_SOC
-	depends on NET_MEDIATEK_MT7623
-
-config NET_MEDIATEK_MDIO
-	def_bool NET_MEDIATEK_SOC
-	depends on (NET_MEDIATEK_RT2880 || NET_MEDIATEK_RT3883 || NET_MEDIATEK_MT7620 || NET_MEDIATEK_MT7621)
+config NET_MEDIATEK_SOC
+	tristate "MediaTek SoC Gigabit Ethernet support"
+	depends on NET_VENDOR_MEDIATEK
 	select PHYLIB
+	---help---
+	  This driver supports the gigabit ethernet MACs in the
+	  MediaTek SoC family.
 
-config NET_MEDIATEK_MDIO_RT2880
-	def_bool NET_MEDIATEK_SOC
-	depends on (NET_MEDIATEK_RT2880 || NET_MEDIATEK_RT3883)
-	select NET_MEDIATEK_MDIO
-
-config NET_MEDIATEK_MDIO_MT7620
-	def_bool NET_MEDIATEK_SOC
-	depends on (NET_MEDIATEK_MT7620 || NET_MEDIATEK_MT7621)
-	select NET_MEDIATEK_MDIO
-
-config NET_MEDIATEK_ESW_RT3050
-	def_tristate NET_MEDIATEK_SOC
-	depends on NET_MEDIATEK_RT3050
-
-config NET_MEDIATEK_GSW_MT7620
-	def_tristate NET_MEDIATEK_SOC
-	depends on NET_MEDIATEK_MT7620
-
-config NET_MEDIATEK_GSW_MT7621
-	def_tristate NET_MEDIATEK_SOC
-	depends on NET_MEDIATEK_MT7621
-endif
+endif #NET_VENDOR_MEDIATEK
diff --git a/drivers/net/ethernet/mediatek/Makefile b/drivers/net/ethernet/mediatek/Makefile
index b038ae369948..aa3f1c8ccd4a 100644
--- a/drivers/net/ethernet/mediatek/Makefile
+++ b/drivers/net/ethernet/mediatek/Makefile
@@ -1,22 +1,5 @@
 #
-# Makefile for the Ralink SoCs built-in ethernet macs
+# Makefile for the Mediatek SoCs built-in ethernet macs
 #
 
-mtk-eth-soc-y					+= mtk_eth_soc.o ethtool.o
-
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MDIO)		+= mdio.o
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MDIO_RT2880)	+= mdio_rt2880.o
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MDIO_MT7620)	+= mdio_mt7620.o
-
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_OFFLOAD)	+= mtk_offload.o mtk_debugfs.o
-
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_RT2880)	+= soc_rt2880.o
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_RT3050)	+= soc_rt3050.o
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_RT3883)	+= soc_rt3883.o
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MT7620)	+= soc_mt7620.o
-mtk-eth-soc-$(CONFIG_NET_MEDIATEK_MT7621)	+= soc_mt7621.o
-
-obj-$(CONFIG_NET_MEDIATEK_ESW_RT3050)		+= esw_rt3050.o
-obj-$(CONFIG_NET_MEDIATEK_GSW_MT7620)		+= gsw_mt7620.o mt7530.o
-obj-$(CONFIG_NET_MEDIATEK_GSW_MT7621)		+= gsw_mt7621.o mt7530.o
-obj-$(CONFIG_NET_MEDIATEK_SOC)			+= mtk-eth-soc.o
+obj-$(CONFIG_NET_MEDIATEK_SOC)			+= mtk_eth_soc.o
diff --git a/drivers/net/ethernet/mediatek/esw_rt3050.c b/drivers/net/ethernet/mediatek/esw_rt3050.c
deleted file mode 100644
index 816c588dd7f2..000000000000
--- a/drivers/net/ethernet/mediatek/esw_rt3050.c
+++ /dev/null
@@ -1,1461 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- *   Copyright (C) 2016 Vittorio Gambaletta <openwrt@vittgam.net>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/platform_device.h>
-#include <asm/mach-ralink/ralink_regs.h>
-#include <linux/of_irq.h>
-
-#include <linux/switch.h>
-
-#include "mtk_eth_soc.h"
-
-/* HW limitations for this switch:
- * - No large frame support (PKT_MAX_LEN at most 1536)
- * - Can't have untagged vlan and tagged vlan on one port at the same time,
- *   though this might be possible using the undocumented PPE.
- */
-
-#define RT305X_ESW_REG_ISR		0x00
-#define RT305X_ESW_REG_IMR		0x04
-#define RT305X_ESW_REG_FCT0		0x08
-#define RT305X_ESW_REG_PFC1		0x14
-#define RT305X_ESW_REG_ATS		0x24
-#define RT305X_ESW_REG_ATS0		0x28
-#define RT305X_ESW_REG_ATS1		0x2c
-#define RT305X_ESW_REG_ATS2		0x30
-#define RT305X_ESW_REG_PVIDC(_n)	(0x40 + 4 * (_n))
-#define RT305X_ESW_REG_VLANI(_n)	(0x50 + 4 * (_n))
-#define RT305X_ESW_REG_VMSC(_n)		(0x70 + 4 * (_n))
-#define RT305X_ESW_REG_POA		0x80
-#define RT305X_ESW_REG_FPA		0x84
-#define RT305X_ESW_REG_SOCPC		0x8c
-#define RT305X_ESW_REG_POC0		0x90
-#define RT305X_ESW_REG_POC1		0x94
-#define RT305X_ESW_REG_POC2		0x98
-#define RT305X_ESW_REG_SGC		0x9c
-#define RT305X_ESW_REG_STRT		0xa0
-#define RT305X_ESW_REG_PCR0		0xc0
-#define RT305X_ESW_REG_PCR1		0xc4
-#define RT305X_ESW_REG_FPA2		0xc8
-#define RT305X_ESW_REG_FCT2		0xcc
-#define RT305X_ESW_REG_SGC2		0xe4
-#define RT305X_ESW_REG_P0LED		0xa4
-#define RT305X_ESW_REG_P1LED		0xa8
-#define RT305X_ESW_REG_P2LED		0xac
-#define RT305X_ESW_REG_P3LED		0xb0
-#define RT305X_ESW_REG_P4LED		0xb4
-#define RT305X_ESW_REG_PXPC(_x)		(0xe8 + (4 * _x))
-#define RT305X_ESW_REG_P1PC		0xec
-#define RT305X_ESW_REG_P2PC		0xf0
-#define RT305X_ESW_REG_P3PC		0xf4
-#define RT305X_ESW_REG_P4PC		0xf8
-#define RT305X_ESW_REG_P5PC		0xfc
-
-#define RT305X_ESW_LED_LINK		0
-#define RT305X_ESW_LED_100M		1
-#define RT305X_ESW_LED_DUPLEX		2
-#define RT305X_ESW_LED_ACTIVITY		3
-#define RT305X_ESW_LED_COLLISION	4
-#define RT305X_ESW_LED_LINKACT		5
-#define RT305X_ESW_LED_DUPLCOLL		6
-#define RT305X_ESW_LED_10MACT		7
-#define RT305X_ESW_LED_100MACT		8
-/* Additional led states not in datasheet: */
-#define RT305X_ESW_LED_BLINK		10
-#define RT305X_ESW_LED_ON		12
-
-#define RT305X_ESW_LINK_S		25
-#define RT305X_ESW_DUPLEX_S		9
-#define RT305X_ESW_SPD_S		0
-
-#define RT305X_ESW_PCR0_WT_NWAY_DATA_S	16
-#define RT305X_ESW_PCR0_WT_PHY_CMD	BIT(13)
-#define RT305X_ESW_PCR0_CPU_PHY_REG_S	8
-
-#define RT305X_ESW_PCR1_WT_DONE		BIT(0)
-
-#define RT305X_ESW_ATS_TIMEOUT		(5 * HZ)
-#define RT305X_ESW_PHY_TIMEOUT		(5 * HZ)
-
-#define RT305X_ESW_PVIDC_PVID_M		0xfff
-#define RT305X_ESW_PVIDC_PVID_S		12
-
-#define RT305X_ESW_VLANI_VID_M		0xfff
-#define RT305X_ESW_VLANI_VID_S		12
-
-#define RT305X_ESW_VMSC_MSC_M		0xff
-#define RT305X_ESW_VMSC_MSC_S		8
-
-#define RT305X_ESW_SOCPC_DISUN2CPU_S	0
-#define RT305X_ESW_SOCPC_DISMC2CPU_S	8
-#define RT305X_ESW_SOCPC_DISBC2CPU_S	16
-#define RT305X_ESW_SOCPC_CRC_PADDING	BIT(25)
-
-#define RT305X_ESW_POC0_EN_BP_S		0
-#define RT305X_ESW_POC0_EN_FC_S		8
-#define RT305X_ESW_POC0_DIS_RMC2CPU_S	16
-#define RT305X_ESW_POC0_DIS_PORT_M	0x7f
-#define RT305X_ESW_POC0_DIS_PORT_S	23
-
-#define RT305X_ESW_POC2_UNTAG_EN_M	0xff
-#define RT305X_ESW_POC2_UNTAG_EN_S	0
-#define RT305X_ESW_POC2_ENAGING_S	8
-#define RT305X_ESW_POC2_DIS_UC_PAUSE_S	16
-
-#define RT305X_ESW_SGC2_DOUBLE_TAG_M	0x7f
-#define RT305X_ESW_SGC2_DOUBLE_TAG_S	0
-#define RT305X_ESW_SGC2_LAN_PMAP_M	0x3f
-#define RT305X_ESW_SGC2_LAN_PMAP_S	24
-
-#define RT305X_ESW_PFC1_EN_VLAN_M	0xff
-#define RT305X_ESW_PFC1_EN_VLAN_S	16
-#define RT305X_ESW_PFC1_EN_TOS_S	24
-
-#define RT305X_ESW_VLAN_NONE		0xfff
-
-#define RT305X_ESW_GSC_BC_STROM_MASK	0x3
-#define RT305X_ESW_GSC_BC_STROM_SHIFT	4
-
-#define RT305X_ESW_GSC_LED_FREQ_MASK	0x3
-#define RT305X_ESW_GSC_LED_FREQ_SHIFT	23
-
-#define RT305X_ESW_POA_LINK_MASK	0x1f
-#define RT305X_ESW_POA_LINK_SHIFT	25
-
-#define RT305X_ESW_PORT_ST_CHG		BIT(26)
-#define RT305X_ESW_PORT0		0
-#define RT305X_ESW_PORT1		1
-#define RT305X_ESW_PORT2		2
-#define RT305X_ESW_PORT3		3
-#define RT305X_ESW_PORT4		4
-#define RT305X_ESW_PORT5		5
-#define RT305X_ESW_PORT6		6
-
-#define RT305X_ESW_PORTS_NONE		0
-
-#define RT305X_ESW_PMAP_LLLLLL		0x3f
-#define RT305X_ESW_PMAP_LLLLWL		0x2f
-#define RT305X_ESW_PMAP_WLLLLL		0x3e
-
-#define RT305X_ESW_PORTS_INTERNAL					\
-		(BIT(RT305X_ESW_PORT0) | BIT(RT305X_ESW_PORT1) |	\
-		 BIT(RT305X_ESW_PORT2) | BIT(RT305X_ESW_PORT3) |	\
-		 BIT(RT305X_ESW_PORT4))
-
-#define RT305X_ESW_PORTS_NOCPU						\
-		(RT305X_ESW_PORTS_INTERNAL | BIT(RT305X_ESW_PORT5))
-
-#define RT305X_ESW_PORTS_CPU	BIT(RT305X_ESW_PORT6)
-
-#define RT305X_ESW_PORTS_ALL						\
-		(RT305X_ESW_PORTS_NOCPU | RT305X_ESW_PORTS_CPU)
-
-#define RT305X_ESW_NUM_VLANS		16
-#define RT305X_ESW_NUM_VIDS		4096
-#define RT305X_ESW_NUM_PORTS		7
-#define RT305X_ESW_NUM_LANWAN		6
-#define RT305X_ESW_NUM_LEDS		5
-
-#define RT5350_ESW_REG_PXTPC(_x)	(0x150 + (4 * _x))
-#define RT5350_EWS_REG_LED_POLARITY	0x168
-#define RT5350_RESET_EPHY		BIT(24)
-
-enum {
-	/* Global attributes. */
-	RT305X_ESW_ATTR_ENABLE_VLAN,
-	RT305X_ESW_ATTR_ALT_VLAN_DISABLE,
-	RT305X_ESW_ATTR_BC_STATUS,
-	RT305X_ESW_ATTR_LED_FREQ,
-	/* Port attributes. */
-	RT305X_ESW_ATTR_PORT_DISABLE,
-	RT305X_ESW_ATTR_PORT_DOUBLETAG,
-	RT305X_ESW_ATTR_PORT_UNTAG,
-	RT305X_ESW_ATTR_PORT_LED,
-	RT305X_ESW_ATTR_PORT_LAN,
-	RT305X_ESW_ATTR_PORT_RECV_BAD,
-	RT305X_ESW_ATTR_PORT_RECV_GOOD,
-	RT5350_ESW_ATTR_PORT_TR_BAD,
-	RT5350_ESW_ATTR_PORT_TR_GOOD,
-};
-
-struct esw_port {
-	bool	disable;
-	bool	doubletag;
-	bool	untag;
-	u8	led;
-	u16	pvid;
-};
-
-struct esw_vlan {
-	u8	ports;
-	u16	vid;
-};
-
-enum {
-	RT305X_ESW_VLAN_CONFIG_NONE = 0,
-	RT305X_ESW_VLAN_CONFIG_LLLLW,
-	RT305X_ESW_VLAN_CONFIG_WLLLL,
-};
-
-struct rt305x_esw {
-	struct device		*dev;
-	void __iomem		*base;
-	int			irq;
-
-	/* Protects against concurrent register r/w operations. */
-	spinlock_t		reg_rw_lock;
-
-	unsigned char		port_map;
-	unsigned char		port_disable;
-	unsigned int		reg_initval_fct2;
-	unsigned int		reg_initval_fpa2;
-	unsigned int		reg_led_polarity;
-
-	struct switch_dev	swdev;
-	bool			global_vlan_enable;
-	bool			alt_vlan_disable;
-	int			bc_storm_protect;
-	int			led_frequency;
-	struct esw_vlan vlans[RT305X_ESW_NUM_VLANS];
-	struct esw_port ports[RT305X_ESW_NUM_PORTS];
-
-};
-
-static inline void esw_w32(struct rt305x_esw *esw, u32 val, unsigned reg)
-{
-	__raw_writel(val, esw->base + reg);
-}
-
-static inline u32 esw_r32(struct rt305x_esw *esw, unsigned reg)
-{
-	return __raw_readl(esw->base + reg);
-}
-
-static inline void esw_rmw_raw(struct rt305x_esw *esw, unsigned reg,
-			       unsigned long mask, unsigned long val)
-{
-	unsigned long t;
-
-	t = __raw_readl(esw->base + reg) & ~mask;
-	__raw_writel(t | val, esw->base + reg);
-}
-
-static void esw_rmw(struct rt305x_esw *esw, unsigned reg,
-		    unsigned long mask, unsigned long val)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&esw->reg_rw_lock, flags);
-	esw_rmw_raw(esw, reg, mask, val);
-	spin_unlock_irqrestore(&esw->reg_rw_lock, flags);
-}
-
-static u32 rt305x_mii_write(struct rt305x_esw *esw, u32 phy_addr,
-			    u32 phy_register, u32 write_data)
-{
-	unsigned long t_start = jiffies;
-	int ret = 0;
-
-	while (1) {
-		if (!(esw_r32(esw, RT305X_ESW_REG_PCR1) &
-		      RT305X_ESW_PCR1_WT_DONE))
-			break;
-		if (time_after(jiffies, t_start + RT305X_ESW_PHY_TIMEOUT)) {
-			ret = 1;
-			goto out;
-		}
-	}
-
-	write_data &= 0xffff;
-	esw_w32(esw, (write_data << RT305X_ESW_PCR0_WT_NWAY_DATA_S) |
-		      (phy_register << RT305X_ESW_PCR0_CPU_PHY_REG_S) |
-		      (phy_addr) | RT305X_ESW_PCR0_WT_PHY_CMD,
-		RT305X_ESW_REG_PCR0);
-
-	t_start = jiffies;
-	while (1) {
-		if (esw_r32(esw, RT305X_ESW_REG_PCR1) &
-			    RT305X_ESW_PCR1_WT_DONE)
-			break;
-
-		if (time_after(jiffies, t_start + RT305X_ESW_PHY_TIMEOUT)) {
-			ret = 1;
-			break;
-		}
-	}
-out:
-	if (ret)
-		dev_err(esw->dev, "ramips_eth: MDIO timeout\n");
-	return ret;
-}
-
-static unsigned esw_get_vlan_id(struct rt305x_esw *esw, unsigned vlan)
-{
-	unsigned s;
-	unsigned val;
-
-	s = RT305X_ESW_VLANI_VID_S * (vlan % 2);
-	val = esw_r32(esw, RT305X_ESW_REG_VLANI(vlan / 2));
-	val = (val >> s) & RT305X_ESW_VLANI_VID_M;
-
-	return val;
-}
-
-static void esw_set_vlan_id(struct rt305x_esw *esw, unsigned vlan, unsigned vid)
-{
-	unsigned s;
-
-	s = RT305X_ESW_VLANI_VID_S * (vlan % 2);
-	esw_rmw(esw,
-		       RT305X_ESW_REG_VLANI(vlan / 2),
-		       RT305X_ESW_VLANI_VID_M << s,
-		       (vid & RT305X_ESW_VLANI_VID_M) << s);
-}
-
-static unsigned esw_get_pvid(struct rt305x_esw *esw, unsigned port)
-{
-	unsigned s, val;
-
-	s = RT305X_ESW_PVIDC_PVID_S * (port % 2);
-	val = esw_r32(esw, RT305X_ESW_REG_PVIDC(port / 2));
-	return (val >> s) & RT305X_ESW_PVIDC_PVID_M;
-}
-
-static void esw_set_pvid(struct rt305x_esw *esw, unsigned port, unsigned pvid)
-{
-	unsigned s;
-
-	s = RT305X_ESW_PVIDC_PVID_S * (port % 2);
-	esw_rmw(esw,
-		       RT305X_ESW_REG_PVIDC(port / 2),
-		       RT305X_ESW_PVIDC_PVID_M << s,
-		       (pvid & RT305X_ESW_PVIDC_PVID_M) << s);
-}
-
-static unsigned esw_get_vmsc(struct rt305x_esw *esw, unsigned vlan)
-{
-	unsigned s, val;
-
-	s = RT305X_ESW_VMSC_MSC_S * (vlan % 4);
-	val = esw_r32(esw, RT305X_ESW_REG_VMSC(vlan / 4));
-	val = (val >> s) & RT305X_ESW_VMSC_MSC_M;
-
-	return val;
-}
-
-static void esw_set_vmsc(struct rt305x_esw *esw, unsigned vlan, unsigned msc)
-{
-	unsigned s;
-
-	s = RT305X_ESW_VMSC_MSC_S * (vlan % 4);
-	esw_rmw(esw,
-		       RT305X_ESW_REG_VMSC(vlan / 4),
-		       RT305X_ESW_VMSC_MSC_M << s,
-		       (msc & RT305X_ESW_VMSC_MSC_M) << s);
-}
-
-static unsigned esw_get_port_disable(struct rt305x_esw *esw)
-{
-	unsigned reg;
-
-	reg = esw_r32(esw, RT305X_ESW_REG_POC0);
-	return (reg >> RT305X_ESW_POC0_DIS_PORT_S) &
-	       RT305X_ESW_POC0_DIS_PORT_M;
-}
-
-static void esw_set_port_disable(struct rt305x_esw *esw, unsigned disable_mask)
-{
-	unsigned old_mask;
-	unsigned enable_mask;
-	unsigned changed;
-	int i;
-
-	old_mask = esw_get_port_disable(esw);
-	changed = old_mask ^ disable_mask;
-	enable_mask = old_mask & disable_mask;
-
-	/* enable before writing to MII */
-	esw_rmw(esw, RT305X_ESW_REG_POC0,
-		       (RT305X_ESW_POC0_DIS_PORT_M <<
-			RT305X_ESW_POC0_DIS_PORT_S),
-		       enable_mask << RT305X_ESW_POC0_DIS_PORT_S);
-
-	for (i = 0; i < RT305X_ESW_NUM_LEDS; i++) {
-		if (!(changed & (1 << i)))
-			continue;
-		if (disable_mask & (1 << i)) {
-			/* disable */
-			rt305x_mii_write(esw, i, MII_BMCR,
-					 BMCR_PDOWN);
-		} else {
-			/* enable */
-			rt305x_mii_write(esw, i, MII_BMCR,
-					 BMCR_FULLDPLX |
-					 BMCR_ANENABLE |
-					 BMCR_ANRESTART |
-					 BMCR_SPEED100);
-		}
-	}
-
-	/* disable after writing to MII */
-	esw_rmw(esw, RT305X_ESW_REG_POC0,
-		       (RT305X_ESW_POC0_DIS_PORT_M <<
-			RT305X_ESW_POC0_DIS_PORT_S),
-		       disable_mask << RT305X_ESW_POC0_DIS_PORT_S);
-}
-
-static void esw_set_gsc(struct rt305x_esw *esw)
-{
-	esw_rmw(esw, RT305X_ESW_REG_SGC,
-		RT305X_ESW_GSC_BC_STROM_MASK << RT305X_ESW_GSC_BC_STROM_SHIFT,
-		esw->bc_storm_protect << RT305X_ESW_GSC_BC_STROM_SHIFT);
-	esw_rmw(esw, RT305X_ESW_REG_SGC,
-		RT305X_ESW_GSC_LED_FREQ_MASK << RT305X_ESW_GSC_LED_FREQ_SHIFT,
-		esw->led_frequency << RT305X_ESW_GSC_LED_FREQ_SHIFT);
-}
-
-static int esw_apply_config(struct switch_dev *dev);
-
-static void esw_hw_init(struct rt305x_esw *esw)
-{
-	int i;
-	u8 port_disable = 0;
-	u8 port_map = RT305X_ESW_PMAP_LLLLLL;
-
-	/* vodoo from original driver */
-	esw_w32(esw, 0xC8A07850, RT305X_ESW_REG_FCT0);
-	esw_w32(esw, 0x00000000, RT305X_ESW_REG_SGC2);
-	/* Port priority 1 for all ports, vlan enabled. */
-	esw_w32(esw, 0x00005555 |
-		     (RT305X_ESW_PORTS_ALL << RT305X_ESW_PFC1_EN_VLAN_S),
-		RT305X_ESW_REG_PFC1);
-
-	/* Enable all ports, Back Pressure and Flow Control */
-	esw_w32(esw, ((RT305X_ESW_PORTS_ALL << RT305X_ESW_POC0_EN_BP_S) |
-		      (RT305X_ESW_PORTS_ALL << RT305X_ESW_POC0_EN_FC_S)),
-		RT305X_ESW_REG_POC0);
-
-	/* Enable Aging, and VLAN TAG removal */
-	esw_w32(esw, ((RT305X_ESW_PORTS_ALL << RT305X_ESW_POC2_ENAGING_S) |
-		      (RT305X_ESW_PORTS_NOCPU << RT305X_ESW_POC2_UNTAG_EN_S)),
-		RT305X_ESW_REG_POC2);
-
-	if (esw->reg_initval_fct2)
-		esw_w32(esw, esw->reg_initval_fct2, RT305X_ESW_REG_FCT2);
-	else
-		esw_w32(esw, 0x0002500c, RT305X_ESW_REG_FCT2);
-
-	/* 300s aging timer, max packet len 1536, broadcast storm prevention
-	 * disabled, disable collision abort, mac xor48 hash, 10 packet back
-	 * pressure jam, GMII disable was_transmit, back pressure disabled,
-	 * 30ms led flash, unmatched IGMP as broadcast, rmc tb fault to all
-	 * ports.
-	 */
-	esw_w32(esw, 0x0008a301, RT305X_ESW_REG_SGC);
-
-	/* Setup SoC Port control register */
-	esw_w32(esw,
-		(RT305X_ESW_SOCPC_CRC_PADDING |
-		(RT305X_ESW_PORTS_CPU << RT305X_ESW_SOCPC_DISUN2CPU_S) |
-		(RT305X_ESW_PORTS_CPU << RT305X_ESW_SOCPC_DISMC2CPU_S) |
-		(RT305X_ESW_PORTS_CPU << RT305X_ESW_SOCPC_DISBC2CPU_S)),
-		RT305X_ESW_REG_SOCPC);
-
-	/* ext phy base addr 31, enable port 5 polling, rx/tx clock skew 1,
-	 * turbo mii off, rgmi 3.3v off
-	 * port5: disabled
-	 * port6: enabled, gige, full-duplex, rx/tx-flow-control
-	 */
-	if (esw->reg_initval_fpa2)
-		esw_w32(esw, esw->reg_initval_fpa2, RT305X_ESW_REG_FPA2);
-	else
-		esw_w32(esw, 0x3f502b28, RT305X_ESW_REG_FPA2);
-	esw_w32(esw, 0x00000000, RT305X_ESW_REG_FPA);
-
-	/* Force Link/Activity on ports */
-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P0LED);
-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P1LED);
-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P2LED);
-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P3LED);
-	esw_w32(esw, 0x00000005, RT305X_ESW_REG_P4LED);
-
-	/* Copy disabled port configuration from device tree setup */
-	port_disable = esw->port_disable;
-
-	/* Disable nonexistent ports by reading the switch config
-	 * after having enabled all possible ports above
-	 */
-	port_disable |= esw_get_port_disable(esw);
-
-	for (i = 0; i < 6; i++)
-		esw->ports[i].disable = (port_disable & (1 << i)) != 0;
-
-	if (ralink_soc == RT305X_SOC_RT3352) {
-		/* reset EPHY */
-		fe_reset(RT5350_RESET_EPHY);
-
-		rt305x_mii_write(esw, 0, 31, 0x8000);
-		for (i = 0; i < 5; i++) {
-			if (esw->ports[i].disable) {
-				rt305x_mii_write(esw, i, MII_BMCR, BMCR_PDOWN);
-			} else {
-				rt305x_mii_write(esw, i, MII_BMCR,
-						 BMCR_FULLDPLX |
-						 BMCR_ANENABLE |
-						 BMCR_SPEED100);
-			}
-			/* TX10 waveform coefficient LSB=0 disable PHY */
-			rt305x_mii_write(esw, i, 26, 0x1601);
-			/* TX100/TX10 AD/DA current bias */
-			rt305x_mii_write(esw, i, 29, 0x7016);
-			/* TX100 slew rate control */
-			rt305x_mii_write(esw, i, 30, 0x0038);
-		}
-
-		/* select global register */
-		rt305x_mii_write(esw, 0, 31, 0x0);
-		/* enlarge agcsel threshold 3 and threshold 2 */
-		rt305x_mii_write(esw, 0, 1, 0x4a40);
-		/* enlarge agcsel threshold 5 and threshold 4 */
-		rt305x_mii_write(esw, 0, 2, 0x6254);
-		/* enlarge agcsel threshold  */
-		rt305x_mii_write(esw, 0, 3, 0xa17f);
-		rt305x_mii_write(esw, 0, 12, 0x7eaa);
-		/* longer TP_IDL tail length */
-		rt305x_mii_write(esw, 0, 14, 0x65);
-		/* increased squelch pulse count threshold. */
-		rt305x_mii_write(esw, 0, 16, 0x0684);
-		/* set TX10 signal amplitude threshold to minimum */
-		rt305x_mii_write(esw, 0, 17, 0x0fe0);
-		/* set squelch amplitude to higher threshold */
-		rt305x_mii_write(esw, 0, 18, 0x40ba);
-		/* tune TP_IDL tail and head waveform, enable power
-		 * down slew rate control
-		 */
-		rt305x_mii_write(esw, 0, 22, 0x253f);
-		/* set PLL/Receive bias current are calibrated */
-		rt305x_mii_write(esw, 0, 27, 0x2fda);
-		/* change PLL/Receive bias current to internal(RT3350) */
-		rt305x_mii_write(esw, 0, 28, 0xc410);
-		/* change PLL bias current to internal(RT3052_MP3) */
-		rt305x_mii_write(esw, 0, 29, 0x598b);
-		/* select local register */
-		rt305x_mii_write(esw, 0, 31, 0x8000);
-	} else if (ralink_soc == RT305X_SOC_RT5350) {
-		/* reset EPHY */
-		fe_reset(RT5350_RESET_EPHY);
-
-		/* set the led polarity */
-		esw_w32(esw, esw->reg_led_polarity & 0x1F,
-			RT5350_EWS_REG_LED_POLARITY);
-
-		/* local registers */
-		rt305x_mii_write(esw, 0, 31, 0x8000);
-		for (i = 0; i < 5; i++) {
-			if (esw->ports[i].disable) {
-				rt305x_mii_write(esw, i, MII_BMCR, BMCR_PDOWN);
-			} else {
-				rt305x_mii_write(esw, i, MII_BMCR,
-						 BMCR_FULLDPLX |
-						 BMCR_ANENABLE |
-						 BMCR_SPEED100);
-			}
-			/* TX10 waveform coefficient LSB=0 disable PHY */
-			rt305x_mii_write(esw, i, 26, 0x1601);
-			/* TX100/TX10 AD/DA current bias */
-			rt305x_mii_write(esw, i, 29, 0x7015);
-			/* TX100 slew rate control */
-			rt305x_mii_write(esw, i, 30, 0x0038);
-		}
-
-		/* global registers */
-		rt305x_mii_write(esw, 0, 31, 0x0);
-		/* enlarge agcsel threshold 3 and threshold 2 */
-		rt305x_mii_write(esw, 0, 1, 0x4a40);
-		/* enlarge agcsel threshold 5 and threshold 4 */
-		rt305x_mii_write(esw, 0, 2, 0x6254);
-		/* enlarge agcsel threshold 6 */
-		rt305x_mii_write(esw, 0, 3, 0xa17f);
-		rt305x_mii_write(esw, 0, 12, 0x7eaa);
-		/* longer TP_IDL tail length */
-		rt305x_mii_write(esw, 0, 14, 0x65);
-		/* increased squelch pulse count threshold. */
-		rt305x_mii_write(esw, 0, 16, 0x0684);
-		/* set TX10 signal amplitude threshold to minimum */
-		rt305x_mii_write(esw, 0, 17, 0x0fe0);
-		/* set squelch amplitude to higher threshold */
-		rt305x_mii_write(esw, 0, 18, 0x40ba);
-		/* tune TP_IDL tail and head waveform, enable power
-		 * down slew rate control
-		 */
-		rt305x_mii_write(esw, 0, 22, 0x253f);
-		/* set PLL/Receive bias current are calibrated */
-		rt305x_mii_write(esw, 0, 27, 0x2fda);
-		/* change PLL/Receive bias current to internal(RT3350) */
-		rt305x_mii_write(esw, 0, 28, 0xc410);
-		/* change PLL bias current to internal(RT3052_MP3) */
-		rt305x_mii_write(esw, 0, 29, 0x598b);
-		/* select local register */
-		rt305x_mii_write(esw, 0, 31, 0x8000);
-	} else if (ralink_soc == MT762X_SOC_MT7628AN || ralink_soc == MT762X_SOC_MT7688) {
-		int i;
-
-		/* reset EPHY */
-		fe_reset(RT5350_RESET_EPHY);
-
-		rt305x_mii_write(esw, 0, 31, 0x2000); /* change G2 page */
-		rt305x_mii_write(esw, 0, 26, 0x0020);
-
-		for (i = 0; i < 5; i++) {
-			rt305x_mii_write(esw, i, 31, 0x8000);
-			rt305x_mii_write(esw, i,  0, 0x3100);
-			rt305x_mii_write(esw, i, 30, 0xa000);
-			rt305x_mii_write(esw, i, 31, 0xa000);
-			rt305x_mii_write(esw, i, 16, 0x0606);
-			rt305x_mii_write(esw, i, 23, 0x0f0e);
-			rt305x_mii_write(esw, i, 24, 0x1610);
-			rt305x_mii_write(esw, i, 30, 0x1f15);
-			rt305x_mii_write(esw, i, 28, 0x6111);
-			rt305x_mii_write(esw, i, 31, 0x2000);
-			rt305x_mii_write(esw, i, 26, 0x0000);
-		}
-
-		/* 100Base AOI setting */
-		rt305x_mii_write(esw, 0, 31, 0x5000);
-		rt305x_mii_write(esw, 0, 19, 0x004a);
-		rt305x_mii_write(esw, 0, 20, 0x015a);
-		rt305x_mii_write(esw, 0, 21, 0x00ee);
-		rt305x_mii_write(esw, 0, 22, 0x0033);
-		rt305x_mii_write(esw, 0, 23, 0x020a);
-		rt305x_mii_write(esw, 0, 24, 0x0000);
-		rt305x_mii_write(esw, 0, 25, 0x024a);
-		rt305x_mii_write(esw, 0, 26, 0x035a);
-		rt305x_mii_write(esw, 0, 27, 0x02ee);
-		rt305x_mii_write(esw, 0, 28, 0x0233);
-		rt305x_mii_write(esw, 0, 29, 0x000a);
-		rt305x_mii_write(esw, 0, 30, 0x0000);
-	} else {
-		rt305x_mii_write(esw, 0, 31, 0x8000);
-		for (i = 0; i < 5; i++) {
-			if (esw->ports[i].disable) {
-				rt305x_mii_write(esw, i, MII_BMCR, BMCR_PDOWN);
-			} else {
-				rt305x_mii_write(esw, i, MII_BMCR,
-						 BMCR_FULLDPLX |
-						 BMCR_ANENABLE |
-						 BMCR_SPEED100);
-			}
-			/* TX10 waveform coefficient */
-			rt305x_mii_write(esw, i, 26, 0x1601);
-			/* TX100/TX10 AD/DA current bias */
-			rt305x_mii_write(esw, i, 29, 0x7058);
-			/* TX100 slew rate control */
-			rt305x_mii_write(esw, i, 30, 0x0018);
-		}
-
-		/* PHY IOT */
-		/* select global register */
-		rt305x_mii_write(esw, 0, 31, 0x0);
-		/* tune TP_IDL tail and head waveform */
-		rt305x_mii_write(esw, 0, 22, 0x052f);
-		/* set TX10 signal amplitude threshold to minimum */
-		rt305x_mii_write(esw, 0, 17, 0x0fe0);
-		/* set squelch amplitude to higher threshold */
-		rt305x_mii_write(esw, 0, 18, 0x40ba);
-		/* longer TP_IDL tail length */
-		rt305x_mii_write(esw, 0, 14, 0x65);
-		/* select local register */
-		rt305x_mii_write(esw, 0, 31, 0x8000);
-	}
-
-	if (esw->port_map)
-		port_map = esw->port_map;
-	else
-		port_map = RT305X_ESW_PMAP_LLLLLL;
-
-	/* Unused HW feature, but still nice to be consistent here...
-	 * This is also exported to userspace ('lan' attribute) so it's
-	 * conveniently usable to decide which ports go into the wan vlan by
-	 * default.
-	 */
-	esw_rmw(esw, RT305X_ESW_REG_SGC2,
-		RT305X_ESW_SGC2_LAN_PMAP_M << RT305X_ESW_SGC2_LAN_PMAP_S,
-		port_map << RT305X_ESW_SGC2_LAN_PMAP_S);
-
-	/* make the switch leds blink */
-	for (i = 0; i < RT305X_ESW_NUM_LEDS; i++)
-		esw->ports[i].led = 0x05;
-
-	/* Apply the empty config. */
-	esw_apply_config(&esw->swdev);
-
-	/* Only unmask the port change interrupt */
-	esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
-}
-
-static irqreturn_t esw_interrupt(int irq, void *_esw)
-{
-	struct rt305x_esw *esw = (struct rt305x_esw *)_esw;
-	u32 status;
-
-	status = esw_r32(esw, RT305X_ESW_REG_ISR);
-	if (status & RT305X_ESW_PORT_ST_CHG) {
-		u32 link = esw_r32(esw, RT305X_ESW_REG_POA);
-
-		link >>= RT305X_ESW_POA_LINK_SHIFT;
-		link &= RT305X_ESW_POA_LINK_MASK;
-		dev_info(esw->dev, "link changed 0x%02X\n", link);
-	}
-	esw_w32(esw, status, RT305X_ESW_REG_ISR);
-
-	return IRQ_HANDLED;
-}
-
-static int esw_apply_config(struct switch_dev *dev)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int i;
-	u8 disable = 0;
-	u8 doubletag = 0;
-	u8 en_vlan = 0;
-	u8 untag = 0;
-
-	for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
-		u32 vid, vmsc;
-		if (esw->global_vlan_enable) {
-			vid = esw->vlans[i].vid;
-			vmsc = esw->vlans[i].ports;
-		} else {
-			vid = RT305X_ESW_VLAN_NONE;
-			vmsc = RT305X_ESW_PORTS_NONE;
-		}
-		esw_set_vlan_id(esw, i, vid);
-		esw_set_vmsc(esw, i, vmsc);
-	}
-
-	for (i = 0; i < RT305X_ESW_NUM_PORTS; i++) {
-		u32 pvid;
-		disable |= esw->ports[i].disable << i;
-		if (esw->global_vlan_enable) {
-			doubletag |= esw->ports[i].doubletag << i;
-			en_vlan   |= 1                       << i;
-			untag     |= esw->ports[i].untag     << i;
-			pvid       = esw->ports[i].pvid;
-		} else {
-			int x = esw->alt_vlan_disable ? 0 : 1;
-			doubletag |= x << i;
-			en_vlan   |= x << i;
-			untag     |= x << i;
-			pvid       = 0;
-		}
-		esw_set_pvid(esw, i, pvid);
-		if (i < RT305X_ESW_NUM_LEDS)
-			esw_w32(esw, esw->ports[i].led,
-				      RT305X_ESW_REG_P0LED + 4*i);
-	}
-
-	esw_set_gsc(esw);
-	esw_set_port_disable(esw, disable);
-	esw_rmw(esw, RT305X_ESW_REG_SGC2,
-		       (RT305X_ESW_SGC2_DOUBLE_TAG_M <<
-			RT305X_ESW_SGC2_DOUBLE_TAG_S),
-		       doubletag << RT305X_ESW_SGC2_DOUBLE_TAG_S);
-	esw_rmw(esw, RT305X_ESW_REG_PFC1,
-		       RT305X_ESW_PFC1_EN_VLAN_M << RT305X_ESW_PFC1_EN_VLAN_S,
-		       en_vlan << RT305X_ESW_PFC1_EN_VLAN_S);
-	esw_rmw(esw, RT305X_ESW_REG_POC2,
-		       RT305X_ESW_POC2_UNTAG_EN_M << RT305X_ESW_POC2_UNTAG_EN_S,
-		       untag << RT305X_ESW_POC2_UNTAG_EN_S);
-
-	if (!esw->global_vlan_enable) {
-		/*
-		 * Still need to put all ports into vlan 0 or they'll be
-		 * isolated.
-		 * NOTE: vlan 0 is special, no vlan tag is prepended
-		 */
-		esw_set_vlan_id(esw, 0, 0);
-		esw_set_vmsc(esw, 0, RT305X_ESW_PORTS_ALL);
-	}
-
-	return 0;
-}
-
-static int esw_reset_switch(struct switch_dev *dev)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	esw->global_vlan_enable = 0;
-	memset(esw->ports, 0, sizeof(esw->ports));
-	memset(esw->vlans, 0, sizeof(esw->vlans));
-	esw_hw_init(esw);
-
-	return 0;
-}
-
-static int esw_get_vlan_enable(struct switch_dev *dev,
-			   const struct switch_attr *attr,
-			   struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	val->value.i = esw->global_vlan_enable;
-
-	return 0;
-}
-
-static int esw_set_vlan_enable(struct switch_dev *dev,
-			   const struct switch_attr *attr,
-			   struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	esw->global_vlan_enable = val->value.i != 0;
-
-	return 0;
-}
-
-static int esw_get_alt_vlan_disable(struct switch_dev *dev,
-				const struct switch_attr *attr,
-				struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	val->value.i = esw->alt_vlan_disable;
-
-	return 0;
-}
-
-static int esw_set_alt_vlan_disable(struct switch_dev *dev,
-				const struct switch_attr *attr,
-				struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	esw->alt_vlan_disable = val->value.i != 0;
-
-	return 0;
-}
-
-static int
-rt305x_esw_set_bc_status(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	esw->bc_storm_protect = val->value.i & RT305X_ESW_GSC_BC_STROM_MASK;
-
-	return 0;
-}
-
-static int
-rt305x_esw_get_bc_status(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	val->value.i = esw->bc_storm_protect;
-
-	return 0;
-}
-
-static int
-rt305x_esw_set_led_freq(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	esw->led_frequency = val->value.i & RT305X_ESW_GSC_LED_FREQ_MASK;
-
-	return 0;
-}
-
-static int
-rt305x_esw_get_led_freq(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	val->value.i = esw->led_frequency;
-
-	return 0;
-}
-
-static int esw_get_port_link(struct switch_dev *dev,
-			 int port,
-			 struct switch_port_link *link)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	u32 speed, poa;
-
-	if (port < 0 || port >= RT305X_ESW_NUM_PORTS)
-		return -EINVAL;
-
-	poa = esw_r32(esw, RT305X_ESW_REG_POA) >> port;
-
-	link->link = (poa >> RT305X_ESW_LINK_S) & 1;
-	link->duplex = (poa >> RT305X_ESW_DUPLEX_S) & 1;
-	if (port < RT305X_ESW_NUM_LEDS) {
-		speed = (poa >> RT305X_ESW_SPD_S) & 1;
-	} else {
-		if (port == RT305X_ESW_NUM_PORTS - 1)
-			poa >>= 1;
-		speed = (poa >> RT305X_ESW_SPD_S) & 3;
-	}
-	switch (speed) {
-	case 0:
-		link->speed = SWITCH_PORT_SPEED_10;
-		break;
-	case 1:
-		link->speed = SWITCH_PORT_SPEED_100;
-		break;
-	case 2:
-	case 3: /* forced gige speed can be 2 or 3 */
-		link->speed = SWITCH_PORT_SPEED_1000;
-		break;
-	default:
-		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
-		break;
-	}
-
-	return 0;
-}
-
-static int esw_get_port_bool(struct switch_dev *dev,
-			 const struct switch_attr *attr,
-			 struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int idx = val->port_vlan;
-	u32 x, reg, shift;
-
-	if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS)
-		return -EINVAL;
-
-	switch (attr->id) {
-	case RT305X_ESW_ATTR_PORT_DISABLE:
-		reg = RT305X_ESW_REG_POC0;
-		shift = RT305X_ESW_POC0_DIS_PORT_S;
-		break;
-	case RT305X_ESW_ATTR_PORT_DOUBLETAG:
-		reg = RT305X_ESW_REG_SGC2;
-		shift = RT305X_ESW_SGC2_DOUBLE_TAG_S;
-		break;
-	case RT305X_ESW_ATTR_PORT_UNTAG:
-		reg = RT305X_ESW_REG_POC2;
-		shift = RT305X_ESW_POC2_UNTAG_EN_S;
-		break;
-	case RT305X_ESW_ATTR_PORT_LAN:
-		reg = RT305X_ESW_REG_SGC2;
-		shift = RT305X_ESW_SGC2_LAN_PMAP_S;
-		if (idx >= RT305X_ESW_NUM_LANWAN)
-			return -EINVAL;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	x = esw_r32(esw, reg);
-	val->value.i = (x >> (idx + shift)) & 1;
-
-	return 0;
-}
-
-static int esw_set_port_bool(struct switch_dev *dev,
-			 const struct switch_attr *attr,
-			 struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int idx = val->port_vlan;
-
-	if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS ||
-	    val->value.i < 0 || val->value.i > 1)
-		return -EINVAL;
-
-	switch (attr->id) {
-	case RT305X_ESW_ATTR_PORT_DISABLE:
-		esw->ports[idx].disable = val->value.i;
-		break;
-	case RT305X_ESW_ATTR_PORT_DOUBLETAG:
-		esw->ports[idx].doubletag = val->value.i;
-		break;
-	case RT305X_ESW_ATTR_PORT_UNTAG:
-		esw->ports[idx].untag = val->value.i;
-		break;
-	default:
-		return -EINVAL;
-	}
-
-	return 0;
-}
-
-static int esw_get_port_recv_badgood(struct switch_dev *dev,
-				 const struct switch_attr *attr,
-				 struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int idx = val->port_vlan;
-	int shift = attr->id == RT305X_ESW_ATTR_PORT_RECV_GOOD ? 0 : 16;
-	u32 reg;
-
-	if (idx < 0 || idx >= RT305X_ESW_NUM_LANWAN)
-		return -EINVAL;
-	reg = esw_r32(esw, RT305X_ESW_REG_PXPC(idx));
-	val->value.i = (reg >> shift) & 0xffff;
-
-	return 0;
-}
-
-static int
-esw_get_port_tr_badgood(struct switch_dev *dev,
-				 const struct switch_attr *attr,
-				 struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	int idx = val->port_vlan;
-	int shift = attr->id == RT5350_ESW_ATTR_PORT_TR_GOOD ? 0 : 16;
-	u32 reg;
-
-	if ((ralink_soc != RT305X_SOC_RT5350) && (ralink_soc != MT762X_SOC_MT7628AN) && (ralink_soc != MT762X_SOC_MT7688))
-		return -EINVAL;
-
-	if (idx < 0 || idx >= RT305X_ESW_NUM_LANWAN)
-		return -EINVAL;
-
-	reg = esw_r32(esw, RT5350_ESW_REG_PXTPC(idx));
-	val->value.i = (reg >> shift) & 0xffff;
-
-	return 0;
-}
-
-static int esw_get_port_led(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int idx = val->port_vlan;
-
-	if (idx < 0 || idx >= RT305X_ESW_NUM_PORTS ||
-	    idx >= RT305X_ESW_NUM_LEDS)
-		return -EINVAL;
-
-	val->value.i = esw_r32(esw, RT305X_ESW_REG_P0LED + 4*idx);
-
-	return 0;
-}
-
-static int esw_set_port_led(struct switch_dev *dev,
-			const struct switch_attr *attr,
-			struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int idx = val->port_vlan;
-
-	if (idx < 0 || idx >= RT305X_ESW_NUM_LEDS)
-		return -EINVAL;
-
-	esw->ports[idx].led = val->value.i;
-
-	return 0;
-}
-
-static int esw_get_port_pvid(struct switch_dev *dev, int port, int *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	if (port >= RT305X_ESW_NUM_PORTS)
-		return -EINVAL;
-
-	*val = esw_get_pvid(esw, port);
-
-	return 0;
-}
-
-static int esw_set_port_pvid(struct switch_dev *dev, int port, int val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-
-	if (port >= RT305X_ESW_NUM_PORTS)
-		return -EINVAL;
-
-	esw->ports[port].pvid = val;
-
-	return 0;
-}
-
-static int esw_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	u32 vmsc, poc2;
-	int vlan_idx = -1;
-	int i;
-
-	val->len = 0;
-
-	if (val->port_vlan < 0 || val->port_vlan >= RT305X_ESW_NUM_VIDS)
-		return -EINVAL;
-
-	/* valid vlan? */
-	for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
-		if (esw_get_vlan_id(esw, i) == val->port_vlan &&
-		    esw_get_vmsc(esw, i) != RT305X_ESW_PORTS_NONE) {
-			vlan_idx = i;
-			break;
-		}
-	}
-
-	if (vlan_idx == -1)
-		return -EINVAL;
-
-	vmsc = esw_get_vmsc(esw, vlan_idx);
-	poc2 = esw_r32(esw, RT305X_ESW_REG_POC2);
-
-	for (i = 0; i < RT305X_ESW_NUM_PORTS; i++) {
-		struct switch_port *p;
-		int port_mask = 1 << i;
-
-		if (!(vmsc & port_mask))
-			continue;
-
-		p = &val->value.ports[val->len++];
-		p->id = i;
-		if (poc2 & (port_mask << RT305X_ESW_POC2_UNTAG_EN_S))
-			p->flags = 0;
-		else
-			p->flags = 1 << SWITCH_PORT_FLAG_TAGGED;
-	}
-
-	return 0;
-}
-
-static int esw_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
-{
-	struct rt305x_esw *esw = container_of(dev, struct rt305x_esw, swdev);
-	int ports;
-	int vlan_idx = -1;
-	int i;
-
-	if (val->port_vlan < 0 || val->port_vlan >= RT305X_ESW_NUM_VIDS ||
-	    val->len > RT305X_ESW_NUM_PORTS)
-		return -EINVAL;
-
-	/* one of the already defined vlans? */
-	for (i = 0; i < RT305X_ESW_NUM_VLANS; i++) {
-		if (esw->vlans[i].vid == val->port_vlan &&
-		    esw->vlans[i].ports != RT305X_ESW_PORTS_NONE) {
-			vlan_idx = i;
-			break;
-		}
-	}
-
-	/* select a free slot */
-	for (i = 0; vlan_idx == -1 && i < RT305X_ESW_NUM_VLANS; i++) {
-		if (esw->vlans[i].ports == RT305X_ESW_PORTS_NONE)
-			vlan_idx = i;
-	}
-
-	/* bail if all slots are in use */
-	if (vlan_idx == -1)
-		return -EINVAL;
-
-	ports = RT305X_ESW_PORTS_NONE;
-	for (i = 0; i < val->len; i++) {
-		struct switch_port *p = &val->value.ports[i];
-		int port_mask = 1 << p->id;
-		bool untagged = !(p->flags & (1 << SWITCH_PORT_FLAG_TAGGED));
-
-		if (p->id >= RT305X_ESW_NUM_PORTS)
-			return -EINVAL;
-
-		ports |= port_mask;
-		esw->ports[p->id].untag = untagged;
-	}
-	esw->vlans[vlan_idx].ports = ports;
-	if (ports == RT305X_ESW_PORTS_NONE)
-		esw->vlans[vlan_idx].vid = RT305X_ESW_VLAN_NONE;
-	else
-		esw->vlans[vlan_idx].vid = val->port_vlan;
-
-	return 0;
-}
-
-static const struct switch_attr esw_global[] = {
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "enable_vlan",
-		.description = "VLAN mode (1:enabled)",
-		.max = 1,
-		.id = RT305X_ESW_ATTR_ENABLE_VLAN,
-		.get = esw_get_vlan_enable,
-		.set = esw_set_vlan_enable,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "alternate_vlan_disable",
-		.description = "Use en_vlan instead of doubletag to disable"
-				" VLAN mode",
-		.max = 1,
-		.id = RT305X_ESW_ATTR_ALT_VLAN_DISABLE,
-		.get = esw_get_alt_vlan_disable,
-		.set = esw_set_alt_vlan_disable,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "bc_storm_protect",
-		.description = "Global broadcast storm protection (0:Disable, 1:64 blocks, 2:96 blocks, 3:128 blocks)",
-		.max = 3,
-		.id = RT305X_ESW_ATTR_BC_STATUS,
-		.get = rt305x_esw_get_bc_status,
-		.set = rt305x_esw_set_bc_status,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "led_frequency",
-		.description = "LED Flash frequency (0:30mS, 1:60mS, 2:240mS, 3:480mS)",
-		.max = 3,
-		.id = RT305X_ESW_ATTR_LED_FREQ,
-		.get = rt305x_esw_get_led_freq,
-		.set = rt305x_esw_set_led_freq,
-	}
-};
-
-static const struct switch_attr esw_port[] = {
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "disable",
-		.description = "Port state (1:disabled)",
-		.max = 1,
-		.id = RT305X_ESW_ATTR_PORT_DISABLE,
-		.get = esw_get_port_bool,
-		.set = esw_set_port_bool,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "doubletag",
-		.description = "Double tagging for incoming vlan packets "
-				"(1:enabled)",
-		.max = 1,
-		.id = RT305X_ESW_ATTR_PORT_DOUBLETAG,
-		.get = esw_get_port_bool,
-		.set = esw_set_port_bool,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "untag",
-		.description = "Untag (1:strip outgoing vlan tag)",
-		.max = 1,
-		.id = RT305X_ESW_ATTR_PORT_UNTAG,
-		.get = esw_get_port_bool,
-		.set = esw_set_port_bool,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "led",
-		.description = "LED mode (0:link, 1:100m, 2:duplex, 3:activity,"
-				" 4:collision, 5:linkact, 6:duplcoll, 7:10mact,"
-				" 8:100mact, 10:blink, 11:off, 12:on)",
-		.max = 15,
-		.id = RT305X_ESW_ATTR_PORT_LED,
-		.get = esw_get_port_led,
-		.set = esw_set_port_led,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "lan",
-		.description = "HW port group (0:wan, 1:lan)",
-		.max = 1,
-		.id = RT305X_ESW_ATTR_PORT_LAN,
-		.get = esw_get_port_bool,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "recv_bad",
-		.description = "Receive bad packet counter",
-		.id = RT305X_ESW_ATTR_PORT_RECV_BAD,
-		.get = esw_get_port_recv_badgood,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "recv_good",
-		.description = "Receive good packet counter",
-		.id = RT305X_ESW_ATTR_PORT_RECV_GOOD,
-		.get = esw_get_port_recv_badgood,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "tr_bad",
-
-		.description = "Transmit bad packet counter. rt5350 only",
-		.id = RT5350_ESW_ATTR_PORT_TR_BAD,
-		.get = esw_get_port_tr_badgood,
-	},
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "tr_good",
-
-		.description = "Transmit good packet counter. rt5350 only",
-		.id = RT5350_ESW_ATTR_PORT_TR_GOOD,
-		.get = esw_get_port_tr_badgood,
-	},
-};
-
-static const struct switch_attr esw_vlan[] = {
-};
-
-static const struct switch_dev_ops esw_ops = {
-	.attr_global = {
-		.attr = esw_global,
-		.n_attr = ARRAY_SIZE(esw_global),
-	},
-	.attr_port = {
-		.attr = esw_port,
-		.n_attr = ARRAY_SIZE(esw_port),
-	},
-	.attr_vlan = {
-		.attr = esw_vlan,
-		.n_attr = ARRAY_SIZE(esw_vlan),
-	},
-	.get_vlan_ports = esw_get_vlan_ports,
-	.set_vlan_ports = esw_set_vlan_ports,
-	.get_port_pvid = esw_get_port_pvid,
-	.set_port_pvid = esw_set_port_pvid,
-	.get_port_link = esw_get_port_link,
-	.apply_config = esw_apply_config,
-	.reset_switch = esw_reset_switch,
-};
-
-static int esw_probe(struct platform_device *pdev)
-{
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	struct device_node *np = pdev->dev.of_node;
-	const __be32 *port_map, *port_disable, *reg_init;
-	struct switch_dev *swdev;
-	struct rt305x_esw *esw;
-	int ret;
-
-	esw = devm_kzalloc(&pdev->dev, sizeof(*esw), GFP_KERNEL);
-	if (!esw)
-		return -ENOMEM;
-
-	esw->dev = &pdev->dev;
-	esw->irq = irq_of_parse_and_map(np, 0);
-	esw->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(esw->base))
-		return PTR_ERR(esw->base);
-
-	port_map = of_get_property(np, "mediatek,portmap", NULL);
-	if (port_map)
-		esw->port_map = be32_to_cpu(*port_map);
-
-	port_disable = of_get_property(np, "mediatek,portdisable", NULL);
-	if (port_disable)
-		esw->port_disable = be32_to_cpu(*port_disable);
-
-	reg_init = of_get_property(np, "ralink,fct2", NULL);
-	if (reg_init)
-		esw->reg_initval_fct2 = be32_to_cpu(*reg_init);
-
-	reg_init = of_get_property(np, "ralink,fpa2", NULL);
-	if (reg_init)
-		esw->reg_initval_fpa2 = be32_to_cpu(*reg_init);
-
-	reg_init = of_get_property(np, "mediatek,led_polarity", NULL);
-	if (reg_init)
-		esw->reg_led_polarity = be32_to_cpu(*reg_init);
-
-	swdev = &esw->swdev;
-	swdev->of_node = pdev->dev.of_node;
-	swdev->name = "rt305x-esw";
-	swdev->alias = "rt305x";
-	swdev->cpu_port = RT305X_ESW_PORT6;
-	swdev->ports = RT305X_ESW_NUM_PORTS;
-	swdev->vlans = RT305X_ESW_NUM_VIDS;
-	swdev->ops = &esw_ops;
-
-	ret = register_switch(swdev, NULL);
-	if (ret < 0) {
-		dev_err(&pdev->dev, "register_switch failed\n");
-		return ret;
-	}
-
-	platform_set_drvdata(pdev, esw);
-
-	spin_lock_init(&esw->reg_rw_lock);
-
-	esw_hw_init(esw);
-
-	reg_init = of_get_property(np, "ralink,rgmii", NULL);
-	if (reg_init && be32_to_cpu(*reg_init) == 1) {
-		/* 
-		 * External switch connected to RGMII interface. 
-		 * Unregister the switch device after initialization. 
-		 */
-		dev_err(&pdev->dev, "RGMII mode, not exporting switch device.\n");
-		unregister_switch(&esw->swdev);
-		platform_set_drvdata(pdev, NULL);
-		return -ENODEV;
-	}
-
-	ret = devm_request_irq(&pdev->dev, esw->irq, esw_interrupt, 0, "esw",
-			       esw);
-
-	if (!ret) {
-		esw_w32(esw, RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_ISR);
-		esw_w32(esw, ~RT305X_ESW_PORT_ST_CHG, RT305X_ESW_REG_IMR);
-	}
-
-	return ret;
-}
-
-static int esw_remove(struct platform_device *pdev)
-{
-	struct rt305x_esw *esw = platform_get_drvdata(pdev);
-
-	if (esw) {
-		esw_w32(esw, ~0, RT305X_ESW_REG_IMR);
-		platform_set_drvdata(pdev, NULL);
-	}
-
-	return 0;
-}
-
-static const struct of_device_id ralink_esw_match[] = {
-	{ .compatible = "ralink,rt3050-esw" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, ralink_esw_match);
-
-static struct platform_driver esw_driver = {
-	.probe = esw_probe,
-	.remove = esw_remove,
-	.driver = {
-		.name = "rt3050-esw",
-		.owner = THIS_MODULE,
-		.of_match_table = ralink_esw_match,
-	},
-};
-
-module_platform_driver(esw_driver);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
-MODULE_DESCRIPTION("Switch driver for RT305X SoC");
-MODULE_VERSION(MTK_FE_DRV_VERSION);
diff --git a/drivers/net/ethernet/mediatek/esw_rt3050.h b/drivers/net/ethernet/mediatek/esw_rt3050.h
deleted file mode 100644
index b757e5d63946..000000000000
--- a/drivers/net/ethernet/mediatek/esw_rt3050.h
+++ /dev/null
@@ -1,29 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#ifndef _RALINK_ESW_RT3052_H__
-#define _RALINK_ESW_RT3052_H__
-
-#ifdef CONFIG_NET_MEDIATEK_ESW_RT3052
-
-int __init mtk_switch_init(void);
-void mtk_switch_exit(void);
-
-#else
-
-static inline int __init mtk_switch_init(void) { return 0; }
-static inline void mtk_switch_exit(void) { }
-
-#endif
-#endif
diff --git a/drivers/net/ethernet/mediatek/ethtool.c b/drivers/net/ethernet/mediatek/ethtool.c
deleted file mode 100644
index 5732c28536c2..000000000000
--- a/drivers/net/ethernet/mediatek/ethtool.c
+++ /dev/null
@@ -1,230 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include "mtk_eth_soc.h"
-
-static const char fe_gdma_str[][ETH_GSTRING_LEN] = {
-#define _FE(x...)	# x,
-FE_STAT_REG_DECLARE
-#undef _FE
-};
-
-static int fe_get_link_ksettings(struct net_device *ndev,
-			   struct ethtool_link_ksettings *cmd)
-{
-	struct fe_priv *priv = netdev_priv(ndev);
-
-	if (!priv->phy_dev)
-		return -ENODEV;
-
-	if (priv->phy_flags == FE_PHY_FLAG_ATTACH) {
-		if (phy_read_status(priv->phy_dev))
-			return -ENODEV;
-	}
-
-	phy_ethtool_ksettings_get(ndev->phydev, cmd);
-
-	return 0;
-}
-
-static int fe_set_link_ksettings(struct net_device *ndev,
-			   const struct ethtool_link_ksettings *cmd)
-{
-	struct fe_priv *priv = netdev_priv(ndev);
-
-	if (!priv->phy_dev)
-		goto out_sset;
-
-	if (cmd->base.phy_address != priv->phy_dev->mdio.addr) {
-		if (priv->phy->phy_node[cmd->base.phy_address]) {
-			priv->phy_dev = priv->phy->phy[cmd->base.phy_address];
-			priv->phy_flags = FE_PHY_FLAG_PORT;
-		} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, cmd->base.phy_address)) {
-			priv->phy_dev = mdiobus_get_phy(priv->mii_bus, cmd->base.phy_address);
-			priv->phy_flags = FE_PHY_FLAG_ATTACH;
-		} else {
-			goto out_sset;
-		}
-	}
-
-	return phy_ethtool_ksettings_set(ndev->phydev, cmd);
-
-out_sset:
-	return -ENODEV;
-}
-
-static void fe_get_drvinfo(struct net_device *dev,
-			   struct ethtool_drvinfo *info)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	struct fe_soc_data *soc = priv->soc;
-
-	strlcpy(info->driver, priv->dev->driver->name, sizeof(info->driver));
-	strlcpy(info->version, MTK_FE_DRV_VERSION, sizeof(info->version));
-	strlcpy(info->bus_info, dev_name(priv->dev), sizeof(info->bus_info));
-
-	if (soc->reg_table[FE_REG_FE_COUNTER_BASE])
-		info->n_stats = ARRAY_SIZE(fe_gdma_str);
-}
-
-static u32 fe_get_msglevel(struct net_device *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-
-	return priv->msg_enable;
-}
-
-static void fe_set_msglevel(struct net_device *dev, u32 value)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-
-	priv->msg_enable = value;
-}
-
-static int fe_nway_reset(struct net_device *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-
-	if (!priv->phy_dev)
-		goto out_nway_reset;
-
-	return genphy_restart_aneg(priv->phy_dev);
-
-out_nway_reset:
-	return -EOPNOTSUPP;
-}
-
-static u32 fe_get_link(struct net_device *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	int err;
-
-	if (!priv->phy_dev)
-		goto out_get_link;
-
-	if (priv->phy_flags == FE_PHY_FLAG_ATTACH) {
-		err = genphy_update_link(priv->phy_dev);
-		if (err)
-			goto out_get_link;
-	}
-
-	return priv->phy_dev->link;
-
-out_get_link:
-	return ethtool_op_get_link(dev);
-}
-
-static int fe_set_ringparam(struct net_device *dev,
-			    struct ethtool_ringparam *ring)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-
-	if ((ring->tx_pending < 2) ||
-	    (ring->rx_pending < 2) ||
-	    (ring->rx_pending > MAX_DMA_DESC) ||
-	    (ring->tx_pending > MAX_DMA_DESC))
-		return -EINVAL;
-
-	dev->netdev_ops->ndo_stop(dev);
-
-	priv->tx_ring.tx_ring_size = BIT(fls(ring->tx_pending) - 1);
-	priv->rx_ring.rx_ring_size = BIT(fls(ring->rx_pending) - 1);
-
-	dev->netdev_ops->ndo_open(dev);
-
-	return 0;
-}
-
-static void fe_get_ringparam(struct net_device *dev,
-			     struct ethtool_ringparam *ring)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-
-	ring->rx_max_pending = MAX_DMA_DESC;
-	ring->tx_max_pending = MAX_DMA_DESC;
-	ring->rx_pending = priv->rx_ring.rx_ring_size;
-	ring->tx_pending = priv->tx_ring.tx_ring_size;
-}
-
-static void fe_get_strings(struct net_device *dev, u32 stringset, u8 *data)
-{
-	switch (stringset) {
-	case ETH_SS_STATS:
-		memcpy(data, *fe_gdma_str, sizeof(fe_gdma_str));
-		break;
-	}
-}
-
-static int fe_get_sset_count(struct net_device *dev, int sset)
-{
-	switch (sset) {
-	case ETH_SS_STATS:
-		return ARRAY_SIZE(fe_gdma_str);
-	default:
-		return -EOPNOTSUPP;
-	}
-}
-
-static void fe_get_ethtool_stats(struct net_device *dev,
-				 struct ethtool_stats *stats, u64 *data)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	struct fe_hw_stats *hwstats = priv->hw_stats;
-	u64 *data_src, *data_dst;
-	unsigned int start;
-	int i;
-
-	if (netif_running(dev) && netif_device_present(dev)) {
-		if (spin_trylock(&hwstats->stats_lock)) {
-			fe_stats_update(priv);
-			spin_unlock(&hwstats->stats_lock);
-		}
-	}
-
-	do {
-		data_src = &hwstats->tx_bytes;
-		data_dst = data;
-		start = u64_stats_fetch_begin_irq(&hwstats->syncp);
-
-		for (i = 0; i < ARRAY_SIZE(fe_gdma_str); i++)
-			*data_dst++ = *data_src++;
-
-	} while (u64_stats_fetch_retry_irq(&hwstats->syncp, start));
-}
-
-static struct ethtool_ops fe_ethtool_ops = {
-	.get_link_ksettings	= fe_get_link_ksettings,
-	.set_link_ksettings	= fe_set_link_ksettings,
-	.get_drvinfo		= fe_get_drvinfo,
-	.get_msglevel		= fe_get_msglevel,
-	.set_msglevel		= fe_set_msglevel,
-	.nway_reset		= fe_nway_reset,
-	.get_link		= fe_get_link,
-	.set_ringparam		= fe_set_ringparam,
-	.get_ringparam		= fe_get_ringparam,
-};
-
-void fe_set_ethtool_ops(struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-	struct fe_soc_data *soc = priv->soc;
-
-	if (soc->reg_table[FE_REG_FE_COUNTER_BASE]) {
-		fe_ethtool_ops.get_strings = fe_get_strings;
-		fe_ethtool_ops.get_sset_count = fe_get_sset_count;
-		fe_ethtool_ops.get_ethtool_stats = fe_get_ethtool_stats;
-	}
-
-	netdev->ethtool_ops = &fe_ethtool_ops;
-}
diff --git a/drivers/net/ethernet/mediatek/ethtool.h b/drivers/net/ethernet/mediatek/ethtool.h
deleted file mode 100644
index 6fd16f0b663f..000000000000
--- a/drivers/net/ethernet/mediatek/ethtool.h
+++ /dev/null
@@ -1,22 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#ifndef FE_ETHTOOL_H
-#define FE_ETHTOOL_H
-
-#include <linux/ethtool.h>
-
-void fe_set_ethtool_ops(struct net_device *netdev);
-
-#endif /* FE_ETHTOOL_H */
diff --git a/drivers/net/ethernet/mediatek/gsw_mt7620.c b/drivers/net/ethernet/mediatek/gsw_mt7620.c
deleted file mode 100644
index a4602c45868f..000000000000
--- a/drivers/net/ethernet/mediatek/gsw_mt7620.c
+++ /dev/null
@@ -1,260 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/of_device.h>
-#include <linux/of_irq.h>
-
-#include <ralink_regs.h>
-
-#include "mtk_eth_soc.h"
-#include "gsw_mt7620.h"
-
-void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg)
-{
-	iowrite32(val, gsw->base + reg);
-}
-
-u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg)
-{
-	return ioread32(gsw->base + reg);
-}
-
-static irqreturn_t gsw_interrupt_mt7620(int irq, void *_priv)
-{
-	struct fe_priv *priv = (struct fe_priv *)_priv;
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-	u32 status;
-	int i, max = (gsw->port4 == PORT4_EPHY) ? (4) : (3);
-
-	status = mtk_switch_r32(gsw, GSW_REG_ISR);
-	if (status & PORT_IRQ_ST_CHG)
-		for (i = 0; i <= max; i++) {
-			u32 status = mtk_switch_r32(gsw, GSW_REG_PORT_STATUS(i));
-			int link = status & 0x1;
-
-			if (link != priv->link[i])
-				mt7620_print_link_state(priv, i, link,
-							(status >> 2) & 3,
-							(status & 0x2));
-
-			priv->link[i] = link;
-		}
-	mt7620_handle_carrier(priv);
-	mtk_switch_w32(gsw, status, GSW_REG_ISR);
-
-	return IRQ_HANDLED;
-}
-
-static void mt7620_hw_init(struct mt7620_gsw *gsw, struct device_node *np)
-{
-	u32 is_BGA = (rt_sysc_r32(0x0c) >> 16) & 1;
-
-	rt_sysc_w32(rt_sysc_r32(SYSC_REG_CFG1) | BIT(8), SYSC_REG_CFG1);
-	mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_CKGCR) & ~(0x3 << 4), GSW_REG_CKGCR);
-
-	/* Enable MIB stats */
-	mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_MIB_CNT_EN) | (1 << 1), GSW_REG_MIB_CNT_EN);
-
-	if (of_property_read_bool(np, "mediatek,mt7530")) {
-		u32 val;
-
-		/* turn off ephy and set phy base addr to 12 */
-		mtk_switch_w32(gsw, mtk_switch_r32(gsw, GSW_REG_GPC1) |
-			(0x1f << 24) | (0xc << 16),
-			GSW_REG_GPC1);
-
-		/* set MT7530 central align */
-		val = mt7530_mdio_r32(gsw, 0x7830);
-		val &= ~BIT(0);
-		val |= BIT(1);
-		mt7530_mdio_w32(gsw, 0x7830, val);
-
-		val = mt7530_mdio_r32(gsw, 0x7a40);
-		val &= ~BIT(30);
-		mt7530_mdio_w32(gsw, 0x7a40, val);
-
-		mt7530_mdio_w32(gsw, 0x7a78, 0x855);
-	} else {
-		/* global page 4 */
-		_mt7620_mii_write(gsw, 1, 31, 0x4000);
-
-		_mt7620_mii_write(gsw, 1, 17, 0x7444);
-		if (is_BGA)
-			_mt7620_mii_write(gsw, 1, 19, 0x0114);
-		else
-			_mt7620_mii_write(gsw, 1, 19, 0x0117);
-
-		_mt7620_mii_write(gsw, 1, 22, 0x10cf);
-		_mt7620_mii_write(gsw, 1, 25, 0x6212);
-		_mt7620_mii_write(gsw, 1, 26, 0x0777);
-		_mt7620_mii_write(gsw, 1, 29, 0x4000);
-		_mt7620_mii_write(gsw, 1, 28, 0xc077);
-		_mt7620_mii_write(gsw, 1, 24, 0x0000);
-
-		/* global page 3 */
-		_mt7620_mii_write(gsw, 1, 31, 0x3000);
-		_mt7620_mii_write(gsw, 1, 17, 0x4838);
-
-		/* global page 2 */
-		_mt7620_mii_write(gsw, 1, 31, 0x2000);
-		if (is_BGA) {
-			_mt7620_mii_write(gsw, 1, 21, 0x0515);
-			_mt7620_mii_write(gsw, 1, 22, 0x0053);
-			_mt7620_mii_write(gsw, 1, 23, 0x00bf);
-			_mt7620_mii_write(gsw, 1, 24, 0x0aaf);
-			_mt7620_mii_write(gsw, 1, 25, 0x0fad);
-			_mt7620_mii_write(gsw, 1, 26, 0x0fc1);
-		} else {
-			_mt7620_mii_write(gsw, 1, 21, 0x0517);
-			_mt7620_mii_write(gsw, 1, 22, 0x0fd2);
-			_mt7620_mii_write(gsw, 1, 23, 0x00bf);
-			_mt7620_mii_write(gsw, 1, 24, 0x0aab);
-			_mt7620_mii_write(gsw, 1, 25, 0x00ae);
-			_mt7620_mii_write(gsw, 1, 26, 0x0fff);
-		}
-		/* global page 1 */
-		_mt7620_mii_write(gsw, 1, 31, 0x1000);
-		_mt7620_mii_write(gsw, 1, 17, 0xe7f8);
-	}
-
-	/* global page 0 */
-	_mt7620_mii_write(gsw, 1, 31, 0x8000);
-	_mt7620_mii_write(gsw, 0, 30, 0xa000);
-	_mt7620_mii_write(gsw, 1, 30, 0xa000);
-	_mt7620_mii_write(gsw, 2, 30, 0xa000);
-	_mt7620_mii_write(gsw, 3, 30, 0xa000);
-
-	_mt7620_mii_write(gsw, 0, 4, 0x05e1);
-	_mt7620_mii_write(gsw, 1, 4, 0x05e1);
-	_mt7620_mii_write(gsw, 2, 4, 0x05e1);
-	_mt7620_mii_write(gsw, 3, 4, 0x05e1);
-
-	/* global page 2 */
-	_mt7620_mii_write(gsw, 1, 31, 0xa000);
-	_mt7620_mii_write(gsw, 0, 16, 0x1111);
-	_mt7620_mii_write(gsw, 1, 16, 0x1010);
-	_mt7620_mii_write(gsw, 2, 16, 0x1515);
-	_mt7620_mii_write(gsw, 3, 16, 0x0f0f);
-
-	/* CPU Port6 Force Link 1G, FC ON */
-	mtk_switch_w32(gsw, 0x5e33b, GSW_REG_PORT_PMCR(6));
-
-	/* Set Port 6 as CPU Port */
-	mtk_switch_w32(gsw, 0x7f7f7fe0, 0x0010);
-
-	/* setup port 4 */
-	if (gsw->port4 == PORT4_EPHY) {
-		u32 val = rt_sysc_r32(SYSC_REG_CFG1);
-
-		val |= 3 << 14;
-		rt_sysc_w32(val, SYSC_REG_CFG1);
-		_mt7620_mii_write(gsw, 4, 30, 0xa000);
-		_mt7620_mii_write(gsw, 4, 4, 0x05e1);
-		_mt7620_mii_write(gsw, 4, 16, 0x1313);
-		_mt7620_mii_write(gsw, 4, 0, 0x3100);
-		pr_info("gsw: setting port4 to ephy mode\n");
-	}
-}
-
-static const struct of_device_id mediatek_gsw_match[] = {
-	{ .compatible = "mediatek,mt7620-gsw" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, mediatek_gsw_match);
-
-int mtk_gsw_init(struct fe_priv *priv)
-{
-	struct device_node *np = priv->switch_np;
-	struct platform_device *pdev = of_find_device_by_node(np);
-	struct mt7620_gsw *gsw;
-
-	if (!pdev)
-		return -ENODEV;
-
-	if (!of_device_is_compatible(np, mediatek_gsw_match->compatible))
-		return -EINVAL;
-
-	gsw = platform_get_drvdata(pdev);
-	priv->soc->swpriv = gsw;
-
-	mt7620_hw_init(gsw, np);
-
-	if (gsw->irq) {
-		request_irq(gsw->irq, gsw_interrupt_mt7620, 0,
-			    "gsw", priv);
-		mtk_switch_w32(gsw, ~PORT_IRQ_ST_CHG, GSW_REG_IMR);
-	}
-
-	return 0;
-}
-
-static int mt7620_gsw_probe(struct platform_device *pdev)
-{
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	const char *port4 = NULL;
-	struct mt7620_gsw *gsw;
-	struct device_node *np = pdev->dev.of_node;
-
-	gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
-	if (!gsw)
-		return -ENOMEM;
-
-	gsw->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(gsw->base))
-		return PTR_ERR(gsw->base);
-
-	gsw->dev = &pdev->dev;
-
-	of_property_read_string(np, "mediatek,port4", &port4);
-	if (port4 && !strcmp(port4, "ephy"))
-		gsw->port4 = PORT4_EPHY;
-	else if (port4 && !strcmp(port4, "gmac"))
-		gsw->port4 = PORT4_EXT;
-	else
-		gsw->port4 = PORT4_EPHY;
-
-	gsw->irq = platform_get_irq(pdev, 0);
-
-	platform_set_drvdata(pdev, gsw);
-
-	return 0;
-}
-
-static int mt7620_gsw_remove(struct platform_device *pdev)
-{
-	platform_set_drvdata(pdev, NULL);
-
-	return 0;
-}
-
-static struct platform_driver gsw_driver = {
-	.probe = mt7620_gsw_probe,
-	.remove = mt7620_gsw_remove,
-	.driver = {
-		.name = "mt7620-gsw",
-		.owner = THIS_MODULE,
-		.of_match_table = mediatek_gsw_match,
-	},
-};
-
-module_platform_driver(gsw_driver);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
-MODULE_DESCRIPTION("GBit switch driver for Mediatek MT7620 SoC");
-MODULE_VERSION(MTK_FE_DRV_VERSION);
diff --git a/drivers/net/ethernet/mediatek/gsw_mt7620.h b/drivers/net/ethernet/mediatek/gsw_mt7620.h
deleted file mode 100644
index ae0b6de02416..000000000000
--- a/drivers/net/ethernet/mediatek/gsw_mt7620.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#ifndef _RALINK_GSW_MT7620_H__
-#define _RALINK_GSW_MT7620_H__
-
-#define GSW_REG_PHY_TIMEOUT	(5 * HZ)
-
-#ifdef CONFIG_SOC_MT7621
-#define MT7620A_GSW_REG_PIAC	0x0004
-#else
-#define MT7620A_GSW_REG_PIAC	0x7004
-#endif
-
-#define GSW_NUM_VLANS		16
-#define GSW_NUM_VIDS		4096
-#define GSW_NUM_PORTS		7
-#define GSW_PORT6		6
-
-#define GSW_MDIO_ACCESS		BIT(31)
-#define GSW_MDIO_READ		BIT(19)
-#define GSW_MDIO_WRITE		BIT(18)
-#define GSW_MDIO_START		BIT(16)
-#define GSW_MDIO_ADDR_SHIFT	20
-#define GSW_MDIO_REG_SHIFT	25
-
-#define GSW_REG_MIB_CNT_EN	0x4000
-
-#define GSW_REG_PORT_PMCR(x)	(0x3000 + (x * 0x100))
-#define GSW_REG_PORT_STATUS(x)	(0x3008 + (x * 0x100))
-#define GSW_REG_SMACCR0		0x3fE4
-#define GSW_REG_SMACCR1		0x3fE8
-#define GSW_REG_CKGCR		0x3ff0
-
-#define GSW_REG_IMR		0x7008
-#define GSW_REG_ISR		0x700c
-#define GSW_REG_GPC1		0x7014
-
-#define GSW_REG_MAC_P0_MCR	0x100
-#define GSW_REG_MAC_P1_MCR	0x200
-
-// Global MAC control register
-#define GSW_REG_GMACCR		0x30E0
-
-#define SYSC_REG_CHIP_REV_ID	0x0c
-#define SYSC_REG_CFG1		0x14
-#define RST_CTRL_MCM		BIT(2)
-#define SYSC_PAD_RGMII2_MDIO	0x58
-#define SYSC_GPIO_MODE		0x60
-
-#define PORT_IRQ_ST_CHG		0x7f
-
-#ifdef CONFIG_SOC_MT7621
-#define ESW_PHY_POLLING		0x0000
-#else
-#define ESW_PHY_POLLING		0x7000
-#endif
-
-#define	PMCR_IPG		BIT(18)
-#define	PMCR_MAC_MODE		BIT(16)
-#define	PMCR_FORCE		BIT(15)
-#define	PMCR_TX_EN		BIT(14)
-#define	PMCR_RX_EN		BIT(13)
-#define	PMCR_BACKOFF		BIT(9)
-#define	PMCR_BACKPRES		BIT(8)
-#define	PMCR_RX_FC		BIT(5)
-#define	PMCR_TX_FC		BIT(4)
-#define	PMCR_SPEED(_x)		(_x << 2)
-#define	PMCR_DUPLEX		BIT(1)
-#define	PMCR_LINK		BIT(0)
-
-#define PHY_AN_EN		BIT(31)
-#define PHY_PRE_EN		BIT(30)
-#define PMY_MDC_CONF(_x)	((_x & 0x3f) << 24)
-
-
-enum {
-	/* Global attributes. */
-	GSW_ATTR_ENABLE_VLAN,
-	/* Port attributes. */
-	GSW_ATTR_PORT_UNTAG,
-};
-
-enum {
-	PORT4_EPHY = 0,
-	PORT4_EXT,
-};
-
-struct mt7620_gsw {
-	struct device		*dev;
-	void __iomem		*base;
-	int			irq;
-	int			port4;
-	unsigned long int	autopoll;
-};
-
-void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg);
-u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg);
-int mtk_gsw_init(struct fe_priv *priv);
-
-int mt7620_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val);
-int mt7620_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg);
-void mt7620_mdio_link_adjust(struct fe_priv *priv, int port);
-int mt7620_has_carrier(struct fe_priv *priv);
-void mt7620_print_link_state(struct fe_priv *priv, int port, int link,
-			     int speed, int duplex);
-
-void mt7530_mdio_w32(struct mt7620_gsw *gsw, u32 reg, u32 val);
-u32 mt7530_mdio_r32(struct mt7620_gsw *gsw, u32 reg);
-
-u32 _mt7620_mii_write(struct mt7620_gsw *gsw, u32 phy_addr,
-			     u32 phy_register, u32 write_data);
-u32 _mt7620_mii_read(struct mt7620_gsw *gsw, int phy_addr, int phy_reg);
-void mt7620_handle_carrier(struct fe_priv *priv);
-
-#endif
diff --git a/drivers/net/ethernet/mediatek/gsw_mt7621.c b/drivers/net/ethernet/mediatek/gsw_mt7621.c
deleted file mode 100644
index 89be23900738..000000000000
--- a/drivers/net/ethernet/mediatek/gsw_mt7621.c
+++ /dev/null
@@ -1,281 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/platform_device.h>
-#include <linux/of_device.h>
-#include <linux/of_irq.h>
-
-#include <ralink_regs.h>
-
-#include "mtk_eth_soc.h"
-#include "gsw_mt7620.h"
-
-void mtk_switch_w32(struct mt7620_gsw *gsw, u32 val, unsigned reg)
-{
-	iowrite32(val, gsw->base + reg);
-}
-
-u32 mtk_switch_r32(struct mt7620_gsw *gsw, unsigned reg)
-{
-	return ioread32(gsw->base + reg);
-}
-
-static irqreturn_t gsw_interrupt_mt7621(int irq, void *_priv)
-{
-	struct fe_priv *priv = (struct fe_priv *)_priv;
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-	u32 reg, i;
-
-	reg = mt7530_mdio_r32(gsw, 0x700c);
-	mt7530_mdio_w32(gsw, 0x700c, reg);
-
-	for (i = 0; i < 5; i++)
-		if (reg & BIT(i)) {
-			unsigned int link;
-
-			link = mt7530_mdio_r32(gsw,
-					       0x3008 + (i * 0x100)) & 0x1;
-
-			if (link != priv->link[i]) {
-				priv->link[i] = link;
-				if (link)
-					netdev_info(priv->netdev,
-						    "port %d link up\n", i);
-				else
-					netdev_info(priv->netdev,
-						    "port %d link down\n", i);
-			}
-		}
-
-	mt7620_handle_carrier(priv);
-
-	return IRQ_HANDLED;
-}
-
-static void mt7621_hw_init(struct mt7620_gsw *gsw, struct device_node *np)
-{
-	u32 i;
-	u32 val;
-
-	/* wardware reset the switch */
-	fe_reset(RST_CTRL_MCM);
-	mdelay(10);
-
-	/* reduce RGMII2 PAD driving strength */
-	rt_sysc_m32(3 << 4, 0, SYSC_PAD_RGMII2_MDIO);
-
-	/* gpio mux - RGMII1=Normal mode */
-	rt_sysc_m32(BIT(14), 0, SYSC_GPIO_MODE);
-
-	/* set GMAC1 RGMII mode */
-	rt_sysc_m32(3 << 12, 0, SYSC_REG_CFG1);
-
-	/* enable MDIO to control MT7530 */
-	rt_sysc_m32(3 << 12, 0, SYSC_GPIO_MODE);
-
-	/* turn off all PHYs */
-	for (i = 0; i <= 4; i++) {
-		val = _mt7620_mii_read(gsw, i, 0x0);
-		val |= BIT(11);
-		_mt7620_mii_write(gsw, i, 0x0, val);
-	}
-
-	/* reset the switch */
-	mt7530_mdio_w32(gsw, 0x7000, 0x3);
-	usleep_range(10, 20);
-
-	if ((rt_sysc_r32(SYSC_REG_CHIP_REV_ID) & 0xFFFF) == 0x0101) {
-		/* (GE1, Force 1000M/FD, FC ON, MAX_RX_LENGTH 1536) */
-		mtk_switch_w32(gsw, 0x2305e30b, GSW_REG_MAC_P0_MCR);
-		mt7530_mdio_w32(gsw, 0x3600, 0x5e30b);
-	} else {
-		/* (GE1, Force 1000M/FD, FC ON, MAX_RX_LENGTH 1536) */
-		mtk_switch_w32(gsw, 0x2305e33b, GSW_REG_MAC_P0_MCR);
-		mt7530_mdio_w32(gsw, 0x3600, 0x5e33b);
-	}
-
-	/* (GE2, Link down) */
-	mtk_switch_w32(gsw, 0x8000, GSW_REG_MAC_P1_MCR);
-
-	/* Set switch max RX frame length to 2k */
-	mt7530_mdio_w32(gsw, GSW_REG_GMACCR, 0x3F0B);
-
-	/* Enable Port 6, P5 as GMAC5, P5 disable */
-	val = mt7530_mdio_r32(gsw, 0x7804);
-	val &= ~BIT(8);
-	val |= BIT(6) | BIT(13) | BIT(16);
-	mt7530_mdio_w32(gsw, 0x7804, val);
-
-	val = rt_sysc_r32(0x10);
-	val = (val >> 6) & 0x7;
-	if (val >= 6) {
-		/* 25Mhz Xtal - do nothing */
-	} else if (val >= 3) {
-		/* 40Mhz */
-
-		/* disable MT7530 core clock */
-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
-		_mt7620_mii_write(gsw, 0, 14, 0x410);
-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
-		_mt7620_mii_write(gsw, 0, 14, 0x0);
-
-		/* disable MT7530 PLL */
-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
-		_mt7620_mii_write(gsw, 0, 14, 0x40d);
-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
-		_mt7620_mii_write(gsw, 0, 14, 0x2020);
-
-		/* for MT7530 core clock = 500Mhz */
-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
-		_mt7620_mii_write(gsw, 0, 14, 0x40e);
-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
-		_mt7620_mii_write(gsw, 0, 14, 0x119);
-
-		/* enable MT7530 PLL */
-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
-		_mt7620_mii_write(gsw, 0, 14, 0x40d);
-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
-		_mt7620_mii_write(gsw, 0, 14, 0x2820);
-
-		usleep_range(20, 40);
-
-		/* enable MT7530 core clock */
-		_mt7620_mii_write(gsw, 0, 13, 0x1f);
-		_mt7620_mii_write(gsw, 0, 14, 0x410);
-		_mt7620_mii_write(gsw, 0, 13, 0x401f);
-	} else {
-		/* 20Mhz Xtal - TODO */
-	}
-
-	/* RGMII */
-	_mt7620_mii_write(gsw, 0, 14, 0x1);
-
-	/* set MT7530 central align */
-	val = mt7530_mdio_r32(gsw, 0x7830);
-	val &= ~BIT(0);
-	val |= BIT(1);
-	mt7530_mdio_w32(gsw, 0x7830, val);
-	val = mt7530_mdio_r32(gsw, 0x7a40);
-	val &= ~BIT(30);
-	mt7530_mdio_w32(gsw, 0x7a40, val);
-	mt7530_mdio_w32(gsw, 0x7a78, 0x855);
-
-	/* delay setting for 10/1000M */
-	mt7530_mdio_w32(gsw, 0x7b00, 0x102);
-	mt7530_mdio_w32(gsw, 0x7b04, 0x14);
-
-	/* lower Tx Driving*/
-	mt7530_mdio_w32(gsw, 0x7a54, 0x44);
-	mt7530_mdio_w32(gsw, 0x7a5c, 0x44);
-	mt7530_mdio_w32(gsw, 0x7a64, 0x44);
-	mt7530_mdio_w32(gsw, 0x7a6c, 0x44);
-	mt7530_mdio_w32(gsw, 0x7a74, 0x44);
-	mt7530_mdio_w32(gsw, 0x7a7c, 0x44);
-
-	/* turn on all PHYs */
-	for (i = 0; i <= 4; i++) {
-		val = _mt7620_mii_read(gsw, i, 0);
-		val &= ~BIT(11);
-		_mt7620_mii_write(gsw, i, 0, val);
-	}
-
-	/* enable irq */
-	mt7530_mdio_w32(gsw, 0x7008, 0x1f);
-	val = mt7530_mdio_r32(gsw, 0x7808);
-	val |= 3 << 16;
-	mt7530_mdio_w32(gsw, 0x7808, val);
-}
-
-static const struct of_device_id mediatek_gsw_match[] = {
-	{ .compatible = "mediatek,mt7621-gsw" },
-	{},
-};
-MODULE_DEVICE_TABLE(of, mediatek_gsw_match);
-
-int mtk_gsw_init(struct fe_priv *priv)
-{
-	struct device_node *np = priv->switch_np;
-	struct platform_device *pdev = of_find_device_by_node(np);
-	struct mt7620_gsw *gsw;
-
-	if (!pdev)
-		return -ENODEV;
-
-	if (!of_device_is_compatible(np, mediatek_gsw_match->compatible))
-		return -EINVAL;
-
-	gsw = platform_get_drvdata(pdev);
-	priv->soc->swpriv = gsw;
-
-	if (gsw->irq) {
-		request_irq(gsw->irq, gsw_interrupt_mt7621, 0,
-			    "gsw", priv);
-		disable_irq(gsw->irq);
-	}
-
-	mt7621_hw_init(gsw, np);
-
-	if (gsw->irq)
-		enable_irq(gsw->irq);
-
-	return 0;
-}
-
-static int mt7621_gsw_probe(struct platform_device *pdev)
-{
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	struct mt7620_gsw *gsw;
-
-	gsw = devm_kzalloc(&pdev->dev, sizeof(struct mt7620_gsw), GFP_KERNEL);
-	if (!gsw)
-		return -ENOMEM;
-
-	gsw->base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(gsw->base))
-		return PTR_ERR(gsw->base);
-
-	gsw->dev = &pdev->dev;
-	gsw->irq = platform_get_irq(pdev, 0);
-
-	platform_set_drvdata(pdev, gsw);
-
-	return 0;
-}
-
-static int mt7621_gsw_remove(struct platform_device *pdev)
-{
-	platform_set_drvdata(pdev, NULL);
-
-	return 0;
-}
-
-static struct platform_driver gsw_driver = {
-	.probe = mt7621_gsw_probe,
-	.remove = mt7621_gsw_remove,
-	.driver = {
-		.name = "mt7621-gsw",
-		.owner = THIS_MODULE,
-		.of_match_table = mediatek_gsw_match,
-	},
-};
-
-module_platform_driver(gsw_driver);
-
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
-MODULE_DESCRIPTION("GBit switch driver for Mediatek MT7621 SoC");
-MODULE_VERSION(MTK_FE_DRV_VERSION);
diff --git a/drivers/net/ethernet/mediatek/mdio.c b/drivers/net/ethernet/mediatek/mdio.c
deleted file mode 100644
index bdfdf7a432c7..000000000000
--- a/drivers/net/ethernet/mediatek/mdio.c
+++ /dev/null
@@ -1,260 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/phy.h>
-#include <linux/of_net.h>
-#include <linux/of_mdio.h>
-
-#include "mtk_eth_soc.h"
-#include "mdio.h"
-
-static int fe_mdio_reset(struct mii_bus *bus)
-{
-	/* TODO */
-	return 0;
-}
-
-static void fe_phy_link_adjust(struct net_device *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	unsigned long flags;
-	int i;
-
-	spin_lock_irqsave(&priv->phy->lock, flags);
-	for (i = 0; i < 8; i++) {
-		if (priv->phy->phy_node[i]) {
-			struct phy_device *phydev = priv->phy->phy[i];
-			int status_change = 0;
-
-			if (phydev->link)
-				if (priv->phy->duplex[i] != phydev->duplex ||
-				    priv->phy->speed[i] != phydev->speed)
-					status_change = 1;
-
-			if (phydev->link != priv->link[i])
-				status_change = 1;
-
-			switch (phydev->speed) {
-			case SPEED_1000:
-			case SPEED_100:
-			case SPEED_10:
-				priv->link[i] = phydev->link;
-				priv->phy->duplex[i] = phydev->duplex;
-				priv->phy->speed[i] = phydev->speed;
-
-				if (status_change &&
-				    priv->soc->mdio_adjust_link)
-					priv->soc->mdio_adjust_link(priv, i);
-				break;
-			}
-		}
-	}
-	spin_unlock_irqrestore(&priv->phy->lock, flags);
-}
-
-int fe_connect_phy_node(struct fe_priv *priv, struct device_node *phy_node)
-{
-	const __be32 *_port = NULL;
-	struct phy_device *phydev;
-	int phy_mode, port;
-
-	_port = of_get_property(phy_node, "reg", NULL);
-
-	if (!_port || (be32_to_cpu(*_port) >= 0x20)) {
-		pr_err("%s: invalid port id\n", phy_node->name);
-		return -EINVAL;
-	}
-	port = be32_to_cpu(*_port);
-	phy_mode = of_get_phy_mode(phy_node);
-	if (phy_mode < 0) {
-		dev_err(priv->dev, "incorrect phy-mode %d\n", phy_mode);
-		priv->phy->phy_node[port] = NULL;
-		return -EINVAL;
-	}
-
-	phydev = of_phy_connect(priv->netdev, phy_node, fe_phy_link_adjust,
-				0, phy_mode);
-	if (!phydev) {
-		dev_err(priv->dev, "could not connect to PHY\n");
-		priv->phy->phy_node[port] = NULL;
-		return -ENODEV;
-	}
-
-	phydev->supported &= PHY_GBIT_FEATURES;
-	phydev->advertising = phydev->supported;
-	phydev->no_auto_carrier_off = 1;
-
-	dev_info(priv->dev,
-		 "connected port %d to PHY at %s [uid=%08x, driver=%s]\n",
-		 port, dev_name(&phydev->mdio.dev), phydev->phy_id,
-		 phydev->drv->name);
-
-	priv->phy->phy[port] = phydev;
-	priv->link[port] = 0;
-
-	return 0;
-}
-
-static void phy_init(struct fe_priv *priv, struct phy_device *phy)
-{
-	phy_attach(priv->netdev, dev_name(&phy->mdio.dev), PHY_INTERFACE_MODE_MII);
-
-	phy->autoneg = AUTONEG_ENABLE;
-	phy->speed = 0;
-	phy->duplex = 0;
-	phy->supported &= PHY_BASIC_FEATURES;
-	phy->advertising = phy->supported | ADVERTISED_Autoneg;
-
-	phy_start_aneg(phy);
-}
-
-static int fe_phy_connect(struct fe_priv *priv)
-{
-	int i;
-
-	for (i = 0; i < 8; i++) {
-		if (priv->phy->phy_node[i]) {
-			if (!priv->phy_dev) {
-				priv->phy_dev = priv->phy->phy[i];
-				priv->phy_flags = FE_PHY_FLAG_PORT;
-			}
-		} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, i)) {
-			phy_init(priv, mdiobus_get_phy(priv->mii_bus, i));
-			if (!priv->phy_dev) {
-				priv->phy_dev = mdiobus_get_phy(priv->mii_bus, i);
-				priv->phy_flags = FE_PHY_FLAG_ATTACH;
-			}
-		}
-	}
-
-	return 0;
-}
-
-static void fe_phy_disconnect(struct fe_priv *priv)
-{
-	unsigned long flags;
-	int i;
-
-	for (i = 0; i < 8; i++)
-		if (priv->phy->phy_fixed[i]) {
-			spin_lock_irqsave(&priv->phy->lock, flags);
-			priv->link[i] = 0;
-			if (priv->soc->mdio_adjust_link)
-				priv->soc->mdio_adjust_link(priv, i);
-			spin_unlock_irqrestore(&priv->phy->lock, flags);
-		} else if (priv->phy->phy[i]) {
-			phy_disconnect(priv->phy->phy[i]);
-		} else if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, i)) {
-			phy_detach(mdiobus_get_phy(priv->mii_bus, i));
-		}
-}
-
-static void fe_phy_start(struct fe_priv *priv)
-{
-	unsigned long flags;
-	int i;
-
-	for (i = 0; i < 8; i++) {
-		if (priv->phy->phy_fixed[i]) {
-			spin_lock_irqsave(&priv->phy->lock, flags);
-			priv->link[i] = 1;
-			if (priv->soc->mdio_adjust_link)
-				priv->soc->mdio_adjust_link(priv, i);
-			spin_unlock_irqrestore(&priv->phy->lock, flags);
-		} else if (priv->phy->phy[i]) {
-			phy_start(priv->phy->phy[i]);
-		}
-	}
-}
-
-static void fe_phy_stop(struct fe_priv *priv)
-{
-	unsigned long flags;
-	int i;
-
-	for (i = 0; i < 8; i++)
-		if (priv->phy->phy_fixed[i]) {
-			spin_lock_irqsave(&priv->phy->lock, flags);
-			priv->link[i] = 0;
-			if (priv->soc->mdio_adjust_link)
-				priv->soc->mdio_adjust_link(priv, i);
-			spin_unlock_irqrestore(&priv->phy->lock, flags);
-		} else if (priv->phy->phy[i]) {
-			phy_stop(priv->phy->phy[i]);
-		}
-}
-
-static struct fe_phy phy_ralink = {
-	.connect = fe_phy_connect,
-	.disconnect = fe_phy_disconnect,
-	.start = fe_phy_start,
-	.stop = fe_phy_stop,
-};
-
-int fe_mdio_init(struct fe_priv *priv)
-{
-	struct device_node *mii_np;
-	int err;
-
-	if (!priv->soc->mdio_read || !priv->soc->mdio_write)
-		return 0;
-
-	spin_lock_init(&phy_ralink.lock);
-	priv->phy = &phy_ralink;
-
-	mii_np = of_get_child_by_name(priv->dev->of_node, "mdio-bus");
-	if (!mii_np) {
-		dev_err(priv->dev, "no %s child node found", "mdio-bus");
-		return -ENODEV;
-	}
-
-	if (!of_device_is_available(mii_np)) {
-		err = 0;
-		goto err_put_node;
-	}
-
-	priv->mii_bus = mdiobus_alloc();
-	if (!priv->mii_bus) {
-		err = -ENOMEM;
-		goto err_put_node;
-	}
-
-	priv->mii_bus->name = "mdio";
-	priv->mii_bus->read = priv->soc->mdio_read;
-	priv->mii_bus->write = priv->soc->mdio_write;
-	priv->mii_bus->reset = fe_mdio_reset;
-	priv->mii_bus->priv = priv;
-	priv->mii_bus->parent = priv->dev;
-
-	snprintf(priv->mii_bus->id, MII_BUS_ID_SIZE, "%s", mii_np->name);
-	err = of_mdiobus_register(priv->mii_bus, mii_np);
-	if (err)
-		goto err_free_bus;
-
-	return 0;
-
-err_free_bus:
-	kfree(priv->mii_bus);
-err_put_node:
-	of_node_put(mii_np);
-	priv->mii_bus = NULL;
-	return err;
-}
-
-void fe_mdio_cleanup(struct fe_priv *priv)
-{
-	if (!priv->mii_bus)
-		return;
-
-	mdiobus_unregister(priv->mii_bus);
-	of_node_put(priv->mii_bus->dev.of_node);
-	kfree(priv->mii_bus);
-}
diff --git a/drivers/net/ethernet/mediatek/mdio.h b/drivers/net/ethernet/mediatek/mdio.h
deleted file mode 100644
index 498cf144e631..000000000000
--- a/drivers/net/ethernet/mediatek/mdio.h
+++ /dev/null
@@ -1,27 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#ifndef _RALINK_MDIO_H__
-#define _RALINK_MDIO_H__
-
-#ifdef CONFIG_NET_MEDIATEK_MDIO
-int fe_mdio_init(struct fe_priv *priv);
-void fe_mdio_cleanup(struct fe_priv *priv);
-int fe_connect_phy_node(struct fe_priv *priv,
-			struct device_node *phy_node);
-#else
-static inline int fe_mdio_init(struct fe_priv *priv) { return 0; }
-static inline void fe_mdio_cleanup(struct fe_priv *priv) {}
-#endif
-#endif
diff --git a/drivers/net/ethernet/mediatek/mdio_mt7620.c b/drivers/net/ethernet/mediatek/mdio_mt7620.c
deleted file mode 100644
index 9efe7896a581..000000000000
--- a/drivers/net/ethernet/mediatek/mdio_mt7620.c
+++ /dev/null
@@ -1,168 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-
-#include "mtk_eth_soc.h"
-#include "gsw_mt7620.h"
-#include "mdio.h"
-
-static int mt7620_mii_busy_wait(struct mt7620_gsw *gsw)
-{
-	unsigned long t_start = jiffies;
-
-	while (1) {
-		if (!(mtk_switch_r32(gsw, MT7620A_GSW_REG_PIAC) & GSW_MDIO_ACCESS))
-			return 0;
-		if (time_after(jiffies, t_start + GSW_REG_PHY_TIMEOUT))
-			break;
-	}
-
-	dev_err(gsw->dev, "mdio: MDIO timeout\n");
-	return -1;
-}
-
-u32 _mt7620_mii_write(struct mt7620_gsw *gsw, u32 phy_addr,
-			     u32 phy_register, u32 write_data)
-{
-	if (mt7620_mii_busy_wait(gsw))
-		return -1;
-
-	write_data &= 0xffff;
-
-	mtk_switch_w32(gsw, GSW_MDIO_ACCESS | GSW_MDIO_START | GSW_MDIO_WRITE |
-		(phy_register << GSW_MDIO_REG_SHIFT) |
-		(phy_addr << GSW_MDIO_ADDR_SHIFT) | write_data,
-		MT7620A_GSW_REG_PIAC);
-
-	if (mt7620_mii_busy_wait(gsw))
-		return -1;
-
-	return 0;
-}
-
-u32 _mt7620_mii_read(struct mt7620_gsw *gsw, int phy_addr, int phy_reg)
-{
-	u32 d;
-
-	if (mt7620_mii_busy_wait(gsw))
-		return 0xffff;
-
-	mtk_switch_w32(gsw, GSW_MDIO_ACCESS | GSW_MDIO_START | GSW_MDIO_READ |
-		(phy_reg << GSW_MDIO_REG_SHIFT) |
-		(phy_addr << GSW_MDIO_ADDR_SHIFT),
-		MT7620A_GSW_REG_PIAC);
-
-	if (mt7620_mii_busy_wait(gsw))
-		return 0xffff;
-
-	d = mtk_switch_r32(gsw, MT7620A_GSW_REG_PIAC) & 0xffff;
-
-	return d;
-}
-
-int mt7620_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val)
-{
-	struct fe_priv *priv = bus->priv;
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-
-	return _mt7620_mii_write(gsw, phy_addr, phy_reg, val);
-}
-
-int mt7620_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
-{
-	struct fe_priv *priv = bus->priv;
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-
-	return _mt7620_mii_read(gsw, phy_addr, phy_reg);
-}
-
-void mt7530_mdio_w32(struct mt7620_gsw *gsw, u32 reg, u32 val)
-{
-	_mt7620_mii_write(gsw, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
-	_mt7620_mii_write(gsw, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
-	_mt7620_mii_write(gsw, 0x1f, 0x10, val >> 16);
-}
-
-u32 mt7530_mdio_r32(struct mt7620_gsw *gsw, u32 reg)
-{
-	u16 high, low;
-
-	_mt7620_mii_write(gsw, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
-	low = _mt7620_mii_read(gsw, 0x1f, (reg >> 2) & 0xf);
-	high = _mt7620_mii_read(gsw, 0x1f, 0x10);
-
-	return (high << 16) | (low & 0xffff);
-}
-
-static unsigned char *fe_speed_str(int speed)
-{
-	switch (speed) {
-	case 2:
-	case SPEED_1000:
-		return "1000";
-	case 1:
-	case SPEED_100:
-		return "100";
-	case 0:
-	case SPEED_10:
-		return "10";
-	}
-
-	return "? ";
-}
-
-int mt7620_has_carrier(struct fe_priv *priv)
-{
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-	int i;
-
-	for (i = 0; i < GSW_PORT6; i++)
-		if (mtk_switch_r32(gsw, GSW_REG_PORT_STATUS(i)) & 0x1)
-			return 1;
-	return 0;
-}
-
-
-void mt7620_handle_carrier(struct fe_priv *priv)
-{
-	if (!priv->phy)
-		return;
-
-	if (mt7620_has_carrier(priv))
-		netif_carrier_on(priv->netdev);
-	else
-		netif_carrier_off(priv->netdev);
-}
-
-void mt7620_print_link_state(struct fe_priv *priv, int port, int link,
-			     int speed, int duplex)
-{
-	if (link)
-		netdev_info(priv->netdev, "port %d link up (%sMbps/%s duplex)\n",
-			    port, fe_speed_str(speed),
-			    (duplex) ? "Full" : "Half");
-	else
-		netdev_info(priv->netdev, "port %d link down\n", port);
-}
-
-void mt7620_mdio_link_adjust(struct fe_priv *priv, int port)
-{
-	mt7620_print_link_state(priv, port, priv->link[port],
-				priv->phy->speed[port],
-				(priv->phy->duplex[port] == DUPLEX_FULL));
-	mt7620_handle_carrier(priv);
-}
diff --git a/drivers/net/ethernet/mediatek/mdio_rt2880.c b/drivers/net/ethernet/mediatek/mdio_rt2880.c
deleted file mode 100644
index e53fd7f62889..000000000000
--- a/drivers/net/ethernet/mediatek/mdio_rt2880.c
+++ /dev/null
@@ -1,222 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/of_net.h>
-#include <linux/of_mdio.h>
-
-#include "mtk_eth_soc.h"
-#include "mdio_rt2880.h"
-#include "mdio.h"
-
-#define FE_MDIO_RETRY	1000
-
-static unsigned char *rt2880_speed_str(struct fe_priv *priv)
-{
-	switch (priv->phy->speed[0]) {
-	case SPEED_1000:
-		return "1000";
-	case SPEED_100:
-		return "100";
-	case SPEED_10:
-		return "10";
-	}
-
-	return "?";
-}
-
-void rt2880_mdio_link_adjust(struct fe_priv *priv, int port)
-{
-	u32 mdio_cfg;
-
-	if (!priv->link[0]) {
-		netif_carrier_off(priv->netdev);
-		netdev_info(priv->netdev, "link down\n");
-		return;
-	}
-
-	mdio_cfg = FE_MDIO_CFG_TX_CLK_SKEW_200 |
-		   FE_MDIO_CFG_RX_CLK_SKEW_200 |
-		   FE_MDIO_CFG_GP1_FRC_EN;
-
-	if (priv->phy->duplex[0] == DUPLEX_FULL)
-		mdio_cfg |= FE_MDIO_CFG_GP1_DUPLEX;
-
-	if (priv->phy->tx_fc[0])
-		mdio_cfg |= FE_MDIO_CFG_GP1_FC_TX;
-
-	if (priv->phy->rx_fc[0])
-		mdio_cfg |= FE_MDIO_CFG_GP1_FC_RX;
-
-	switch (priv->phy->speed[0]) {
-	case SPEED_10:
-		mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_10;
-		break;
-	case SPEED_100:
-		mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_100;
-		break;
-	case SPEED_1000:
-		mdio_cfg |= FE_MDIO_CFG_GP1_SPEED_1000;
-		break;
-	default:
-		BUG();
-	}
-
-	fe_w32(mdio_cfg, FE_MDIO_CFG);
-
-	netif_carrier_on(priv->netdev);
-	netdev_info(priv->netdev, "link up (%sMbps/%s duplex)\n",
-		    rt2880_speed_str(priv),
-		    (priv->phy->duplex[0] == DUPLEX_FULL) ? "Full" : "Half");
-}
-
-static int rt2880_mdio_wait_ready(struct fe_priv *priv)
-{
-	int retries;
-
-	retries = FE_MDIO_RETRY;
-	while (1) {
-		u32 t;
-
-		t = fe_r32(FE_MDIO_ACCESS);
-		if ((t & BIT(31)) == 0)
-			return 0;
-
-		if (retries-- == 0)
-			break;
-
-		udelay(1);
-	}
-
-	dev_err(priv->dev, "MDIO operation timed out\n");
-	return -ETIMEDOUT;
-}
-
-int rt2880_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
-{
-	struct fe_priv *priv = bus->priv;
-	int err;
-	u32 t;
-
-	err = rt2880_mdio_wait_ready(priv);
-	if (err)
-		return 0xffff;
-
-	t = (phy_addr << 24) | (phy_reg << 16);
-	fe_w32(t, FE_MDIO_ACCESS);
-	t |= BIT(31);
-	fe_w32(t, FE_MDIO_ACCESS);
-
-	err = rt2880_mdio_wait_ready(priv);
-	if (err)
-		return 0xffff;
-
-	pr_debug("%s: addr=%04x, reg=%04x, value=%04x\n", __func__,
-		 phy_addr, phy_reg, fe_r32(FE_MDIO_ACCESS) & 0xffff);
-
-	return fe_r32(FE_MDIO_ACCESS) & 0xffff;
-}
-
-int rt2880_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val)
-{
-	struct fe_priv *priv = bus->priv;
-	int err;
-	u32 t;
-
-	pr_debug("%s: addr=%04x, reg=%04x, value=%04x\n", __func__,
-		 phy_addr, phy_reg, fe_r32(FE_MDIO_ACCESS) & 0xffff);
-
-	err = rt2880_mdio_wait_ready(priv);
-	if (err)
-		return err;
-
-	t = (1 << 30) | (phy_addr << 24) | (phy_reg << 16) | val;
-	fe_w32(t, FE_MDIO_ACCESS);
-	t |= BIT(31);
-	fe_w32(t, FE_MDIO_ACCESS);
-
-	return rt2880_mdio_wait_ready(priv);
-}
-
-void rt2880_port_init(struct fe_priv *priv, struct device_node *np)
-{
-	const __be32 *id = of_get_property(np, "reg", NULL);
-	const __be32 *link;
-	int size;
-	int phy_mode;
-
-	if (!id || (be32_to_cpu(*id) != 0)) {
-		pr_err("%s: invalid port id\n", np->name);
-		return;
-	}
-
-	priv->phy->phy_fixed[0] = of_get_property(np,
-						  "mediatek,fixed-link", &size);
-	if (priv->phy->phy_fixed[0] &&
-	    (size != (4 * sizeof(*priv->phy->phy_fixed[0])))) {
-		pr_err("%s: invalid fixed link property\n", np->name);
-		priv->phy->phy_fixed[0] = NULL;
-		return;
-	}
-
-	phy_mode = of_get_phy_mode(np);
-	switch (phy_mode) {
-	case PHY_INTERFACE_MODE_RGMII:
-		break;
-	case PHY_INTERFACE_MODE_MII:
-		break;
-	case PHY_INTERFACE_MODE_RMII:
-		break;
-	default:
-		if (!priv->phy->phy_fixed[0])
-			dev_err(priv->dev, "port %d - invalid phy mode\n",
-				priv->phy->speed[0]);
-		break;
-	}
-
-	priv->phy->phy_node[0] = of_parse_phandle(np, "phy-handle", 0);
-	if (!priv->phy->phy_node[0] && !priv->phy->phy_fixed[0])
-		return;
-
-	if (priv->phy->phy_fixed[0]) {
-		link = priv->phy->phy_fixed[0];
-		priv->phy->speed[0] = be32_to_cpup(link++);
-		priv->phy->duplex[0] = be32_to_cpup(link++);
-		priv->phy->tx_fc[0] = be32_to_cpup(link++);
-		priv->phy->rx_fc[0] = be32_to_cpup(link++);
-
-		priv->link[0] = 1;
-		switch (priv->phy->speed[0]) {
-		case SPEED_10:
-			break;
-		case SPEED_100:
-			break;
-		case SPEED_1000:
-			break;
-		default:
-			dev_err(priv->dev, "invalid link speed: %d\n",
-				priv->phy->speed[0]);
-			priv->phy->phy_fixed[0] = 0;
-			return;
-		}
-		dev_info(priv->dev, "using fixed link parameters\n");
-		rt2880_mdio_link_adjust(priv, 0);
-		return;
-	}
-
-	if (priv->phy->phy_node[0] && mdiobus_get_phy(priv->mii_bus, 0))
-		fe_connect_phy_node(priv, priv->phy->phy_node[0]);
-}
diff --git a/drivers/net/ethernet/mediatek/mdio_rt2880.h b/drivers/net/ethernet/mediatek/mdio_rt2880.h
deleted file mode 100644
index 70e344283e59..000000000000
--- a/drivers/net/ethernet/mediatek/mdio_rt2880.h
+++ /dev/null
@@ -1,23 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#ifndef _RALINK_MDIO_RT2880_H__
-#define _RALINK_MDIO_RT2880_H__
-
-void rt2880_mdio_link_adjust(struct fe_priv *priv, int port);
-int rt2880_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg);
-int rt2880_mdio_write(struct mii_bus *bus, int phy_addr, int phy_reg, u16 val);
-void rt2880_port_init(struct fe_priv *priv, struct device_node *np);
-
-#endif
diff --git a/drivers/net/ethernet/mediatek/mt7530.c b/drivers/net/ethernet/mediatek/mt7530.c
deleted file mode 100644
index 5216cb5c6618..000000000000
--- a/drivers/net/ethernet/mediatek/mt7530.c
+++ /dev/null
@@ -1,979 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
- * Copyright (C) 2016 Vitaly Chekryzhev <13hakta@gmail.com>
- */
-
-#include <linux/if.h>
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/list.h>
-#include <linux/if_ether.h>
-#include <linux/skbuff.h>
-#include <linux/netdevice.h>
-#include <linux/netlink.h>
-#include <linux/bitops.h>
-#include <net/genetlink.h>
-#include <linux/switch.h>
-#include <linux/delay.h>
-#include <linux/phy.h>
-#include <linux/netdevice.h>
-#include <linux/etherdevice.h>
-#include <linux/lockdep.h>
-#include <linux/workqueue.h>
-#include <linux/of_device.h>
-
-#include "mt7530.h"
-
-#define MT7530_CPU_PORT		6
-#define MT7530_NUM_PORTS	8
-#ifdef CONFIG_SOC_MT7621
-#define MT7530_NUM_VLANS	4095
-#else
-#define MT7530_NUM_VLANS	16
-#endif
-#define MT7530_MAX_VID		4095
-#define MT7530_MIN_VID		0
-
-#define MT7530_PORT_MIB_TXB_ID	2	/* TxGOC */
-#define MT7530_PORT_MIB_RXB_ID	6	/* RxGOC */
-
-#define MT7621_PORT_MIB_TXB_ID	18	/* TxByte */
-#define MT7621_PORT_MIB_RXB_ID	37	/* RxByte */
-
-/* registers */
-#define REG_ESW_VLAN_VTCR		0x90
-#define REG_ESW_VLAN_VAWD1		0x94
-#define REG_ESW_VLAN_VAWD2		0x98
-#define REG_ESW_VLAN_VTIM(x)	(0x100 + 4 * ((x) / 2))
-
-#define REG_ESW_VLAN_VAWD1_IVL_MAC	BIT(30)
-#define REG_ESW_VLAN_VAWD1_VTAG_EN	BIT(28)
-#define REG_ESW_VLAN_VAWD1_VALID	BIT(0)
-
-/* vlan egress mode */
-enum {
-	ETAG_CTRL_UNTAG	= 0,
-	ETAG_CTRL_TAG	= 2,
-	ETAG_CTRL_SWAP	= 1,
-	ETAG_CTRL_STACK	= 3,
-};
-
-#define REG_ESW_PORT_PCR(x)	(0x2004 | ((x) << 8))
-#define REG_ESW_PORT_PVC(x)	(0x2010 | ((x) << 8))
-#define REG_ESW_PORT_PPBV1(x)	(0x2014 | ((x) << 8))
-
-#define REG_HWTRAP		0x7804
-
-#define MIB_DESC(_s , _o, _n)   \
-	{                       \
-		.size = (_s),   \
-		.offset = (_o), \
-		.name = (_n),   \
-	}
-
-struct mt7xxx_mib_desc {
-	unsigned int size;
-	unsigned int offset;
-	const char *name;
-};
-
-static const struct mt7xxx_mib_desc mt7620_mibs[] = {
-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_BCNT0, "PPE_AC_BCNT0"),
-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_PCNT0, "PPE_AC_PCNT0"),
-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_BCNT63, "PPE_AC_BCNT63"),
-	MIB_DESC(1, MT7620_MIB_STATS_PPE_AC_PCNT63, "PPE_AC_PCNT63"),
-	MIB_DESC(1, MT7620_MIB_STATS_PPE_MTR_CNT0, "PPE_MTR_CNT0"),
-	MIB_DESC(1, MT7620_MIB_STATS_PPE_MTR_CNT63, "PPE_MTR_CNT63"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_GBCNT, "GDM1_TX_GBCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_GPCNT, "GDM1_TX_GPCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_SKIPCNT, "GDM1_TX_SKIPCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_TX_COLCNT, "GDM1_TX_COLCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_GBCNT1, "GDM1_RX_GBCNT1"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_GPCNT1, "GDM1_RX_GPCNT1"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_OERCNT, "GDM1_RX_OERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_FERCNT, "GDM1_RX_FERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_SERCNT, "GDM1_RX_SERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_LERCNT, "GDM1_RX_LERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_CERCNT, "GDM1_RX_CERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM1_RX_FCCNT, "GDM1_RX_FCCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_GBCNT, "GDM2_TX_GBCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_GPCNT, "GDM2_TX_GPCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_SKIPCNT, "GDM2_TX_SKIPCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_TX_COLCNT, "GDM2_TX_COLCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_GBCNT, "GDM2_RX_GBCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_GPCNT, "GDM2_RX_GPCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_OERCNT, "GDM2_RX_OERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_FERCNT, "GDM2_RX_FERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_SERCNT, "GDM2_RX_SERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_LERCNT, "GDM2_RX_LERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_CERCNT, "GDM2_RX_CERCNT"),
-	MIB_DESC(1, MT7620_MIB_STATS_GDM2_RX_FCCNT, "GDM2_RX_FCCNT")
-};
-
-static const struct mt7xxx_mib_desc mt7620_port_mibs[] = {
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TGPCN,  "TxGPC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TBOCN,  "TxBOC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TGOCN,  "TxGOC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_TEPCN,  "TxEPC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_RGPCN,  "RxGPC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_RBOCN,  "RxBOC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_RGOCN,  "RxGOC"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_REPC1N, "RxEPC1"),
-	MIB_DESC(1, MT7620_MIB_STATS_PORT_REPC2N, "RxEPC2")
-};
-
-static const struct mt7xxx_mib_desc mt7621_mibs[] = {
-	MIB_DESC(1, MT7621_STATS_TDPC, "TxDrop"),
-	MIB_DESC(1, MT7621_STATS_TCRC, "TxCRC"),
-	MIB_DESC(1, MT7621_STATS_TUPC, "TxUni"),
-	MIB_DESC(1, MT7621_STATS_TMPC, "TxMulti"),
-	MIB_DESC(1, MT7621_STATS_TBPC, "TxBroad"),
-	MIB_DESC(1, MT7621_STATS_TCEC, "TxCollision"),
-	MIB_DESC(1, MT7621_STATS_TSCEC, "TxSingleCol"),
-	MIB_DESC(1, MT7621_STATS_TMCEC, "TxMultiCol"),
-	MIB_DESC(1, MT7621_STATS_TDEC, "TxDefer"),
-	MIB_DESC(1, MT7621_STATS_TLCEC, "TxLateCol"),
-	MIB_DESC(1, MT7621_STATS_TXCEC, "TxExcCol"),
-	MIB_DESC(1, MT7621_STATS_TPPC, "TxPause"),
-	MIB_DESC(1, MT7621_STATS_TL64PC, "Tx64Byte"),
-	MIB_DESC(1, MT7621_STATS_TL65PC, "Tx65Byte"),
-	MIB_DESC(1, MT7621_STATS_TL128PC, "Tx128Byte"),
-	MIB_DESC(1, MT7621_STATS_TL256PC, "Tx256Byte"),
-	MIB_DESC(1, MT7621_STATS_TL512PC, "Tx512Byte"),
-	MIB_DESC(1, MT7621_STATS_TL1024PC, "Tx1024Byte"),
-	MIB_DESC(2, MT7621_STATS_TOC, "TxByte"),
-	MIB_DESC(1, MT7621_STATS_RDPC, "RxDrop"),
-	MIB_DESC(1, MT7621_STATS_RFPC, "RxFiltered"),
-	MIB_DESC(1, MT7621_STATS_RUPC, "RxUni"),
-	MIB_DESC(1, MT7621_STATS_RMPC, "RxMulti"),
-	MIB_DESC(1, MT7621_STATS_RBPC, "RxBroad"),
-	MIB_DESC(1, MT7621_STATS_RAEPC, "RxAlignErr"),
-	MIB_DESC(1, MT7621_STATS_RCEPC, "RxCRC"),
-	MIB_DESC(1, MT7621_STATS_RUSPC, "RxUnderSize"),
-	MIB_DESC(1, MT7621_STATS_RFEPC, "RxFragment"),
-	MIB_DESC(1, MT7621_STATS_ROSPC, "RxOverSize"),
-	MIB_DESC(1, MT7621_STATS_RJEPC, "RxJabber"),
-	MIB_DESC(1, MT7621_STATS_RPPC, "RxPause"),
-	MIB_DESC(1, MT7621_STATS_RL64PC, "Rx64Byte"),
-	MIB_DESC(1, MT7621_STATS_RL65PC, "Rx65Byte"),
-	MIB_DESC(1, MT7621_STATS_RL128PC, "Rx128Byte"),
-	MIB_DESC(1, MT7621_STATS_RL256PC, "Rx256Byte"),
-	MIB_DESC(1, MT7621_STATS_RL512PC, "Rx512Byte"),
-	MIB_DESC(1, MT7621_STATS_RL1024PC, "Rx1024Byte"),
-	MIB_DESC(2, MT7621_STATS_ROC, "RxByte"),
-	MIB_DESC(1, MT7621_STATS_RDPC_CTRL, "RxCtrlDrop"),
-	MIB_DESC(1, MT7621_STATS_RDPC_ING, "RxIngDrop"),
-	MIB_DESC(1, MT7621_STATS_RDPC_ARL, "RxARLDrop")
-};
-
-enum {
-	/* Global attributes. */
-	MT7530_ATTR_ENABLE_VLAN,
-};
-
-struct mt7530_port_entry {
-	u16	pvid;
-};
-
-struct mt7530_vlan_entry {
-	u16	vid;
-	u8	member;
-	u8	etags;
-};
-
-struct mt7530_priv {
-	void __iomem		*base;
-	struct mii_bus		*bus;
-	struct switch_dev	swdev;
-
-	bool			global_vlan_enable;
-	struct mt7530_vlan_entry	vlan_entries[MT7530_NUM_VLANS];
-	struct mt7530_port_entry	port_entries[MT7530_NUM_PORTS];
-};
-
-struct mt7530_mapping {
-	char	*name;
-	u16	pvids[MT7530_NUM_PORTS];
-	u8	members[MT7530_NUM_VLANS];
-	u8	etags[MT7530_NUM_VLANS];
-	u16	vids[MT7530_NUM_VLANS];
-} mt7530_defaults[] = {
-	{
-		.name = "llllw",
-		.pvids = { 1, 1, 1, 1, 2, 1, 1 },
-		.members = { 0, 0x6f, 0x50 },
-		.etags = { 0, 0x40, 0x40 },
-		.vids = { 0, 1, 2 },
-	}, {
-		.name = "wllll",
-		.pvids = { 2, 1, 1, 1, 1, 1, 1 },
-		.members = { 0, 0x7e, 0x41 },
-		.etags = { 0, 0x40, 0x40 },
-		.vids = { 0, 1, 2 },
-	}, {
-		.name = "lwlll",
-		.pvids = { 1, 2, 1, 1, 1, 1, 1 },
-		.members = { 0, 0x7d, 0x42 },
-		.etags = { 0, 0x40, 0x40 },
-		.vids = { 0, 1, 2 },
-	},
-};
-
-struct mt7530_mapping*
-mt7530_find_mapping(struct device_node *np)
-{
-	const char *map;
-	int i;
-
-	if (of_property_read_string(np, "mediatek,portmap", &map))
-		return NULL;
-
-	for (i = 0; i < ARRAY_SIZE(mt7530_defaults); i++)
-		if (!strcmp(map, mt7530_defaults[i].name))
-			return &mt7530_defaults[i];
-
-	return NULL;
-}
-
-static void
-mt7530_apply_mapping(struct mt7530_priv *mt7530, struct mt7530_mapping *map)
-{
-	int i = 0;
-
-	for (i = 0; i < MT7530_NUM_PORTS; i++)
-		mt7530->port_entries[i].pvid = map->pvids[i];
-
-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
-		mt7530->vlan_entries[i].member = map->members[i];
-		mt7530->vlan_entries[i].etags = map->etags[i];
-		mt7530->vlan_entries[i].vid = map->vids[i];
-	}
-}
-
-static int
-mt7530_reset_switch(struct switch_dev *dev)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	int i;
-
-	memset(priv->port_entries, 0, sizeof(priv->port_entries));
-	memset(priv->vlan_entries, 0, sizeof(priv->vlan_entries));
-
-	/* set default vid of each vlan to the same number of vlan, so the vid
-	 * won't need be set explicitly.
-	 */
-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
-		priv->vlan_entries[i].vid = i;
-	}
-
-	return 0;
-}
-
-static int
-mt7530_get_vlan_enable(struct switch_dev *dev,
-			   const struct switch_attr *attr,
-			   struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-
-	val->value.i = priv->global_vlan_enable;
-
-	return 0;
-}
-
-static int
-mt7530_set_vlan_enable(struct switch_dev *dev,
-			   const struct switch_attr *attr,
-			   struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-
-	priv->global_vlan_enable = val->value.i != 0;
-
-	return 0;
-}
-
-static u32
-mt7530_r32(struct mt7530_priv *priv, u32 reg)
-{
-	u32 val;
-	if (priv->bus) {
-		u16 high, low;
-
-		mdiobus_write(priv->bus, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
-		low = mdiobus_read(priv->bus, 0x1f, (reg >> 2) & 0xf);
-		high = mdiobus_read(priv->bus, 0x1f, 0x10);
-
-		return (high << 16) | (low & 0xffff);
-	}
-
-	val = ioread32(priv->base + reg);
-	pr_debug("MT7530 MDIO Read [%04x]=%08x\n", reg, val);
-
-	return val;
-}
-
-static void
-mt7530_w32(struct mt7530_priv *priv, u32 reg, u32 val)
-{
-	if (priv->bus) {
-		mdiobus_write(priv->bus, 0x1f, 0x1f, (reg >> 6) & 0x3ff);
-		mdiobus_write(priv->bus, 0x1f, (reg >> 2) & 0xf,  val & 0xffff);
-		mdiobus_write(priv->bus, 0x1f, 0x10, val >> 16);
-		return;
-	}
-
-	pr_debug("MT7530 MDIO Write[%04x]=%08x\n", reg, val);
-	iowrite32(val, priv->base + reg);
-}
-
-static void
-mt7530_vtcr(struct mt7530_priv *priv, u32 cmd, u32 val)
-{
-	int i;
-
-	mt7530_w32(priv, REG_ESW_VLAN_VTCR, BIT(31) | (cmd << 12) | val);
-
-	for (i = 0; i < 20; i++) {
-		u32 val = mt7530_r32(priv, REG_ESW_VLAN_VTCR);
-
-		if ((val & BIT(31)) == 0)
-			break;
-
-		udelay(1000);
-	}
-	if (i == 20)
-		printk("mt7530: vtcr timeout\n");
-}
-
-static int
-mt7530_get_port_pvid(struct switch_dev *dev, int port, int *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-
-	if (port >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	*val = mt7530_r32(priv, REG_ESW_PORT_PPBV1(port));
-	*val &= 0xfff;
-
-	return 0;
-}
-
-static int
-mt7530_set_port_pvid(struct switch_dev *dev, int port, int pvid)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-
-	if (port >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	if (pvid < MT7530_MIN_VID || pvid > MT7530_MAX_VID)
-		return -EINVAL;
-
-	priv->port_entries[port].pvid = pvid;
-
-	return 0;
-}
-
-static int
-mt7530_get_vlan_ports(struct switch_dev *dev, struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	u32 member;
-	u32 etags;
-	int i;
-
-	val->len = 0;
-
-	if (val->port_vlan < 0 || val->port_vlan >= MT7530_NUM_VLANS)
-		return -EINVAL;
-
-	mt7530_vtcr(priv, 0, val->port_vlan);
-
-	member = mt7530_r32(priv, REG_ESW_VLAN_VAWD1);
-	member >>= 16;
-	member &= 0xff;
-
-	etags = mt7530_r32(priv, REG_ESW_VLAN_VAWD2);
-
-	for (i = 0; i < MT7530_NUM_PORTS; i++) {
-		struct switch_port *p;
-		int etag;
-
-		if (!(member & BIT(i)))
-			continue;
-
-		p = &val->value.ports[val->len++];
-		p->id = i;
-
-		etag = (etags >> (i * 2)) & 0x3;
-
-		if (etag == ETAG_CTRL_TAG)
-			p->flags |= BIT(SWITCH_PORT_FLAG_TAGGED);
-		else if (etag != ETAG_CTRL_UNTAG)
-			printk("vlan egress tag control neither untag nor tag.\n");
-	}
-
-	return 0;
-}
-
-static int
-mt7530_set_vlan_ports(struct switch_dev *dev, struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	u8 member = 0;
-	u8 etags = 0;
-	int i;
-
-	if (val->port_vlan < 0 || val->port_vlan >= MT7530_NUM_VLANS ||
-			val->len > MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	for (i = 0; i < val->len; i++) {
-		struct switch_port *p = &val->value.ports[i];
-
-		if (p->id >= MT7530_NUM_PORTS)
-			return -EINVAL;
-
-		member |= BIT(p->id);
-
-		if (p->flags & BIT(SWITCH_PORT_FLAG_TAGGED))
-			etags |= BIT(p->id);
-	}
-	priv->vlan_entries[val->port_vlan].member = member;
-	priv->vlan_entries[val->port_vlan].etags = etags;
-
-	return 0;
-}
-
-static int
-mt7530_set_vid(struct switch_dev *dev, const struct switch_attr *attr,
-		struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	int vlan;
-	u16 vid;
-
-	vlan = val->port_vlan;
-	vid = (u16)val->value.i;
-
-	if (vlan < 0 || vlan >= MT7530_NUM_VLANS)
-		return -EINVAL;
-
-	if (vid < MT7530_MIN_VID || vid > MT7530_MAX_VID)
-		return -EINVAL;
-
-	priv->vlan_entries[vlan].vid = vid;
-	return 0;
-}
-
-static int
-mt7621_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
-		struct switch_val *val)
-{
-	val->value.i = val->port_vlan;
-	return 0;
-}
-
-static int
-mt7530_get_vid(struct switch_dev *dev, const struct switch_attr *attr,
-		struct switch_val *val)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	u32 vid;
-	int vlan;
-
-	vlan = val->port_vlan;
-
-	vid = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
-	if (vlan & 1)
-		vid = vid >> 12;
-	vid &= 0xfff;
-
-	val->value.i = vid;
-	return 0;
-}
-
-static void
-mt7530_write_vlan_entry(struct mt7530_priv *priv, int vlan, u16 vid,
-	                    u8 ports, u8 etags)
-{
-	int port;
-	u32 val;
-
-#ifndef CONFIG_SOC_MT7621
-	/* vid of vlan */
-	val = mt7530_r32(priv, REG_ESW_VLAN_VTIM(vlan));
-	if (vlan % 2 == 0) {
-		val &= 0xfff000;
-		val |= vid;
-	} else {
-		val &= 0xfff;
-		val |= (vid << 12);
-	}
-	mt7530_w32(priv, REG_ESW_VLAN_VTIM(vlan), val);
-#endif
-
-	/* vlan port membership */
-	if (ports)
-		mt7530_w32(priv, REG_ESW_VLAN_VAWD1, REG_ESW_VLAN_VAWD1_IVL_MAC |
-			REG_ESW_VLAN_VAWD1_VTAG_EN | (ports << 16) |
-			REG_ESW_VLAN_VAWD1_VALID);
-	else
-		mt7530_w32(priv, REG_ESW_VLAN_VAWD1, 0);
-
-	/* egress mode */
-	val = 0;
-	for (port = 0; port < MT7530_NUM_PORTS; port++) {
-		if (etags & BIT(port))
-			val |= ETAG_CTRL_TAG << (port * 2);
-		else
-			val |= ETAG_CTRL_UNTAG << (port * 2);
-	}
-	mt7530_w32(priv, REG_ESW_VLAN_VAWD2, val);
-
-	/* write to vlan table */
-#ifdef CONFIG_SOC_MT7621
-	mt7530_vtcr(priv, 1, vid);
-#else
-	mt7530_vtcr(priv, 1, vlan);
-#endif
-}
-
-static int
-mt7530_apply_config(struct switch_dev *dev)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	int i, j;
-	u8 tag_ports;
-	u8 untag_ports;
-
-	if (!priv->global_vlan_enable) {
-		for (i = 0; i < MT7530_NUM_PORTS; i++)
-			mt7530_w32(priv, REG_ESW_PORT_PCR(i), 0x00400000);
-
-		mt7530_w32(priv, REG_ESW_PORT_PCR(MT7530_CPU_PORT), 0x00ff0000);
-
-		for (i = 0; i < MT7530_NUM_PORTS; i++)
-			mt7530_w32(priv, REG_ESW_PORT_PVC(i), 0x810000c0);
-
-		return 0;
-	}
-
-	/* set all ports as security mode */
-	for (i = 0; i < MT7530_NUM_PORTS; i++)
-		mt7530_w32(priv, REG_ESW_PORT_PCR(i), 0x00ff0003);
-
-	/* check if a port is used in tag/untag vlan egress mode */
-	tag_ports = 0;
-	untag_ports = 0;
-
-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
-		u8 member = priv->vlan_entries[i].member;
-		u8 etags = priv->vlan_entries[i].etags;
-
-		if (!member)
-			continue;
-
-		for (j = 0; j < MT7530_NUM_PORTS; j++) {
-			if (!(member & BIT(j)))
-				continue;
-
-			if (etags & BIT(j))
-				tag_ports |= 1u << j;
-			else
-				untag_ports |= 1u << j;
-		}
-	}
-
-	/* set all untag-only ports as transparent and the rest as user port */
-	for (i = 0; i < MT7530_NUM_PORTS; i++) {
-		u32 pvc_mode = 0x81000000;
-
-		if (untag_ports & BIT(i) && !(tag_ports & BIT(i)))
-			pvc_mode = 0x810000c0;
-
-		mt7530_w32(priv, REG_ESW_PORT_PVC(i), pvc_mode);
-	}
-
-	/* first clear the swtich vlan table */
-	for (i = 0; i < MT7530_NUM_VLANS; i++)
-		mt7530_write_vlan_entry(priv, i, i, 0, 0);
-
-	/* now program only vlans with members to avoid
-	   clobbering remapped entries in later iterations */
-	for (i = 0; i < MT7530_NUM_VLANS; i++) {
-		u16 vid = priv->vlan_entries[i].vid;
-		u8 member = priv->vlan_entries[i].member;
-		u8 etags = priv->vlan_entries[i].etags;
-
-		if (member)
-			mt7530_write_vlan_entry(priv, i, vid, member, etags);
-	}
-
-	/* Port Default PVID */
-	for (i = 0; i < MT7530_NUM_PORTS; i++) {
-		int vlan = priv->port_entries[i].pvid;
-		u16 pvid = 0;
-		u32 val;
-
-		if (vlan < MT7530_NUM_VLANS && priv->vlan_entries[vlan].member)
-			pvid = priv->vlan_entries[vlan].vid;
-
-		val = mt7530_r32(priv, REG_ESW_PORT_PPBV1(i));
-		val &= ~0xfff;
-		val |= pvid;
-		mt7530_w32(priv, REG_ESW_PORT_PPBV1(i), val);
-	}
-
-	return 0;
-}
-
-static int
-mt7530_get_port_link(struct switch_dev *dev,  int port,
-			struct switch_port_link *link)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	u32 speed, pmsr;
-
-	if (port < 0 || port >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	pmsr = mt7530_r32(priv, 0x3008 + (0x100 * port));
-
-	link->link = pmsr & 1;
-	link->duplex = (pmsr >> 1) & 1;
-	speed = (pmsr >> 2) & 3;
-
-	switch (speed) {
-	case 0:
-		link->speed = SWITCH_PORT_SPEED_10;
-		break;
-	case 1:
-		link->speed = SWITCH_PORT_SPEED_100;
-		break;
-	case 2:
-	case 3: /* forced gige speed can be 2 or 3 */
-		link->speed = SWITCH_PORT_SPEED_1000;
-		break;
-	default:
-		link->speed = SWITCH_PORT_SPEED_UNKNOWN;
-		break;
-	}
-
-	return 0;
-}
-
-static u64 get_mib_counter(struct mt7530_priv *priv, int i, int port)
-{
-	unsigned int port_base;
-	u64 lo;
-
-	port_base = MT7621_MIB_COUNTER_BASE +
-		    MT7621_MIB_COUNTER_PORT_OFFSET * port;
-
-	lo = mt7530_r32(priv, port_base + mt7621_mibs[i].offset);
-	if (mt7621_mibs[i].size == 2) {
-		u64 hi;
-
-		hi = mt7530_r32(priv, port_base + mt7621_mibs[i].offset + 4);
-		lo |= hi << 32;
-	}
-
-	return lo;
-}
-
-static int mt7621_sw_get_port_mib(struct switch_dev *dev,
-				  const struct switch_attr *attr,
-				  struct switch_val *val)
-{
-	static char buf[4096];
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	int i, len = 0;
-
-	if (val->port_vlan >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	len += snprintf(buf + len, sizeof(buf) - len,
-			"Port %d MIB counters\n", val->port_vlan);
-
-	for (i = 0; i < ARRAY_SIZE(mt7621_mibs); ++i) {
-		u64 counter;
-		len += snprintf(buf + len, sizeof(buf) - len,
-				"%-11s: ", mt7621_mibs[i].name);
-		counter = get_mib_counter(priv, i, val->port_vlan);
-		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
-				counter);
-	}
-
-	val->value.s = buf;
-	val->len = len;
-	return 0;
-}
-
-static u64 get_mib_counter_7620(struct mt7530_priv *priv, int i)
-{
-	return mt7530_r32(priv, MT7620_MIB_COUNTER_BASE + mt7620_mibs[i].offset);
-}
-
-static u64 get_mib_counter_port_7620(struct mt7530_priv *priv, int i, int port)
-{
-	return mt7530_r32(priv,
-			MT7620_MIB_COUNTER_BASE_PORT +
-			(MT7620_MIB_COUNTER_PORT_OFFSET * port) +
-			mt7620_port_mibs[i].offset);
-}
-
-static int mt7530_sw_get_mib(struct switch_dev *dev,
-				  const struct switch_attr *attr,
-				  struct switch_val *val)
-{
-	static char buf[4096];
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	int i, len = 0;
-
-	len += snprintf(buf + len, sizeof(buf) - len, "Switch MIB counters\n");
-
-	for (i = 0; i < ARRAY_SIZE(mt7620_mibs); ++i) {
-		u64 counter;
-		len += snprintf(buf + len, sizeof(buf) - len,
-				"%-11s: ", mt7620_mibs[i].name);
-		counter = get_mib_counter_7620(priv, i);
-		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
-				counter);
-	}
-
-	val->value.s = buf;
-	val->len = len;
-	return 0;
-}
-
-static int mt7530_sw_get_port_mib(struct switch_dev *dev,
-				  const struct switch_attr *attr,
-				  struct switch_val *val)
-{
-	static char buf[4096];
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-	int i, len = 0;
-
-	if (val->port_vlan >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	len += snprintf(buf + len, sizeof(buf) - len,
-			"Port %d MIB counters\n", val->port_vlan);
-
-	for (i = 0; i < ARRAY_SIZE(mt7620_port_mibs); ++i) {
-		u64 counter;
-		len += snprintf(buf + len, sizeof(buf) - len,
-				"%-11s: ", mt7620_port_mibs[i].name);
-		counter = get_mib_counter_port_7620(priv, i, val->port_vlan);
-		len += snprintf(buf + len, sizeof(buf) - len, "%llu\n",
-				counter);
-	}
-
-	val->value.s = buf;
-	val->len = len;
-	return 0;
-}
-
-static int mt7530_get_port_stats(struct switch_dev *dev, int port,
-					struct switch_port_stats *stats)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-
-	if (port < 0 || port >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	stats->tx_bytes = get_mib_counter_port_7620(priv, MT7530_PORT_MIB_TXB_ID, port);
-	stats->rx_bytes = get_mib_counter_port_7620(priv, MT7530_PORT_MIB_RXB_ID, port);
-
-	return 0;
-}
-
-static int mt7621_get_port_stats(struct switch_dev *dev, int port,
-					struct switch_port_stats *stats)
-{
-	struct mt7530_priv *priv = container_of(dev, struct mt7530_priv, swdev);
-
-	if (port < 0 || port >= MT7530_NUM_PORTS)
-		return -EINVAL;
-
-	stats->tx_bytes = get_mib_counter(priv, MT7621_PORT_MIB_TXB_ID, port);
-	stats->rx_bytes = get_mib_counter(priv, MT7621_PORT_MIB_RXB_ID, port);
-
-	return 0;
-}
-
-static const struct switch_attr mt7530_global[] = {
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "enable_vlan",
-		.description = "VLAN mode (1:enabled)",
-		.max = 1,
-		.id = MT7530_ATTR_ENABLE_VLAN,
-		.get = mt7530_get_vlan_enable,
-		.set = mt7530_set_vlan_enable,
-	}, {
-		.type = SWITCH_TYPE_STRING,
-		.name = "mib",
-		.description = "Get MIB counters for switch",
-		.get = mt7530_sw_get_mib,
-		.set = NULL,
-	},
-};
-
-static const struct switch_attr mt7621_port[] = {
-	{
-		.type = SWITCH_TYPE_STRING,
-		.name = "mib",
-		.description = "Get MIB counters for port",
-		.get = mt7621_sw_get_port_mib,
-		.set = NULL,
-	},
-};
-
-static const struct switch_attr mt7621_vlan[] = {
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "vid",
-		.description = "VLAN ID (0-4094)",
-		.set = mt7530_set_vid,
-		.get = mt7621_get_vid,
-		.max = 4094,
-	},
-};
-
-static const struct switch_attr mt7530_port[] = {
-	{
-		.type = SWITCH_TYPE_STRING,
-		.name = "mib",
-		.description = "Get MIB counters for port",
-		.get = mt7530_sw_get_port_mib,
-		.set = NULL,
-	},
-};
-
-static const struct switch_attr mt7530_vlan[] = {
-	{
-		.type = SWITCH_TYPE_INT,
-		.name = "vid",
-		.description = "VLAN ID (0-4094)",
-		.set = mt7530_set_vid,
-		.get = mt7530_get_vid,
-		.max = 4094,
-	},
-};
-
-static const struct switch_dev_ops mt7621_ops = {
-	.attr_global = {
-		.attr = mt7530_global,
-		.n_attr = ARRAY_SIZE(mt7530_global),
-	},
-	.attr_port = {
-		.attr = mt7621_port,
-		.n_attr = ARRAY_SIZE(mt7621_port),
-	},
-	.attr_vlan = {
-		.attr = mt7621_vlan,
-		.n_attr = ARRAY_SIZE(mt7621_vlan),
-	},
-	.get_vlan_ports = mt7530_get_vlan_ports,
-	.set_vlan_ports = mt7530_set_vlan_ports,
-	.get_port_pvid = mt7530_get_port_pvid,
-	.set_port_pvid = mt7530_set_port_pvid,
-	.get_port_link = mt7530_get_port_link,
-	.get_port_stats = mt7621_get_port_stats,
-	.apply_config = mt7530_apply_config,
-	.reset_switch = mt7530_reset_switch,
-};
-
-static const struct switch_dev_ops mt7530_ops = {
-	.attr_global = {
-		.attr = mt7530_global,
-		.n_attr = ARRAY_SIZE(mt7530_global),
-	},
-	.attr_port = {
-		.attr = mt7530_port,
-		.n_attr = ARRAY_SIZE(mt7530_port),
-	},
-	.attr_vlan = {
-		.attr = mt7530_vlan,
-		.n_attr = ARRAY_SIZE(mt7530_vlan),
-	},
-	.get_vlan_ports = mt7530_get_vlan_ports,
-	.set_vlan_ports = mt7530_set_vlan_ports,
-	.get_port_pvid = mt7530_get_port_pvid,
-	.set_port_pvid = mt7530_set_port_pvid,
-	.get_port_link = mt7530_get_port_link,
-	.get_port_stats = mt7530_get_port_stats,
-	.apply_config = mt7530_apply_config,
-	.reset_switch = mt7530_reset_switch,
-};
-
-int
-mt7530_probe(struct device *dev, void __iomem *base, struct mii_bus *bus, int vlan)
-{
-	struct switch_dev *swdev;
-	struct mt7530_priv *mt7530;
-	struct mt7530_mapping *map;
-	int ret;
-
-	mt7530 = devm_kzalloc(dev, sizeof(struct mt7530_priv), GFP_KERNEL);
-	if (!mt7530)
-		return -ENOMEM;
-
-	mt7530->base = base;
-	mt7530->bus = bus;
-	mt7530->global_vlan_enable = vlan;
-
-	swdev = &mt7530->swdev;
-	if (bus) {
-		swdev->alias = "mt7530";
-		swdev->name = "mt7530";
-	} else if (IS_ENABLED(CONFIG_SOC_MT7621)) {
-		swdev->alias = "mt7621";
-		swdev->name = "mt7621";
-	} else {
-		swdev->alias = "mt7620";
-		swdev->name = "mt7620";
-	}
-	swdev->cpu_port = MT7530_CPU_PORT;
-	swdev->ports = MT7530_NUM_PORTS;
-	swdev->vlans = MT7530_NUM_VLANS;
-	if (IS_ENABLED(CONFIG_SOC_MT7621))
-		swdev->ops = &mt7621_ops;
-	else
-		swdev->ops = &mt7530_ops;
-
-	ret = register_switch(swdev, NULL);
-	if (ret) {
-		dev_err(dev, "failed to register mt7530\n");
-		return ret;
-	}
-
-
-	map = mt7530_find_mapping(dev->of_node);
-	if (map)
-		mt7530_apply_mapping(mt7530, map);
-	mt7530_apply_config(swdev);
-
-	/* magic vodoo */
-	if (!IS_ENABLED(CONFIG_SOC_MT7621) && bus && mt7530_r32(mt7530, REG_HWTRAP) !=  0x1117edf) {
-		dev_info(dev, "fixing up MHWTRAP register - bootloader probably played with it\n");
-		mt7530_w32(mt7530, REG_HWTRAP, 0x1117edf);
-	}
-	dev_info(dev, "loaded %s driver\n", swdev->name);
-
-	return 0;
-}
diff --git a/drivers/net/ethernet/mediatek/mt7530.h b/drivers/net/ethernet/mediatek/mt7530.h
deleted file mode 100644
index cf725c2f2ba9..000000000000
--- a/drivers/net/ethernet/mediatek/mt7530.h
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * Copyright (C) 2013 John Crispin <blogic@openwrt.org>
- * Copyright (C) 2016 Vitaly Chekryzhev <13hakta@gmail.com>
- */
-
-#ifndef _MT7530_H__
-#define _MT7530_H__
-
-#define MT7620_MIB_COUNTER_BASE_PORT	0x4000
-#define MT7620_MIB_COUNTER_PORT_OFFSET	0x100
-#define MT7620_MIB_COUNTER_BASE	0x1010
-
-/* PPE Accounting Group #0 Byte Counter */
-#define MT7620_MIB_STATS_PPE_AC_BCNT0	0x000
-
-/* PPE Accounting Group #0 Packet Counter */
-#define MT7620_MIB_STATS_PPE_AC_PCNT0	0x004
-
-/* PPE Accounting Group #63 Byte Counter */
-#define MT7620_MIB_STATS_PPE_AC_BCNT63	0x1F8
-
-/* PPE Accounting Group #63 Packet Counter */
-#define MT7620_MIB_STATS_PPE_AC_PCNT63	0x1FC
-
-/* PPE Meter Group #0 */
-#define MT7620_MIB_STATS_PPE_MTR_CNT0	0x200
-
-/* PPE Meter Group #63 */
-#define MT7620_MIB_STATS_PPE_MTR_CNT63	0x2FC
-
-/* Transmit good byte count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_TX_GBCNT	0x300
-
-/* Transmit good packet count for CPU GDM (exclude flow control frames) */
-#define MT7620_MIB_STATS_GDM1_TX_GPCNT	0x304
-
-/* Transmit abort count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_TX_SKIPCNT	0x308
-
-/* Transmit collision count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_TX_COLCNT	0x30C
-
-/* Received good byte count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_GBCNT1	0x320
-
-/* Received good packet count for CPU GDM (exclude flow control frame) */
-#define MT7620_MIB_STATS_GDM1_RX_GPCNT1	0x324
-
-/* Received overflow error packet count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_OERCNT	0x328
-
-/* Received FCS error packet count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_FERCNT	0x32C
-
-/* Received too short error packet count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_SERCNT	0x330
-
-/* Received too long error packet count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_LERCNT	0x334
-
-/* Received IP/TCP/UDP checksum error packet count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_CERCNT	0x338
-
-/* Received flow control pkt count for CPU GDM */
-#define MT7620_MIB_STATS_GDM1_RX_FCCNT	0x33C
-
-/* Transmit good byte count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_TX_GBCNT	0x340
-
-/* Transmit good packet count for PPE GDM (exclude flow control frames) */
-#define MT7620_MIB_STATS_GDM2_TX_GPCNT	0x344
-
-/* Transmit abort count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_TX_SKIPCNT	0x348
-
-/* Transmit collision count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_TX_COLCNT	0x34C
-
-/* Received good byte count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_GBCNT	0x360
-
-/* Received good packet count for PPE GDM (exclude flow control frame) */
-#define MT7620_MIB_STATS_GDM2_RX_GPCNT	0x364
-
-/* Received overflow error packet count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_OERCNT	0x368
-
-/* Received FCS error packet count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_FERCNT	0x36C
-
-/* Received too short error packet count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_SERCNT	0x370
-
-/* Received too long error packet count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_LERCNT	0x374
-
-/* Received IP/TCP/UDP checksum error packet count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_CERCNT	0x378
-
-/* Received flow control pkt count for PPE GDM */
-#define MT7620_MIB_STATS_GDM2_RX_FCCNT	0x37C
-
-/* Tx Packet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_TGPCN	0x10
-
-/* Tx Bad Octet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_TBOCN	0x14
-
-/* Tx Good Octet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_TGOCN	0x18
-
-/* Tx Event Packet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_TEPCN	0x1C
-
-/* Rx Packet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_RGPCN	0x20
-
-/* Rx Bad Octet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_RBOCN	0x24
-
-/* Rx Good Octet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_RGOCN	0x28
-
-/* Rx Event Packet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_REPC1N	0x2C
-
-/* Rx Event Packet Counter of Port n */
-#define MT7620_MIB_STATS_PORT_REPC2N	0x30
-
-#define MT7621_MIB_COUNTER_BASE	0x4000
-#define MT7621_MIB_COUNTER_PORT_OFFSET	0x100
-#define MT7621_STATS_TDPC	0x00
-#define MT7621_STATS_TCRC	0x04
-#define MT7621_STATS_TUPC	0x08
-#define MT7621_STATS_TMPC	0x0C
-#define MT7621_STATS_TBPC	0x10
-#define MT7621_STATS_TCEC	0x14
-#define MT7621_STATS_TSCEC	0x18
-#define MT7621_STATS_TMCEC	0x1C
-#define MT7621_STATS_TDEC	0x20
-#define MT7621_STATS_TLCEC	0x24
-#define MT7621_STATS_TXCEC	0x28
-#define MT7621_STATS_TPPC	0x2C
-#define MT7621_STATS_TL64PC	0x30
-#define MT7621_STATS_TL65PC	0x34
-#define MT7621_STATS_TL128PC	0x38
-#define MT7621_STATS_TL256PC	0x3C
-#define MT7621_STATS_TL512PC	0x40
-#define MT7621_STATS_TL1024PC	0x44
-#define MT7621_STATS_TOC	0x48
-#define MT7621_STATS_RDPC	0x60
-#define MT7621_STATS_RFPC	0x64
-#define MT7621_STATS_RUPC	0x68
-#define MT7621_STATS_RMPC	0x6C
-#define MT7621_STATS_RBPC	0x70
-#define MT7621_STATS_RAEPC	0x74
-#define MT7621_STATS_RCEPC	0x78
-#define MT7621_STATS_RUSPC	0x7C
-#define MT7621_STATS_RFEPC	0x80
-#define MT7621_STATS_ROSPC	0x84
-#define MT7621_STATS_RJEPC	0x88
-#define MT7621_STATS_RPPC	0x8C
-#define MT7621_STATS_RL64PC	0x90
-#define MT7621_STATS_RL65PC	0x94
-#define MT7621_STATS_RL128PC	0x98
-#define MT7621_STATS_RL256PC	0x9C
-#define MT7621_STATS_RL512PC	0xA0
-#define MT7621_STATS_RL1024PC	0xA4
-#define MT7621_STATS_ROC	0xA8
-#define MT7621_STATS_RDPC_CTRL	0xB0
-#define MT7621_STATS_RDPC_ING	0xB4
-#define MT7621_STATS_RDPC_ARL	0xB8
-
-int mt7530_probe(struct device *dev, void __iomem *base, struct mii_bus *bus, int vlan);
-
-#endif
diff --git a/drivers/net/ethernet/mediatek/mtk_debugfs.c b/drivers/net/ethernet/mediatek/mtk_debugfs.c
deleted file mode 100644
index 2938119e891e..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_debugfs.c
+++ /dev/null
@@ -1,115 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2014-2016 Sean Wang <sean.wang@mediatek.com>
- *   Copyright (C) 2016-2017 John Crispin <blogic@openwrt.org>
- */
-
-#include "mtk_offload.h"
-
-static const char *mtk_foe_entry_state_str[] = {
-	"INVALID",
-	"UNBIND",
-	"BIND",
-	"FIN"
-};
-
-static const char *mtk_foe_packet_type_str[] = {
-	"IPV4_HNAPT",
-	"IPV4_HNAT",
-	"IPV6_1T_ROUTE",
-	"IPV4_DSLITE",
-	"IPV6_3T_ROUTE",
-	"IPV6_5T_ROUTE",
-	"IPV6_6RD",
-};
-
-#define IPV4_HNAPT                      0
-#define IPV4_HNAT                       1
-#define IS_IPV4_HNAPT(x)	(((x)->bfib1.pkt_type == IPV4_HNAPT) ? 1: 0)
-struct mtk_eth *_eth;
-#define es(entry)		(mtk_foe_entry_state_str[entry->bfib1.state])
-//#define ei(entry, end)		(MTK_PPE_TBL_SZ - (int)(end - entry))
-#define ei(entry, end)		(MTK_PPE_ENTRY_CNT - (int)(end - entry))
-#define pt(entry)		(mtk_foe_packet_type_str[entry->ipv4_hnapt.bfib1.pkt_type])
-
-static int mtk_ppe_debugfs_foe_show(struct seq_file *m, void *private)
-{
-	struct mtk_eth *eth = _eth;
-	struct mtk_foe_entry *entry, *end;
-	int i = 0;
-
-	entry = eth->foe_table;
-	end = eth->foe_table + MTK_PPE_ENTRY_CNT;
-
-	while (entry < end) {
-		if (IS_IPV4_HNAPT(entry)) {
-			__be32 saddr = htonl(entry->ipv4_hnapt.sip);
-			__be32 daddr = htonl(entry->ipv4_hnapt.dip);
-			__be32 nsaddr = htonl(entry->ipv4_hnapt.new_sip);
-			__be32 ndaddr = htonl(entry->ipv4_hnapt.new_dip);
-			unsigned char h_dest[ETH_ALEN];
-			unsigned char h_source[ETH_ALEN];
-
-			*((u32*) h_source) = swab32(entry->ipv4_hnapt.smac_hi);
-			*((u16*) &h_source[4]) = swab16(entry->ipv4_hnapt.smac_lo);
-			*((u32*) h_dest) = swab32(entry->ipv4_hnapt.dmac_hi);
-			*((u16*) &h_dest[4]) = swab16(entry->ipv4_hnapt.dmac_lo);
-			seq_printf(m,
-				   "(%x)0x%05x|state=%s|type=%s|"
-				   "%pI4:%d->%pI4:%d=>%pI4:%d->%pI4:%d|%pM=>%pM|"
-				   "etype=0x%04x|info1=0x%x|info2=0x%x|"
-				   "vlan1=%d|vlan2=%d\n",
-				   i,
-				   ei(entry, end), es(entry), pt(entry),
-				   &saddr, entry->ipv4_hnapt.sport,
-				   &daddr, entry->ipv4_hnapt.dport,
-				   &nsaddr, entry->ipv4_hnapt.new_sport,
-				   &ndaddr, entry->ipv4_hnapt.new_dport, h_source,
-				   h_dest, ntohs(entry->ipv4_hnapt.etype),
-				   entry->ipv4_hnapt.info_blk1,
-				   entry->ipv4_hnapt.info_blk2,
-				   entry->ipv4_hnapt.vlan1,
-				   entry->ipv4_hnapt.vlan2);
-		} else
-			seq_printf(m, "0x%05x state=%s\n",
-				   ei(entry, end), es(entry));
-		entry++;
-		i++;
-	}
-
-	return 0;
-}
-
-static int mtk_ppe_debugfs_foe_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, mtk_ppe_debugfs_foe_show, file->private_data);
-}
-
-static const struct file_operations mtk_ppe_debugfs_foe_fops = {
-	.open = mtk_ppe_debugfs_foe_open,
-	.read = seq_read,
-	.llseek = seq_lseek,
-	.release = single_release,
-};
-
-int mtk_ppe_debugfs_init(struct mtk_eth *eth)
-{
-	struct dentry *root;
-
-	_eth = eth;
-
-	root = debugfs_create_dir("mtk_ppe", NULL);
-	if (!root)
-		return -ENOMEM;
-
-	debugfs_create_file("all_entry", S_IRUGO, root, eth, &mtk_ppe_debugfs_foe_fops);
-
-	return 0;
-}
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
index 8bf17f629c2f..b5f3241d48b0 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -7,902 +7,1035 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+ *   Copyright (C) 2009-2016 John Crispin <blogic@openwrt.org>
+ *   Copyright (C) 2009-2016 Felix Fietkau <nbd@openwrt.org>
+ *   Copyright (C) 2013-2016 Michael Lee <igvtee@gmail.com>
  */
 
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/dma-mapping.h>
-#include <linux/init.h>
-#include <linux/skbuff.h>
-#include <linux/etherdevice.h>
-#include <linux/ethtool.h>
-#include <linux/platform_device.h>
 #include <linux/of_device.h>
-#include <linux/clk.h>
-#include <linux/of_net.h>
 #include <linux/of_mdio.h>
+#include <linux/of_net.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include <linux/clk.h>
+#include <linux/pm_runtime.h>
 #include <linux/if_vlan.h>
 #include <linux/reset.h>
 #include <linux/tcp.h>
-#include <linux/io.h>
-#include <linux/bug.h>
-#include <linux/netfilter.h>
-#include <net/netfilter/nf_flow_table.h>
-
-#include <asm/mach-ralink/ralink_regs.h>
+#include <linux/interrupt.h>
 
 #include "mtk_eth_soc.h"
-#include "mdio.h"
-#include "ethtool.h"
-
-#define	MAX_RX_LENGTH		1536
-#define FE_RX_ETH_HLEN		(VLAN_ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN)
-#define FE_RX_HLEN		(NET_SKB_PAD + FE_RX_ETH_HLEN + NET_IP_ALIGN)
-#define DMA_DUMMY_DESC		0xffffffff
-#define FE_DEFAULT_MSG_ENABLE \
-		(NETIF_MSG_DRV | \
-		NETIF_MSG_PROBE | \
-		NETIF_MSG_LINK | \
-		NETIF_MSG_TIMER | \
-		NETIF_MSG_IFDOWN | \
-		NETIF_MSG_IFUP | \
-		NETIF_MSG_RX_ERR | \
-		NETIF_MSG_TX_ERR)
-
-#define TX_DMA_DESP2_DEF	(TX_DMA_LS0 | TX_DMA_DONE)
-#define TX_DMA_DESP4_DEF	(TX_DMA_QN(3) | TX_DMA_PN(1))
-#define NEXT_TX_DESP_IDX(X)	(((X) + 1) & (ring->tx_ring_size - 1))
-#define NEXT_RX_DESP_IDX(X)	(((X) + 1) & (ring->rx_ring_size - 1))
-
-#define SYSC_REG_RSTCTRL	0x34
-
-static int fe_msg_level = -1;
-module_param_named(msg_level, fe_msg_level, int, 0);
+
+static int mtk_msg_level = -1;
+module_param_named(msg_level, mtk_msg_level, int, 0);
 MODULE_PARM_DESC(msg_level, "Message level (-1=defaults,0=none,...,16=all)");
 
-static const u16 fe_reg_table_default[FE_REG_COUNT] = {
-	[FE_REG_PDMA_GLO_CFG] = FE_PDMA_GLO_CFG,
-	[FE_REG_PDMA_RST_CFG] = FE_PDMA_RST_CFG,
-	[FE_REG_DLY_INT_CFG] = FE_DLY_INT_CFG,
-	[FE_REG_TX_BASE_PTR0] = FE_TX_BASE_PTR0,
-	[FE_REG_TX_MAX_CNT0] = FE_TX_MAX_CNT0,
-	[FE_REG_TX_CTX_IDX0] = FE_TX_CTX_IDX0,
-	[FE_REG_TX_DTX_IDX0] = FE_TX_DTX_IDX0,
-	[FE_REG_RX_BASE_PTR0] = FE_RX_BASE_PTR0,
-	[FE_REG_RX_MAX_CNT0] = FE_RX_MAX_CNT0,
-	[FE_REG_RX_CALC_IDX0] = FE_RX_CALC_IDX0,
-	[FE_REG_RX_DRX_IDX0] = FE_RX_DRX_IDX0,
-	[FE_REG_FE_INT_ENABLE] = FE_FE_INT_ENABLE,
-	[FE_REG_FE_INT_STATUS] = FE_FE_INT_STATUS,
-	[FE_REG_FE_DMA_VID_BASE] = FE_DMA_VID0,
-	[FE_REG_FE_COUNTER_BASE] = FE_GDMA1_TX_GBCNT,
-	[FE_REG_FE_RST_GL] = FE_FE_RST_GL,
+#define MTK_ETHTOOL_STAT(x) { #x, \
+			      offsetof(struct mtk_hw_stats, x) / sizeof(u64) }
+
+/* strings used by ethtool */
+static const struct mtk_ethtool_stats {
+	char str[ETH_GSTRING_LEN];
+	u32 offset;
+} mtk_ethtool_stats[] = {
+	MTK_ETHTOOL_STAT(tx_bytes),
+	MTK_ETHTOOL_STAT(tx_packets),
+	MTK_ETHTOOL_STAT(tx_skip),
+	MTK_ETHTOOL_STAT(tx_collisions),
+	MTK_ETHTOOL_STAT(rx_bytes),
+	MTK_ETHTOOL_STAT(rx_packets),
+	MTK_ETHTOOL_STAT(rx_overflow),
+	MTK_ETHTOOL_STAT(rx_fcs_errors),
+	MTK_ETHTOOL_STAT(rx_short_errors),
+	MTK_ETHTOOL_STAT(rx_long_errors),
+	MTK_ETHTOOL_STAT(rx_checksum_errors),
+	MTK_ETHTOOL_STAT(rx_flow_control_packets),
 };
 
-static const u16 *fe_reg_table = fe_reg_table_default;
-
-struct fe_work_t {
-	int bitnr;
-	void (*action)(struct fe_priv *);
+static const char * const mtk_clks_source_name[] = {
+	"ethif", "esw", "gp0", "gp1", "gp2", "trgpll", "sgmii_tx250m",
+	"sgmii_rx250m", "sgmii_cdr_ref", "sgmii_cdr_fb", "sgmii_ck", "eth2pll"
 };
 
-static void __iomem *fe_base;
-
-void fe_w32(u32 val, unsigned reg)
+void mtk_w32(struct mtk_eth *eth, u32 val, unsigned reg)
 {
-	__raw_writel(val, fe_base + reg);
+	__raw_writel(val, eth->base + reg);
 }
 
-u32 fe_r32(unsigned reg)
+u32 mtk_r32(struct mtk_eth *eth, unsigned reg)
 {
-	return __raw_readl(fe_base + reg);
+	return __raw_readl(eth->base + reg);
 }
 
-void fe_reg_w32(u32 val, enum fe_reg reg)
+static int mtk_mdio_busy_wait(struct mtk_eth *eth)
 {
-	fe_w32(val, fe_reg_table[reg]);
-}
+	unsigned long t_start = jiffies;
 
-u32 fe_reg_r32(enum fe_reg reg)
-{
-	return fe_r32(fe_reg_table[reg]);
+	while (1) {
+		if (!(mtk_r32(eth, MTK_PHY_IAC) & PHY_IAC_ACCESS))
+			return 0;
+		if (time_after(jiffies, t_start + PHY_IAC_TIMEOUT))
+			break;
+		if (in_atomic())
+			udelay(10);
+		else
+			usleep_range(10, 20);
+	}
+
+	dev_err(eth->dev, "mdio: MDIO timeout\n");
+	return -1;
 }
 
-void fe_m32(struct fe_priv *eth, u32 clear, u32 set, unsigned reg)
+static u32 _mtk_mdio_write(struct mtk_eth *eth, u32 phy_addr,
+			   u32 phy_register, u32 write_data)
 {
-	u32 val;
+	if (mtk_mdio_busy_wait(eth))
+		return -1;
 
-	spin_lock(&eth->page_lock);
-	val = __raw_readl(fe_base + reg);
-	val &= ~clear;
-	val |= set;
-	__raw_writel(val, fe_base + reg);
-	spin_unlock(&eth->page_lock);
+	write_data &= 0xffff;
+
+	mtk_w32(eth, PHY_IAC_ACCESS | PHY_IAC_START | PHY_IAC_WRITE |
+		(phy_register << PHY_IAC_REG_SHIFT) |
+		(phy_addr << PHY_IAC_ADDR_SHIFT) | write_data,
+		MTK_PHY_IAC);
+
+	if (mtk_mdio_busy_wait(eth))
+		return -1;
+
+	return 0;
 }
 
-void fe_reset(u32 reset_bits)
+static u32 _mtk_mdio_read(struct mtk_eth *eth, int phy_addr, int phy_reg)
 {
-	u32 t;
+	u32 d;
+
+	if (mtk_mdio_busy_wait(eth))
+		return 0xffff;
+
+	mtk_w32(eth, PHY_IAC_ACCESS | PHY_IAC_START | PHY_IAC_READ |
+		(phy_reg << PHY_IAC_REG_SHIFT) |
+		(phy_addr << PHY_IAC_ADDR_SHIFT),
+		MTK_PHY_IAC);
 
-	t = rt_sysc_r32(SYSC_REG_RSTCTRL);
-	t |= reset_bits;
-	rt_sysc_w32(t, SYSC_REG_RSTCTRL);
-	usleep_range(10, 20);
+	if (mtk_mdio_busy_wait(eth))
+		return 0xffff;
 
-	t &= ~reset_bits;
-	rt_sysc_w32(t, SYSC_REG_RSTCTRL);
-	usleep_range(10, 20);
+	d = mtk_r32(eth, MTK_PHY_IAC) & 0xffff;
+
+	return d;
 }
 
-static inline void fe_int_disable(u32 mask)
+static int mtk_mdio_write(struct mii_bus *bus, int phy_addr,
+			  int phy_reg, u16 val)
 {
-	fe_reg_w32(fe_reg_r32(FE_REG_FE_INT_ENABLE) & ~mask,
-		   FE_REG_FE_INT_ENABLE);
-	/* flush write */
-	fe_reg_r32(FE_REG_FE_INT_ENABLE);
+	struct mtk_eth *eth = bus->priv;
+
+	return _mtk_mdio_write(eth, phy_addr, phy_reg, val);
 }
 
-static inline void fe_int_enable(u32 mask)
+static int mtk_mdio_read(struct mii_bus *bus, int phy_addr, int phy_reg)
 {
-	fe_reg_w32(fe_reg_r32(FE_REG_FE_INT_ENABLE) | mask,
-		   FE_REG_FE_INT_ENABLE);
-	/* flush write */
-	fe_reg_r32(FE_REG_FE_INT_ENABLE);
+	struct mtk_eth *eth = bus->priv;
+
+	return _mtk_mdio_read(eth, phy_addr, phy_reg);
 }
 
-static inline void fe_hw_set_macaddr(struct fe_priv *priv, unsigned char *mac)
+static void mtk_gmac0_rgmii_adjust(struct mtk_eth *eth, int speed)
 {
-	unsigned long flags;
+	u32 val;
+	int ret;
+
+	val = (speed == SPEED_1000) ?
+		INTF_MODE_RGMII_1000 : INTF_MODE_RGMII_10_100;
+	mtk_w32(eth, val, INTF_MODE);
+
+	regmap_update_bits(eth->ethsys, ETHSYS_CLKCFG0,
+			   ETHSYS_TRGMII_CLK_SEL362_5,
+			   ETHSYS_TRGMII_CLK_SEL362_5);
 
-	spin_lock_irqsave(&priv->page_lock, flags);
-	fe_w32((mac[0] << 8) | mac[1], FE_GDMA1_MAC_ADRH);
-	fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
-	       FE_GDMA1_MAC_ADRL);
-	spin_unlock_irqrestore(&priv->page_lock, flags);
+	val = (speed == SPEED_1000) ? 250000000 : 500000000;
+	ret = clk_set_rate(eth->clks[MTK_CLK_TRGPLL], val);
+	if (ret)
+		dev_err(eth->dev, "Failed to set trgmii pll: %d\n", ret);
+
+	val = (speed == SPEED_1000) ?
+		RCK_CTRL_RGMII_1000 : RCK_CTRL_RGMII_10_100;
+	mtk_w32(eth, val, TRGMII_RCK_CTRL);
+
+	val = (speed == SPEED_1000) ?
+		TCK_CTRL_RGMII_1000 : TCK_CTRL_RGMII_10_100;
+	mtk_w32(eth, val, TRGMII_TCK_CTRL);
 }
 
-static int fe_set_mac_address(struct net_device *dev, void *p)
+static void mtk_gmac_sgmii_hw_setup(struct mtk_eth *eth, int mac_id)
 {
-	int ret = eth_mac_addr(dev, p);
+	u32 val;
 
-	if (!ret) {
-		struct fe_priv *priv = netdev_priv(dev);
+	/* Setup the link timer and QPHY power up inside SGMIISYS */
+	regmap_write(eth->sgmiisys, SGMSYS_PCS_LINK_TIMER,
+		     SGMII_LINK_TIMER_DEFAULT);
 
-		if (priv->soc->set_mac)
-			priv->soc->set_mac(priv, dev->dev_addr);
-		else
-			fe_hw_set_macaddr(priv, p);
+	regmap_read(eth->sgmiisys, SGMSYS_SGMII_MODE, &val);
+	val |= SGMII_REMOTE_FAULT_DIS;
+	regmap_write(eth->sgmiisys, SGMSYS_SGMII_MODE, val);
+
+	regmap_read(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, &val);
+	val |= SGMII_AN_RESTART;
+	regmap_write(eth->sgmiisys, SGMSYS_PCS_CONTROL_1, val);
+
+	regmap_read(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, &val);
+	val &= ~SGMII_PHYA_PWD;
+	regmap_write(eth->sgmiisys, SGMSYS_QPHY_PWR_STATE_CTRL, val);
+
+	/* Determine MUX for which GMAC uses the SGMII interface */
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_DUAL_GMAC_SHARED_SGMII)) {
+		regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
+		val &= ~SYSCFG0_SGMII_MASK;
+		val |= !mac_id ? SYSCFG0_SGMII_GMAC1 : SYSCFG0_SGMII_GMAC2;
+		regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
+
+		dev_info(eth->dev, "setup shared sgmii for gmac=%d\n",
+			 mac_id);
 	}
 
-	return ret;
+	/* Setup the GMAC1 going through SGMII path when SoC also support
+	 * ESW on GMAC1
+	 */
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_GMAC1_ESW | MTK_GMAC1_SGMII) &&
+	    !mac_id) {
+		mtk_w32(eth, 0, MTK_MAC_MISC);
+		dev_info(eth->dev, "setup gmac1 going through sgmii");
+	}
 }
 
-static inline int fe_max_frag_size(int mtu)
+static void mtk_phy_link_adjust(struct net_device *dev)
 {
-	/* make sure buf_size will be at least MAX_RX_LENGTH */
-	if (mtu + FE_RX_ETH_HLEN < MAX_RX_LENGTH)
-		mtu = MAX_RX_LENGTH - FE_RX_ETH_HLEN;
+	struct mtk_mac *mac = netdev_priv(dev);
+	u16 lcl_adv = 0, rmt_adv = 0;
+	u8 flowctrl;
+	u32 mcr = MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG |
+		  MAC_MCR_FORCE_MODE | MAC_MCR_TX_EN |
+		  MAC_MCR_RX_EN | MAC_MCR_BACKOFF_EN |
+		  MAC_MCR_BACKPR_EN;
+
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return;
 
-	return SKB_DATA_ALIGN(FE_RX_HLEN + mtu) +
-		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
-}
+	switch (dev->phydev->speed) {
+	case SPEED_1000:
+		mcr |= MAC_MCR_SPEED_1000;
+		break;
+	case SPEED_100:
+		mcr |= MAC_MCR_SPEED_100;
+		break;
+	};
 
-static inline int fe_max_buf_size(int frag_size)
-{
-	int buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -
-		       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
+	if (MTK_HAS_CAPS(mac->hw->soc->caps, MTK_GMAC1_TRGMII) &&
+	    !mac->id && !mac->trgmii)
+		mtk_gmac0_rgmii_adjust(mac->hw, dev->phydev->speed);
 
-	BUG_ON(buf_size < MAX_RX_LENGTH);
-	return buf_size;
-}
+	if (dev->phydev->link)
+		mcr |= MAC_MCR_FORCE_LINK;
 
-static inline void fe_get_rxd(struct fe_rx_dma *rxd, struct fe_rx_dma *dma_rxd)
-{
-	rxd->rxd1 = dma_rxd->rxd1;
-	rxd->rxd2 = dma_rxd->rxd2;
-	rxd->rxd3 = dma_rxd->rxd3;
-	rxd->rxd4 = dma_rxd->rxd4;
-}
+	if (dev->phydev->duplex) {
+		mcr |= MAC_MCR_FORCE_DPX;
 
-static inline void fe_set_txd(struct fe_tx_dma *txd, struct fe_tx_dma *dma_txd)
-{
-	dma_txd->txd1 = txd->txd1;
-	dma_txd->txd3 = txd->txd3;
-	dma_txd->txd4 = txd->txd4;
-	/* clean dma done flag last */
-	dma_txd->txd2 = txd->txd2;
-}
+		if (dev->phydev->pause)
+			rmt_adv = LPA_PAUSE_CAP;
+		if (dev->phydev->asym_pause)
+			rmt_adv |= LPA_PAUSE_ASYM;
 
-static void fe_clean_rx(struct fe_priv *priv)
-{
-	struct fe_rx_ring *ring = &priv->rx_ring;
-	struct page *page;
-	int i;
+		if (dev->phydev->advertising & ADVERTISED_Pause)
+			lcl_adv |= ADVERTISE_PAUSE_CAP;
+		if (dev->phydev->advertising & ADVERTISED_Asym_Pause)
+			lcl_adv |= ADVERTISE_PAUSE_ASYM;
 
-	if (ring->rx_data) {
-		for (i = 0; i < ring->rx_ring_size; i++)
-			if (ring->rx_data[i]) {
-				if (ring->rx_dma && ring->rx_dma[i].rxd1)
-					dma_unmap_single(&priv->netdev->dev,
-							 ring->rx_dma[i].rxd1,
-							 ring->rx_buf_size,
-							 DMA_FROM_DEVICE);
-				skb_free_frag(ring->rx_data[i]);
-			}
+		flowctrl = mii_resolve_flowctrl_fdx(lcl_adv, rmt_adv);
 
-		kfree(ring->rx_data);
-		ring->rx_data = NULL;
-	}
+		if (flowctrl & FLOW_CTRL_TX)
+			mcr |= MAC_MCR_FORCE_TX_FC;
+		if (flowctrl & FLOW_CTRL_RX)
+			mcr |= MAC_MCR_FORCE_RX_FC;
 
-	if (ring->rx_dma) {
-		dma_free_coherent(&priv->netdev->dev,
-				  ring->rx_ring_size * sizeof(*ring->rx_dma),
-				  ring->rx_dma,
-				  ring->rx_phys);
-		ring->rx_dma = NULL;
+		netif_dbg(mac->hw, link, dev, "rx pause %s, tx pause %s\n",
+			  flowctrl & FLOW_CTRL_RX ? "enabled" : "disabled",
+			  flowctrl & FLOW_CTRL_TX ? "enabled" : "disabled");
 	}
 
-	if (!ring->frag_cache.va)
-	    return;
+	mtk_w32(mac->hw, mcr, MTK_MAC_MCR(mac->id));
+
+	if (dev->phydev->link)
+		netif_carrier_on(dev);
+	else
+		netif_carrier_off(dev);
 
-	page = virt_to_page(ring->frag_cache.va);
-	__page_frag_cache_drain(page, ring->frag_cache.pagecnt_bias);
-	memset(&ring->frag_cache, 0, sizeof(ring->frag_cache));
+	if (!of_phy_is_fixed_link(mac->of_node))
+		phy_print_status(dev->phydev);
 }
 
-static int fe_alloc_rx(struct fe_priv *priv)
+static int mtk_phy_connect_node(struct mtk_eth *eth, struct mtk_mac *mac,
+				struct device_node *phy_node)
 {
-	struct net_device *netdev = priv->netdev;
-	struct fe_rx_ring *ring = &priv->rx_ring;
-	int i, pad;
+	struct phy_device *phydev;
+	int phy_mode;
 
-	ring->rx_data = kcalloc(ring->rx_ring_size, sizeof(*ring->rx_data),
-			GFP_KERNEL);
-	if (!ring->rx_data)
-		goto no_rx_mem;
+	phy_mode = of_get_phy_mode(phy_node);
+	if (phy_mode < 0) {
+		dev_err(eth->dev, "incorrect phy-mode %d\n", phy_mode);
+		return -EINVAL;
+	}
 
-	for (i = 0; i < ring->rx_ring_size; i++) {
-		ring->rx_data[i] = page_frag_alloc(&ring->frag_cache,
-						   ring->frag_size,
-						   GFP_KERNEL);
-		if (!ring->rx_data[i])
-			goto no_rx_mem;
+	phydev = of_phy_connect(eth->netdev[mac->id], phy_node,
+				mtk_phy_link_adjust, 0, phy_mode);
+	if (!phydev) {
+		dev_err(eth->dev, "could not connect to PHY\n");
+		return -ENODEV;
 	}
 
-	ring->rx_dma = dma_alloc_coherent(&netdev->dev,
-			ring->rx_ring_size * sizeof(*ring->rx_dma),
-			&ring->rx_phys,
-			GFP_ATOMIC | __GFP_ZERO);
-	if (!ring->rx_dma)
-		goto no_rx_mem;
+	dev_info(eth->dev,
+		 "connected mac %d to PHY at %s [uid=%08x, driver=%s]\n",
+		 mac->id, phydev_name(phydev), phydev->phy_id,
+		 phydev->drv->name);
 
-	if (priv->flags & FE_FLAG_RX_2B_OFFSET)
-		pad = 0;
-	else
-		pad = NET_IP_ALIGN;
-	for (i = 0; i < ring->rx_ring_size; i++) {
-		dma_addr_t dma_addr = dma_map_single(&netdev->dev,
-				ring->rx_data[i] + NET_SKB_PAD + pad,
-				ring->rx_buf_size,
-				DMA_FROM_DEVICE);
-		if (unlikely(dma_mapping_error(&netdev->dev, dma_addr)))
-			goto no_rx_mem;
-		ring->rx_dma[i].rxd1 = (unsigned int)dma_addr;
+	return 0;
+}
 
-		if (priv->flags & FE_FLAG_RX_SG_DMA)
-			ring->rx_dma[i].rxd2 = RX_DMA_PLEN0(ring->rx_buf_size);
-		else
-			ring->rx_dma[i].rxd2 = RX_DMA_LSO;
+static int mtk_phy_connect(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth;
+	struct device_node *np;
+	u32 val;
+
+	eth = mac->hw;
+	np = of_parse_phandle(mac->of_node, "phy-handle", 0);
+	if (!np && of_phy_is_fixed_link(mac->of_node))
+		if (!of_phy_register_fixed_link(mac->of_node))
+			np = of_node_get(mac->of_node);
+	if (!np)
+		return -ENODEV;
+
+	mac->ge_mode = 0;
+	switch (of_get_phy_mode(np)) {
+	case PHY_INTERFACE_MODE_TRGMII:
+		mac->trgmii = true;
+	case PHY_INTERFACE_MODE_RGMII_TXID:
+	case PHY_INTERFACE_MODE_RGMII_RXID:
+	case PHY_INTERFACE_MODE_RGMII_ID:
+	case PHY_INTERFACE_MODE_RGMII:
+		break;
+	case PHY_INTERFACE_MODE_SGMII:
+		if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII))
+			mtk_gmac_sgmii_hw_setup(eth, mac->id);
+		break;
+	case PHY_INTERFACE_MODE_MII:
+		mac->ge_mode = 1;
+		break;
+	case PHY_INTERFACE_MODE_REVMII:
+		mac->ge_mode = 2;
+		break;
+	case PHY_INTERFACE_MODE_RMII:
+		if (!mac->id)
+			goto err_phy;
+		mac->ge_mode = 3;
+		break;
+	default:
+		goto err_phy;
 	}
-	ring->rx_calc_idx = ring->rx_ring_size - 1;
-	/* make sure that all changes to the dma ring are flushed before we
-	 * continue
-	 */
-	wmb();
 
-	fe_reg_w32(ring->rx_phys, FE_REG_RX_BASE_PTR0);
-	fe_reg_w32(ring->rx_ring_size, FE_REG_RX_MAX_CNT0);
-	fe_reg_w32(ring->rx_calc_idx, FE_REG_RX_CALC_IDX0);
-	fe_reg_w32(FE_PST_DRX_IDX0, FE_REG_PDMA_RST_CFG);
+	/* put the gmac into the right mode */
+	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
+	val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, mac->id);
+	val |= SYSCFG0_GE_MODE(mac->ge_mode, mac->id);
+	regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
 
-	return 0;
+	/* couple phydev to net_device */
+	if (mtk_phy_connect_node(eth, mac, np))
+		goto err_phy;
 
-no_rx_mem:
-	return -ENOMEM;
-}
+	dev->phydev->autoneg = AUTONEG_ENABLE;
+	dev->phydev->speed = 0;
+	dev->phydev->duplex = 0;
 
-static void fe_txd_unmap(struct device *dev, struct fe_tx_buf *tx_buf)
-{
-	if (dma_unmap_len(tx_buf, dma_len0))
-		dma_unmap_page(dev,
-			       dma_unmap_addr(tx_buf, dma_addr0),
-			       dma_unmap_len(tx_buf, dma_len0),
-			       DMA_TO_DEVICE);
+	if (of_phy_is_fixed_link(mac->of_node))
+		dev->phydev->supported |=
+		SUPPORTED_Pause | SUPPORTED_Asym_Pause;
 
-	if (dma_unmap_len(tx_buf, dma_len1))
-		dma_unmap_page(dev,
-			       dma_unmap_addr(tx_buf, dma_addr1),
-			       dma_unmap_len(tx_buf, dma_len1),
-			       DMA_TO_DEVICE);
+	dev->phydev->supported &= PHY_GBIT_FEATURES | SUPPORTED_Pause |
+				   SUPPORTED_Asym_Pause;
+	dev->phydev->advertising = dev->phydev->supported |
+				    ADVERTISED_Autoneg;
+	phy_start_aneg(dev->phydev);
 
-	dma_unmap_len_set(tx_buf, dma_addr0, 0);
-	dma_unmap_len_set(tx_buf, dma_addr1, 0);
-	if (tx_buf->skb && (tx_buf->skb != (struct sk_buff *)DMA_DUMMY_DESC))
-		dev_kfree_skb_any(tx_buf->skb);
-	tx_buf->skb = NULL;
+	of_node_put(np);
+
+	return 0;
+
+err_phy:
+	if (of_phy_is_fixed_link(mac->of_node))
+		of_phy_deregister_fixed_link(mac->of_node);
+	of_node_put(np);
+	dev_err(eth->dev, "%s: invalid phy\n", __func__);
+	return -EINVAL;
 }
 
-static void fe_clean_tx(struct fe_priv *priv)
+static int mtk_mdio_init(struct mtk_eth *eth)
 {
-	int i;
-	struct device *dev = &priv->netdev->dev;
-	struct fe_tx_ring *ring = &priv->tx_ring;
+	struct device_node *mii_np;
+	int ret;
+
+	mii_np = of_get_child_by_name(eth->dev->of_node, "mdio-bus");
+	if (!mii_np) {
+		dev_err(eth->dev, "no %s child node found", "mdio-bus");
+		return -ENODEV;
+	}
 
-	if (ring->tx_buf) {
-		for (i = 0; i < ring->tx_ring_size; i++)
-			fe_txd_unmap(dev, &ring->tx_buf[i]);
-		kfree(ring->tx_buf);
-		ring->tx_buf = NULL;
+	if (!of_device_is_available(mii_np)) {
+		ret = -ENODEV;
+		goto err_put_node;
 	}
 
-	if (ring->tx_dma) {
-		dma_free_coherent(dev,
-				  ring->tx_ring_size * sizeof(*ring->tx_dma),
-				  ring->tx_dma,
-				  ring->tx_phys);
-		ring->tx_dma = NULL;
+	eth->mii_bus = devm_mdiobus_alloc(eth->dev);
+	if (!eth->mii_bus) {
+		ret = -ENOMEM;
+		goto err_put_node;
 	}
 
-	netdev_reset_queue(priv->netdev);
+	eth->mii_bus->name = "mdio";
+	eth->mii_bus->read = mtk_mdio_read;
+	eth->mii_bus->write = mtk_mdio_write;
+	eth->mii_bus->priv = eth;
+	eth->mii_bus->parent = eth->dev;
+
+	snprintf(eth->mii_bus->id, MII_BUS_ID_SIZE, "%s", mii_np->name);
+	ret = of_mdiobus_register(eth->mii_bus, mii_np);
+printk("%s:%s[%d]%d %p\n", __FILE__, __func__, __LINE__, ret, eth->mii_bus);
+
+err_put_node:
+	of_node_put(mii_np);
+	return ret;
 }
 
-static int fe_alloc_tx(struct fe_priv *priv)
+static void mtk_mdio_cleanup(struct mtk_eth *eth)
 {
-	int i;
-	struct fe_tx_ring *ring = &priv->tx_ring;
+	if (!eth->mii_bus)
+		return;
 
-	ring->tx_free_idx = 0;
-	ring->tx_next_idx = 0;
-	ring->tx_thresh = max((unsigned long)ring->tx_ring_size >> 2,
-			      MAX_SKB_FRAGS);
+	mdiobus_unregister(eth->mii_bus);
+}
 
-	ring->tx_buf = kcalloc(ring->tx_ring_size, sizeof(*ring->tx_buf),
-			GFP_KERNEL);
-	if (!ring->tx_buf)
-		goto no_tx_mem;
+static inline void mtk_tx_irq_disable(struct mtk_eth *eth, u32 mask)
+{
+	unsigned long flags;
+	u32 val;
 
-	ring->tx_dma = dma_alloc_coherent(&priv->netdev->dev,
-			ring->tx_ring_size * sizeof(*ring->tx_dma),
-			&ring->tx_phys,
-			GFP_ATOMIC | __GFP_ZERO);
-	if (!ring->tx_dma)
-		goto no_tx_mem;
+	spin_lock_irqsave(&eth->tx_irq_lock, flags);
+	val = mtk_r32(eth, MTK_QDMA_INT_MASK);
+	mtk_w32(eth, val & ~mask, MTK_QDMA_INT_MASK);
+	spin_unlock_irqrestore(&eth->tx_irq_lock, flags);
+}
 
-	for (i = 0; i < ring->tx_ring_size; i++) {
-		if (priv->soc->tx_dma)
-			priv->soc->tx_dma(&ring->tx_dma[i]);
-		ring->tx_dma[i].txd2 = TX_DMA_DESP2_DEF;
-	}
-	/* make sure that all changes to the dma ring are flushed before we
-	 * continue
-	 */
-	wmb();
+static inline void mtk_tx_irq_enable(struct mtk_eth *eth, u32 mask)
+{
+	unsigned long flags;
+	u32 val;
 
-	fe_reg_w32(ring->tx_phys, FE_REG_TX_BASE_PTR0);
-	fe_reg_w32(ring->tx_ring_size, FE_REG_TX_MAX_CNT0);
-	fe_reg_w32(0, FE_REG_TX_CTX_IDX0);
-	fe_reg_w32(FE_PST_DTX_IDX0, FE_REG_PDMA_RST_CFG);
+	spin_lock_irqsave(&eth->tx_irq_lock, flags);
+	val = mtk_r32(eth, MTK_QDMA_INT_MASK);
+	mtk_w32(eth, val | mask, MTK_QDMA_INT_MASK);
+	spin_unlock_irqrestore(&eth->tx_irq_lock, flags);
+}
 
-	return 0;
+static inline void mtk_rx_irq_disable(struct mtk_eth *eth, u32 mask)
+{
+	unsigned long flags;
+	u32 val;
 
-no_tx_mem:
-	return -ENOMEM;
+	spin_lock_irqsave(&eth->rx_irq_lock, flags);
+	val = mtk_r32(eth, MTK_PDMA_INT_MASK);
+	mtk_w32(eth, val & ~mask, MTK_PDMA_INT_MASK);
+	spin_unlock_irqrestore(&eth->rx_irq_lock, flags);
 }
 
-static int fe_init_dma(struct fe_priv *priv)
+static inline void mtk_rx_irq_enable(struct mtk_eth *eth, u32 mask)
 {
-	int err;
+	unsigned long flags;
+	u32 val;
 
-	err = fe_alloc_tx(priv);
-	if (err)
-		return err;
+	spin_lock_irqsave(&eth->rx_irq_lock, flags);
+	val = mtk_r32(eth, MTK_PDMA_INT_MASK);
+	mtk_w32(eth, val | mask, MTK_PDMA_INT_MASK);
+	spin_unlock_irqrestore(&eth->rx_irq_lock, flags);
+}
 
-	err = fe_alloc_rx(priv);
-	if (err)
-		return err;
+static int mtk_set_mac_address(struct net_device *dev, void *p)
+{
+	int ret = eth_mac_addr(dev, p);
+	struct mtk_mac *mac = netdev_priv(dev);
+	const char *macaddr = dev->dev_addr;
+
+	if (ret)
+		return ret;
+
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return -EBUSY;
+
+	spin_lock_bh(&mac->hw->page_lock);
+	mtk_w32(mac->hw, (macaddr[0] << 8) | macaddr[1],
+		MTK_GDMA_MAC_ADRH(mac->id));
+	mtk_w32(mac->hw, (macaddr[2] << 24) | (macaddr[3] << 16) |
+		(macaddr[4] << 8) | macaddr[5],
+		MTK_GDMA_MAC_ADRL(mac->id));
+	spin_unlock_bh(&mac->hw->page_lock);
 
 	return 0;
 }
 
-static void fe_free_dma(struct fe_priv *priv)
+void mtk_stats_update_mac(struct mtk_mac *mac)
 {
-	fe_clean_tx(priv);
-	fe_clean_rx(priv);
+	struct mtk_hw_stats *hw_stats = mac->hw_stats;
+	unsigned int base = MTK_GDM1_TX_GBCNT;
+	u64 stats;
+
+	base += hw_stats->reg_offset;
+
+	u64_stats_update_begin(&hw_stats->syncp);
+
+	hw_stats->rx_bytes += mtk_r32(mac->hw, base);
+	stats =  mtk_r32(mac->hw, base + 0x04);
+	if (stats)
+		hw_stats->rx_bytes += (stats << 32);
+	hw_stats->rx_packets += mtk_r32(mac->hw, base + 0x08);
+	hw_stats->rx_overflow += mtk_r32(mac->hw, base + 0x10);
+	hw_stats->rx_fcs_errors += mtk_r32(mac->hw, base + 0x14);
+	hw_stats->rx_short_errors += mtk_r32(mac->hw, base + 0x18);
+	hw_stats->rx_long_errors += mtk_r32(mac->hw, base + 0x1c);
+	hw_stats->rx_checksum_errors += mtk_r32(mac->hw, base + 0x20);
+	hw_stats->rx_flow_control_packets +=
+					mtk_r32(mac->hw, base + 0x24);
+	hw_stats->tx_skip += mtk_r32(mac->hw, base + 0x28);
+	hw_stats->tx_collisions += mtk_r32(mac->hw, base + 0x2c);
+	hw_stats->tx_bytes += mtk_r32(mac->hw, base + 0x30);
+	stats =  mtk_r32(mac->hw, base + 0x34);
+	if (stats)
+		hw_stats->tx_bytes += (stats << 32);
+	hw_stats->tx_packets += mtk_r32(mac->hw, base + 0x38);
+	u64_stats_update_end(&hw_stats->syncp);
 }
 
-void fe_stats_update(struct fe_priv *priv)
+static void mtk_stats_update(struct mtk_eth *eth)
 {
-	struct fe_hw_stats *hwstats = priv->hw_stats;
-	unsigned int base = fe_reg_table[FE_REG_FE_COUNTER_BASE];
-	u64 stats;
+	int i;
 
-	u64_stats_update_begin(&hwstats->syncp);
-
-	if (IS_ENABLED(CONFIG_SOC_MT7621)) {
-		hwstats->rx_bytes			+= fe_r32(base);
-		stats					=  fe_r32(base + 0x04);
-		if (stats)
-			hwstats->rx_bytes		+= (stats << 32);
-		hwstats->rx_packets			+= fe_r32(base + 0x08);
-		hwstats->rx_overflow			+= fe_r32(base + 0x10);
-		hwstats->rx_fcs_errors			+= fe_r32(base + 0x14);
-		hwstats->rx_short_errors		+= fe_r32(base + 0x18);
-		hwstats->rx_long_errors			+= fe_r32(base + 0x1c);
-		hwstats->rx_checksum_errors		+= fe_r32(base + 0x20);
-		hwstats->rx_flow_control_packets	+= fe_r32(base + 0x24);
-		hwstats->tx_skip			+= fe_r32(base + 0x28);
-		hwstats->tx_collisions			+= fe_r32(base + 0x2c);
-		hwstats->tx_bytes			+= fe_r32(base + 0x30);
-		stats					=  fe_r32(base + 0x34);
-		if (stats)
-			hwstats->tx_bytes		+= (stats << 32);
-		hwstats->tx_packets			+= fe_r32(base + 0x38);
-	} else {
-		hwstats->tx_bytes			+= fe_r32(base);
-		hwstats->tx_packets			+= fe_r32(base + 0x04);
-		hwstats->tx_skip			+= fe_r32(base + 0x08);
-		hwstats->tx_collisions			+= fe_r32(base + 0x0c);
-		hwstats->rx_bytes			+= fe_r32(base + 0x20);
-		hwstats->rx_packets			+= fe_r32(base + 0x24);
-		hwstats->rx_overflow			+= fe_r32(base + 0x28);
-		hwstats->rx_fcs_errors			+= fe_r32(base + 0x2c);
-		hwstats->rx_short_errors		+= fe_r32(base + 0x30);
-		hwstats->rx_long_errors			+= fe_r32(base + 0x34);
-		hwstats->rx_checksum_errors		+= fe_r32(base + 0x38);
-		hwstats->rx_flow_control_packets	+= fe_r32(base + 0x3c);
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->mac[i] || !eth->mac[i]->hw_stats)
+			continue;
+		if (spin_trylock(&eth->mac[i]->hw_stats->stats_lock)) {
+			mtk_stats_update_mac(eth->mac[i]);
+			spin_unlock(&eth->mac[i]->hw_stats->stats_lock);
+		}
 	}
-
-	u64_stats_update_end(&hwstats->syncp);
 }
 
-static void fe_get_stats64(struct net_device *dev,
-				struct rtnl_link_stats64 *storage)
+static void mtk_get_stats64(struct net_device *dev,
+			    struct rtnl_link_stats64 *storage)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	struct fe_hw_stats *hwstats = priv->hw_stats;
-	unsigned int base = fe_reg_table[FE_REG_FE_COUNTER_BASE];
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_hw_stats *hw_stats = mac->hw_stats;
 	unsigned int start;
 
-	if (!base) {
-		netdev_stats_to_stats64(storage, &dev->stats);
-		return;
-	}
-
 	if (netif_running(dev) && netif_device_present(dev)) {
-		if (spin_trylock_bh(&hwstats->stats_lock)) {
-			fe_stats_update(priv);
-			spin_unlock_bh(&hwstats->stats_lock);
+		if (spin_trylock_bh(&hw_stats->stats_lock)) {
+			mtk_stats_update_mac(mac);
+			spin_unlock_bh(&hw_stats->stats_lock);
 		}
 	}
 
 	do {
-		start = u64_stats_fetch_begin_irq(&hwstats->syncp);
-		storage->rx_packets = hwstats->rx_packets;
-		storage->tx_packets = hwstats->tx_packets;
-		storage->rx_bytes = hwstats->rx_bytes;
-		storage->tx_bytes = hwstats->tx_bytes;
-		storage->collisions = hwstats->tx_collisions;
-		storage->rx_length_errors = hwstats->rx_short_errors +
-			hwstats->rx_long_errors;
-		storage->rx_over_errors = hwstats->rx_overflow;
-		storage->rx_crc_errors = hwstats->rx_fcs_errors;
-		storage->rx_errors = hwstats->rx_checksum_errors;
-		storage->tx_aborted_errors = hwstats->tx_skip;
-	} while (u64_stats_fetch_retry_irq(&hwstats->syncp, start));
-
-	storage->tx_errors = priv->netdev->stats.tx_errors;
-	storage->rx_dropped = priv->netdev->stats.rx_dropped;
-	storage->tx_dropped = priv->netdev->stats.tx_dropped;
+		start = u64_stats_fetch_begin_irq(&hw_stats->syncp);
+		storage->rx_packets = hw_stats->rx_packets;
+		storage->tx_packets = hw_stats->tx_packets;
+		storage->rx_bytes = hw_stats->rx_bytes;
+		storage->tx_bytes = hw_stats->tx_bytes;
+		storage->collisions = hw_stats->tx_collisions;
+		storage->rx_length_errors = hw_stats->rx_short_errors +
+			hw_stats->rx_long_errors;
+		storage->rx_over_errors = hw_stats->rx_overflow;
+		storage->rx_crc_errors = hw_stats->rx_fcs_errors;
+		storage->rx_errors = hw_stats->rx_checksum_errors;
+		storage->tx_aborted_errors = hw_stats->tx_skip;
+	} while (u64_stats_fetch_retry_irq(&hw_stats->syncp, start));
+
+	storage->tx_errors = dev->stats.tx_errors;
+	storage->rx_dropped = dev->stats.rx_dropped;
+	storage->tx_dropped = dev->stats.tx_dropped;
 }
 
-static int fe_vlan_rx_add_vid(struct net_device *dev,
-			      __be16 proto, u16 vid)
+static inline int mtk_max_frag_size(int mtu)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	u32 idx = (vid & 0xf);
-	u32 vlan_cfg;
-
-	if (!((fe_reg_table[FE_REG_FE_DMA_VID_BASE]) &&
-	      (dev->features & NETIF_F_HW_VLAN_CTAG_TX)))
-		return 0;
-
-	if (test_bit(idx, &priv->vlan_map)) {
-		netdev_warn(dev, "disable tx vlan offload\n");
-		dev->wanted_features &= ~NETIF_F_HW_VLAN_CTAG_TX;
-		netdev_update_features(dev);
-	} else {
-		vlan_cfg = fe_r32(fe_reg_table[FE_REG_FE_DMA_VID_BASE] +
-				((idx >> 1) << 2));
-		if (idx & 0x1) {
-			vlan_cfg &= 0xffff;
-			vlan_cfg |= (vid << 16);
-		} else {
-			vlan_cfg &= 0xffff0000;
-			vlan_cfg |= vid;
-		}
-		fe_w32(vlan_cfg, fe_reg_table[FE_REG_FE_DMA_VID_BASE] +
-				((idx >> 1) << 2));
-		set_bit(idx, &priv->vlan_map);
-	}
+	/* make sure buf_size will be at least MTK_MAX_RX_LENGTH */
+	if (mtu + MTK_RX_ETH_HLEN < MTK_MAX_RX_LENGTH)
+		mtu = MTK_MAX_RX_LENGTH - MTK_RX_ETH_HLEN;
 
-	return 0;
+	return SKB_DATA_ALIGN(MTK_RX_HLEN + mtu) +
+		SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 }
 
-static int fe_vlan_rx_kill_vid(struct net_device *dev,
-			       __be16 proto, u16 vid)
+static inline int mtk_max_buf_size(int frag_size)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	u32 idx = (vid & 0xf);
-
-	if (!((fe_reg_table[FE_REG_FE_DMA_VID_BASE]) &&
-	      (dev->features & NETIF_F_HW_VLAN_CTAG_TX)))
-		return 0;
+	int buf_size = frag_size - NET_SKB_PAD - NET_IP_ALIGN -
+		       SKB_DATA_ALIGN(sizeof(struct skb_shared_info));
 
-	clear_bit(idx, &priv->vlan_map);
+	WARN_ON(buf_size < MTK_MAX_RX_LENGTH);
 
-	return 0;
+	return buf_size;
 }
 
-static inline u32 fe_empty_txd(struct fe_tx_ring *ring)
+static inline void mtk_rx_get_desc(struct mtk_rx_dma *rxd,
+				   struct mtk_rx_dma *dma_rxd)
 {
-	barrier();
-	return (u32)(ring->tx_ring_size -
-			((ring->tx_next_idx - ring->tx_free_idx) &
-			 (ring->tx_ring_size - 1)));
+	rxd->rxd1 = READ_ONCE(dma_rxd->rxd1);
+	rxd->rxd2 = READ_ONCE(dma_rxd->rxd2);
+	rxd->rxd3 = READ_ONCE(dma_rxd->rxd3);
+	rxd->rxd4 = READ_ONCE(dma_rxd->rxd4);
 }
 
-static int fe_tx_dma_map_page(struct device *dev, struct fe_tx_buf *tx_buf,
-			      struct fe_tx_dma *txd, int idx,
-			      struct page *page, size_t offset, size_t size)
+/* the qdma core needs scratch memory to be setup */
+static int mtk_init_fq_dma(struct mtk_eth *eth)
 {
-	dma_addr_t mapped_addr;
-
-	mapped_addr = dma_map_page(dev, page, offset, size, DMA_TO_DEVICE);
-	if (unlikely(dma_mapping_error(dev, mapped_addr)))
-		return -EIO;
+	dma_addr_t phy_ring_tail;
+	int cnt = MTK_DMA_SIZE;
+	dma_addr_t dma_addr;
+	int i;
 
-	if (idx & 1) {
-		txd->txd3 = mapped_addr;
-		txd->txd2 |= TX_DMA_PLEN1(size);
-		dma_unmap_addr_set(tx_buf, dma_addr1, mapped_addr);
-		dma_unmap_len_set(tx_buf, dma_len1, size);
-	} else {
-		tx_buf->skb = (struct sk_buff *)DMA_DUMMY_DESC;
-		txd->txd1 = mapped_addr;
-		txd->txd2 = TX_DMA_PLEN0(size);
-		dma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);
-		dma_unmap_len_set(tx_buf, dma_len0, size);
+	eth->scratch_ring = dma_alloc_coherent(eth->dev,
+					       cnt * sizeof(struct mtk_tx_dma),
+					       &eth->phy_scratch_ring,
+					       GFP_ATOMIC | __GFP_ZERO);
+	if (unlikely(!eth->scratch_ring))
+		return -ENOMEM;
+
+	eth->scratch_head = kcalloc(cnt, MTK_QDMA_PAGE_SIZE,
+				    GFP_KERNEL);
+	if (unlikely(!eth->scratch_head))
+		return -ENOMEM;
+
+	dma_addr = dma_map_single(eth->dev,
+				  eth->scratch_head, cnt * MTK_QDMA_PAGE_SIZE,
+				  DMA_FROM_DEVICE);
+	if (unlikely(dma_mapping_error(eth->dev, dma_addr)))
+		return -ENOMEM;
+
+	memset(eth->scratch_ring, 0x0, sizeof(struct mtk_tx_dma) * cnt);
+	phy_ring_tail = eth->phy_scratch_ring +
+			(sizeof(struct mtk_tx_dma) * (cnt - 1));
+
+	for (i = 0; i < cnt; i++) {
+		eth->scratch_ring[i].txd1 =
+					(dma_addr + (i * MTK_QDMA_PAGE_SIZE));
+		if (i < cnt - 1)
+			eth->scratch_ring[i].txd2 = (eth->phy_scratch_ring +
+				((i + 1) * sizeof(struct mtk_tx_dma)));
+		eth->scratch_ring[i].txd3 = TX_DMA_SDL(MTK_QDMA_PAGE_SIZE);
 	}
+
+	mtk_w32(eth, eth->phy_scratch_ring, MTK_QDMA_FQ_HEAD);
+	mtk_w32(eth, phy_ring_tail, MTK_QDMA_FQ_TAIL);
+	mtk_w32(eth, (cnt << 16) | cnt, MTK_QDMA_FQ_CNT);
+	mtk_w32(eth, MTK_QDMA_PAGE_SIZE << 16, MTK_QDMA_FQ_BLEN);
+
 	return 0;
 }
 
-static int fe_tx_dma_map_skb(struct device *dev, struct fe_tx_buf *tx_buf,
-			     struct fe_tx_dma *txd, int idx,
-			     struct sk_buff *skb)
+static inline void *mtk_qdma_phys_to_virt(struct mtk_tx_ring *ring, u32 desc)
 {
-	struct page *page = virt_to_page(skb->data);
-	size_t offset = offset_in_page(skb->data);
-	size_t size = skb_headlen(skb);
+	void *ret = ring->dma;
 
-	return fe_tx_dma_map_page(dev, tx_buf, txd, idx, page, offset, size);
+	return ret + (desc - ring->phys);
 }
 
-static inline struct sk_buff *
-fe_next_frag(struct sk_buff *head, struct sk_buff *skb)
+static inline struct mtk_tx_buf *mtk_desc_to_tx_buf(struct mtk_tx_ring *ring,
+						    struct mtk_tx_dma *txd)
 {
-	if (skb != head)
-		return skb->next;
+	int idx = txd - ring->dma;
 
-	if (skb_has_frag_list(skb))
-		return skb_shinfo(skb)->frag_list;
+	return &ring->buf[idx];
+}
 
-	return NULL;
+static void mtk_tx_unmap(struct mtk_eth *eth, struct mtk_tx_buf *tx_buf)
+{
+	if (tx_buf->flags & MTK_TX_FLAGS_SINGLE0) {
+		dma_unmap_single(eth->dev,
+				 dma_unmap_addr(tx_buf, dma_addr0),
+				 dma_unmap_len(tx_buf, dma_len0),
+				 DMA_TO_DEVICE);
+	} else if (tx_buf->flags & MTK_TX_FLAGS_PAGE0) {
+		dma_unmap_page(eth->dev,
+			       dma_unmap_addr(tx_buf, dma_addr0),
+			       dma_unmap_len(tx_buf, dma_len0),
+			       DMA_TO_DEVICE);
+	}
+	tx_buf->flags = 0;
+	if (tx_buf->skb &&
+	    (tx_buf->skb != (struct sk_buff *)MTK_DMA_DUMMY_DESC))
+		dev_kfree_skb_any(tx_buf->skb);
+	tx_buf->skb = NULL;
 }
 
-static int fe_tx_map_dma(struct sk_buff *skb, struct net_device *dev,
-			 int tx_num, struct fe_tx_ring *ring)
+static int mtk_tx_map(struct sk_buff *skb, struct net_device *dev,
+		      int tx_num, struct mtk_tx_ring *ring, bool gso)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	struct skb_frag_struct *frag;
-	struct fe_tx_dma txd, *ptxd;
-	struct fe_tx_buf *tx_buf;
-	struct sk_buff *head = skb;
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	struct mtk_tx_dma *itxd, *txd;
+	struct mtk_tx_buf *itx_buf, *tx_buf;
+	dma_addr_t mapped_addr;
 	unsigned int nr_frags;
-	u32 def_txd4;
-	int i, j, k, frag_size, frag_map_size, offset;
+	int i, n_desc = 1;
+	u32 txd4 = 0, fport;
 
-	tx_buf = &ring->tx_buf[ring->tx_next_idx];
-	memset(tx_buf, 0, sizeof(*tx_buf));
-	memset(&txd, 0, sizeof(txd));
+	itxd = ring->next_free;
+	if (itxd == ring->last_free)
+		return -ENOMEM;
 
-	/* init tx descriptor */
-	if (priv->soc->tx_dma)
-		priv->soc->tx_dma(&txd);
-	else
-		txd.txd4 = TX_DMA_DESP4_DEF;
-	def_txd4 = txd.txd4;
+	/* set the forward port */
+	fport = (mac->id + 1) << TX_DMA_FPORT_SHIFT;
+	txd4 |= fport;
+
+	itx_buf = mtk_desc_to_tx_buf(ring, itxd);
+	memset(itx_buf, 0, sizeof(*itx_buf));
+
+	if (gso)
+		txd4 |= TX_DMA_TSO;
 
 	/* TX Checksum offload */
 	if (skb->ip_summed == CHECKSUM_PARTIAL)
-		txd.txd4 |= TX_DMA_CHKSUM;
+		txd4 |= TX_DMA_CHKSUM;
 
 	/* VLAN header offload */
-	if (skb_vlan_tag_present(skb)) {
-		u16 tag = skb_vlan_tag_get(skb);
-
-		if (IS_ENABLED(CONFIG_SOC_MT7621))
-			txd.txd4 |= TX_DMA_INS_VLAN_MT7621 | tag;
-		else
-			txd.txd4 |= TX_DMA_INS_VLAN |
-				((tag >> VLAN_PRIO_SHIFT) << 4) |
-				(tag & 0xF);
-	}
-
-	/* TSO: fill MSS info in tcp checksum field */
-	if (skb_is_gso(skb)) {
-		if (skb_cow_head(skb, 0)) {
-			netif_warn(priv, tx_err, dev,
-				   "GSO expand head fail.\n");
-			goto err_out;
-		}
-		if (skb_shinfo(skb)->gso_type &
-				(SKB_GSO_TCPV4 | SKB_GSO_TCPV6)) {
-			txd.txd4 |= TX_DMA_TSO;
-			tcp_hdr(skb)->check = htons(skb_shinfo(skb)->gso_size);
-		}
-	}
+//	if (skb_vlan_tag_present(skb))
+//		txd4 |= TX_DMA_INS_VLAN | skb_vlan_tag_get(skb);
 
-	k = 0;
-	j = ring->tx_next_idx;
+	mapped_addr = dma_map_single(eth->dev, skb->data,
+				     skb_headlen(skb), DMA_TO_DEVICE);
+	if (unlikely(dma_mapping_error(eth->dev, mapped_addr)))
+		return -ENOMEM;
 
-next_frag:
-	if (skb_headlen(skb)) {
-		if (fe_tx_dma_map_skb(&dev->dev, tx_buf, &txd, k++, skb))
-			goto err_dma;
-	}
+	WRITE_ONCE(itxd->txd1, mapped_addr);
+	itx_buf->flags |= MTK_TX_FLAGS_SINGLE0;
+	itx_buf->flags |= (!mac->id) ? MTK_TX_FLAGS_FPORT0 :
+			  MTK_TX_FLAGS_FPORT1;
+	dma_unmap_addr_set(itx_buf, dma_addr0, mapped_addr);
+	dma_unmap_len_set(itx_buf, dma_len0, skb_headlen(skb));
 
 	/* TX SG offload */
+	txd = itxd;
 	nr_frags = skb_shinfo(skb)->nr_frags;
 	for (i = 0; i < nr_frags; i++) {
-		struct page *page;
-
-		frag = &skb_shinfo(skb)->frags[i];
-		frag_size = skb_frag_size(frag);
-		offset = frag->page_offset;
-		page = skb_frag_page(frag);
-
-		while (frag_size > 0) {
-			frag_map_size = min(frag_size, TX_DMA_BUF_LEN);
-			if (!(k & 0x1)) {
-				fe_set_txd(&txd, &ring->tx_dma[j]);
-				memset(&txd, 0, sizeof(txd));
-				txd.txd4 = def_txd4;
-				j = NEXT_TX_DESP_IDX(j);
-				tx_buf = &ring->tx_buf[j];
-			}
+		struct skb_frag_struct *frag = &skb_shinfo(skb)->frags[i];
+		unsigned int offset = 0;
+		int frag_size = skb_frag_size(frag);
 
-			if (fe_tx_dma_map_page(&dev->dev, tx_buf, &txd, k++,
-					       page, offset, frag_map_size))
+		while (frag_size) {
+			bool last_frag = false;
+			unsigned int frag_map_size;
+
+			txd = mtk_qdma_phys_to_virt(ring, txd->txd2);
+			if (txd == ring->last_free)
+				goto err_dma;
+
+			n_desc++;
+			frag_map_size = min(frag_size, MTK_TX_DMA_BUF_LEN);
+			mapped_addr = skb_frag_dma_map(eth->dev, frag, offset,
+						       frag_map_size,
+						       DMA_TO_DEVICE);
+			if (unlikely(dma_mapping_error(eth->dev, mapped_addr)))
 				goto err_dma;
 
+			if (i == nr_frags - 1 &&
+			    (frag_size - frag_map_size) == 0)
+				last_frag = true;
+
+			WRITE_ONCE(txd->txd1, mapped_addr);
+			WRITE_ONCE(txd->txd3, (TX_DMA_SWC |
+					       TX_DMA_PLEN0(frag_map_size) |
+					       last_frag * TX_DMA_LS0));
+			WRITE_ONCE(txd->txd4, fport);
+
+			tx_buf = mtk_desc_to_tx_buf(ring, txd);
+			memset(tx_buf, 0, sizeof(*tx_buf));
+			tx_buf->skb = (struct sk_buff *)MTK_DMA_DUMMY_DESC;
+			tx_buf->flags |= MTK_TX_FLAGS_PAGE0;
+			tx_buf->flags |= (!mac->id) ? MTK_TX_FLAGS_FPORT0 :
+					 MTK_TX_FLAGS_FPORT1;
+
+			dma_unmap_addr_set(tx_buf, dma_addr0, mapped_addr);
+			dma_unmap_len_set(tx_buf, dma_len0, frag_map_size);
 			frag_size -= frag_map_size;
 			offset += frag_map_size;
 		}
 	}
 
-	skb = fe_next_frag(head, skb);
-	if (skb) {
-		if (!(k & 0x1)) {
-			fe_set_txd(&txd, &ring->tx_dma[j]);
-			memset(&txd, 0, sizeof(txd));
-			txd.txd4 = def_txd4;
-			j = NEXT_TX_DESP_IDX(j);
-			tx_buf = &ring->tx_buf[j];
-		}
-		goto next_frag;
-	}
+	/* store skb to cleanup */
+	itx_buf->skb = skb;
 
-	/* set last segment */
-	if (k & 0x1)
-		txd.txd2 |= TX_DMA_LS0;
-	else
-		txd.txd2 |= TX_DMA_LS1;
-	fe_set_txd(&txd, &ring->tx_dma[j]);
+	WRITE_ONCE(itxd->txd4, txd4);
+	WRITE_ONCE(itxd->txd3, (TX_DMA_SWC | TX_DMA_PLEN0(skb_headlen(skb)) |
+				(!nr_frags * TX_DMA_LS0)));
 
-	/* store skb to cleanup */
-	tx_buf->skb = head;
+	/* we have a single DMA ring so BQL needs to be updated for all devices
+	 * sitting on this ring
+	 */
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+
+		netdev_sent_queue(eth->netdev[i], skb->len);
+	}
 
-	netdev_sent_queue(dev, head->len);
-	skb_tx_timestamp(head);
+	skb_tx_timestamp(skb);
+
+	ring->next_free = mtk_qdma_phys_to_virt(ring, txd->txd2);
+	atomic_sub(n_desc, &ring->free_count);
 
-	ring->tx_next_idx = NEXT_TX_DESP_IDX(j);
 	/* make sure that all changes to the dma ring are flushed before we
 	 * continue
 	 */
 	wmb();
-	if (unlikely(fe_empty_txd(ring) <= ring->tx_thresh)) {
-		netif_stop_queue(dev);
-		smp_mb();
-		if (unlikely(fe_empty_txd(ring) > ring->tx_thresh))
-			netif_wake_queue(dev);
-	}
 
-	if (netif_xmit_stopped(netdev_get_tx_queue(dev, 0)) || !head->xmit_more)
-		fe_reg_w32(ring->tx_next_idx, FE_REG_TX_CTX_IDX0);
+	if (netif_xmit_stopped(netdev_get_tx_queue(dev, 0)) || !skb->xmit_more)
+		mtk_w32(eth, txd->txd2, MTK_QTX_CTX_PTR);
 
 	return 0;
 
 err_dma:
-	j = ring->tx_next_idx;
-	for (i = 0; i < tx_num; i++) {
-		ptxd = &ring->tx_dma[j];
-		tx_buf = &ring->tx_buf[j];
+	do {
+		tx_buf = mtk_desc_to_tx_buf(ring, itxd);
 
 		/* unmap dma */
-		fe_txd_unmap(&dev->dev, tx_buf);
-
-		ptxd->txd2 = TX_DMA_DESP2_DEF;
-		j = NEXT_TX_DESP_IDX(j);
-	}
-	/* make sure that all changes to the dma ring are flushed before we
-	 * continue
-	 */
-	wmb();
-
-err_out:
-	return -1;
-}
+		mtk_tx_unmap(eth, tx_buf);
 
-static inline int fe_skb_padto(struct sk_buff *skb, struct fe_priv *priv)
-{
-	unsigned int len;
-	int ret;
-
-	ret = 0;
-	if (unlikely(skb->len < VLAN_ETH_ZLEN)) {
-		if ((priv->flags & FE_FLAG_PADDING_64B) &&
-		    !(priv->flags & FE_FLAG_PADDING_BUG))
-			return ret;
-
-		if (skb_vlan_tag_present(skb))
-			len = ETH_ZLEN;
-		else if (skb->protocol == cpu_to_be16(ETH_P_8021Q))
-			len = VLAN_ETH_ZLEN;
-		else if (!(priv->flags & FE_FLAG_PADDING_64B))
-			len = ETH_ZLEN;
-		else
-			return ret;
-
-		if (skb->len < len) {
-			ret = skb_pad(skb, len - skb->len);
-			if (ret < 0)
-				return ret;
-			skb->len = len;
-			skb_set_tail_pointer(skb, len);
-		}
-	}
+		itxd->txd3 = TX_DMA_LS0 | TX_DMA_OWNER_CPU;
+		itxd = mtk_qdma_phys_to_virt(ring, itxd->txd2);
+	} while (itxd != txd);
 
-	return ret;
+	return -ENOMEM;
 }
 
-static inline int fe_cal_txd_req(struct sk_buff *skb)
+static inline int mtk_cal_txd_req(struct sk_buff *skb)
 {
-	struct sk_buff *head = skb;
-	int i, nfrags = 0;
+	int i, nfrags;
 	struct skb_frag_struct *frag;
 
-next_frag:
-	nfrags++;
+	nfrags = 1;
 	if (skb_is_gso(skb)) {
 		for (i = 0; i < skb_shinfo(skb)->nr_frags; i++) {
 			frag = &skb_shinfo(skb)->frags[i];
-			nfrags += DIV_ROUND_UP(frag->size, TX_DMA_BUF_LEN);
+			nfrags += DIV_ROUND_UP(frag->size, MTK_TX_DMA_BUF_LEN);
 		}
 	} else {
 		nfrags += skb_shinfo(skb)->nr_frags;
 	}
 
-	skb = fe_next_frag(head, skb);
-	if (skb)
-		goto next_frag;
-
-	return DIV_ROUND_UP(nfrags, 2);
+	return nfrags;
 }
 
-static int fe_start_xmit(struct sk_buff *skb, struct net_device *dev)
+static int mtk_queue_stopped(struct mtk_eth *eth)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	struct fe_tx_ring *ring = &priv->tx_ring;
-	struct net_device_stats *stats = &dev->stats;
-	int tx_num;
-	int len = skb->len;
+	int i;
 
-	if (fe_skb_padto(skb, priv)) {
-		netif_warn(priv, tx_err, dev, "tx padding failed!\n");
-		return NETDEV_TX_OK;
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		if (netif_queue_stopped(eth->netdev[i]))
+			return 1;
 	}
 
-	tx_num = fe_cal_txd_req(skb);
-	if (unlikely(fe_empty_txd(ring) <= tx_num)) {
-		netif_stop_queue(dev);
-		netif_err(priv, tx_queued, dev,
-			  "Tx Ring full when queue awake!\n");
-		return NETDEV_TX_BUSY;
-	}
+	return 0;
+}
 
-	if (fe_tx_map_dma(skb, dev, tx_num, ring) < 0) {
-		stats->tx_dropped++;
-	} else {
-		stats->tx_packets++;
-		stats->tx_bytes += len;
-	}
+static void mtk_wake_queue(struct mtk_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		netif_wake_queue(eth->netdev[i]);
+	}
+}
+
+static void mtk_stop_queue(struct mtk_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		netif_stop_queue(eth->netdev[i]);
+	}
+}
+
+static int mtk_start_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	struct mtk_tx_ring *ring = &eth->tx_ring;
+	struct net_device_stats *stats = &dev->stats;
+	bool gso = false;
+	int tx_num;
+
+	/* normally we can rely on the stack not calling this more than once,
+	 * however we have 2 queues running on the same ring so we need to lock
+	 * the ring access
+	 */
+	spin_lock(&eth->page_lock);
+
+	if (unlikely(test_bit(MTK_RESETTING, &eth->state)))
+		goto drop;
+
+	tx_num = mtk_cal_txd_req(skb);
+	if (unlikely(atomic_read(&ring->free_count) <= tx_num)) {
+		mtk_stop_queue(eth);
+		netif_err(eth, tx_queued, dev,
+			  "Tx Ring full when queue awake!\n");
+		spin_unlock(&eth->page_lock);
+		return NETDEV_TX_BUSY;
+	}
+
+	/* TSO: fill MSS info in tcp checksum field */
+	if (skb_is_gso(skb)) {
+		if (skb_cow_head(skb, 0)) {
+			netif_warn(eth, tx_err, dev,
+				   "GSO expand head fail.\n");
+			goto drop;
+		}
+
+		if (skb_shinfo(skb)->gso_type &
+				(SKB_GSO_TCPV4 | SKB_GSO_TCPV6)) {
+			gso = true;
+			tcp_hdr(skb)->check = htons(skb_shinfo(skb)->gso_size);
+		}
+	}
+
+	if (mtk_tx_map(skb, dev, tx_num, ring, gso) < 0)
+		goto drop;
+
+	if (unlikely(atomic_read(&ring->free_count) <= ring->thresh))
+		mtk_stop_queue(eth);
+
+	spin_unlock(&eth->page_lock);
+
+	return NETDEV_TX_OK;
 
+drop:
+	spin_unlock(&eth->page_lock);
+	stats->tx_dropped++;
+	dev_kfree_skb_any(skb);
 	return NETDEV_TX_OK;
 }
 
-static int fe_poll_rx(struct napi_struct *napi, int budget,
-		      struct fe_priv *priv, u32 rx_intr)
+static struct mtk_rx_ring *mtk_get_rx_ring(struct mtk_eth *eth)
 {
-	struct net_device *netdev = priv->netdev;
-	struct net_device_stats *stats = &netdev->stats;
-	struct fe_soc_data *soc = priv->soc;
-	struct fe_rx_ring *ring = &priv->rx_ring;
-	int idx = ring->rx_calc_idx;
-	u32 checksum_bit;
-	struct sk_buff *skb;
-	u8 *data, *new_data;
-	struct fe_rx_dma *rxd, trxd;
-	int done = 0, pad;
+	int i;
+	struct mtk_rx_ring *ring;
+	int idx;
+
+	if (!eth->hwlro)
+		return &eth->rx_ring[0];
+
+	for (i = 0; i < MTK_MAX_RX_RING_NUM; i++) {
+		ring = &eth->rx_ring[i];
+		idx = NEXT_RX_DESP_IDX(ring->calc_idx, ring->dma_size);
+		if (ring->dma[idx].rxd2 & RX_DMA_DONE) {
+			ring->calc_idx_update = true;
+			return ring;
+		}
+	}
 
-	if (netdev->features & NETIF_F_RXCSUM)
-		checksum_bit = soc->checksum_bit;
-	else
-		checksum_bit = 0;
+	return NULL;
+}
 
-	if (priv->flags & FE_FLAG_RX_2B_OFFSET)
-		pad = 0;
-	else
-		pad = NET_IP_ALIGN;
+static void mtk_update_rx_cpu_idx(struct mtk_eth *eth)
+{
+	struct mtk_rx_ring *ring;
+	int i;
+
+	if (!eth->hwlro) {
+		ring = &eth->rx_ring[0];
+		mtk_w32(eth, ring->calc_idx, ring->crx_idx_reg);
+	} else {
+		for (i = 0; i < MTK_MAX_RX_RING_NUM; i++) {
+			ring = &eth->rx_ring[i];
+			if (ring->calc_idx_update) {
+				ring->calc_idx_update = false;
+				mtk_w32(eth, ring->calc_idx, ring->crx_idx_reg);
+			}
+		}
+	}
+}
+
+static int mtk_poll_rx(struct napi_struct *napi, int budget,
+		       struct mtk_eth *eth)
+{
+	struct mtk_rx_ring *ring;
+	int idx;
+	struct sk_buff *skb;
+	u8 *data, *new_data;
+	struct mtk_rx_dma *rxd, trxd;
+	int done = 0;
 
 	while (done < budget) {
+		struct net_device *netdev;
 		unsigned int pktlen;
 		dma_addr_t dma_addr;
+		int mac = 0;
 
-		idx = NEXT_RX_DESP_IDX(idx);
-		rxd = &ring->rx_dma[idx];
-		data = ring->rx_data[idx];
+		ring = mtk_get_rx_ring(eth);
+		if (unlikely(!ring))
+			goto rx_done;
 
-		fe_get_rxd(&trxd, rxd);
+		idx = NEXT_RX_DESP_IDX(ring->calc_idx, ring->dma_size);
+		rxd = &ring->dma[idx];
+		data = ring->data[idx];
+
+		mtk_rx_get_desc(&trxd, rxd);
 		if (!(trxd.rxd2 & RX_DMA_DONE))
 			break;
 
+		/* find out which mac the packet comes from. If the special tag is
+		 * we can assume that the traffic is coming from the builtin mt7530
+		 * and the DSA driver has loaded. FPORT will be the physical switch
+		 * port in this case rather than the FE forward port id. */
+		if (!(trxd.rxd4 & RX_DMA_SP_TAG)) {
+			/* values start at 1 */
+			mac = (trxd.rxd4 >> RX_DMA_FPORT_SHIFT) &
+			      RX_DMA_FPORT_MASK;
+			mac--;
+		}
+
+		if (unlikely(mac < 0 || mac >= MTK_MAC_COUNT ||
+			     !eth->netdev[mac]))
+			goto release_desc;
+
+		netdev = eth->netdev[mac];
+
+		if (unlikely(test_bit(MTK_RESETTING, &eth->state)))
+			goto release_desc;
+
 		/* alloc new buffer */
-		new_data = page_frag_alloc(&ring->frag_cache, ring->frag_size,
-					   GFP_ATOMIC);
+		new_data = napi_alloc_frag(ring->frag_size);
 		if (unlikely(!new_data)) {
-			stats->rx_dropped++;
+			netdev->stats.rx_dropped++;
 			goto release_desc;
 		}
-		dma_addr = dma_map_single(&netdev->dev,
-					  new_data + NET_SKB_PAD + pad,
-					  ring->rx_buf_size,
+		dma_addr = dma_map_single(eth->dev,
+					  new_data + NET_SKB_PAD,
+					  ring->buf_size,
 					  DMA_FROM_DEVICE);
-		if (unlikely(dma_mapping_error(&netdev->dev, dma_addr))) {
+		if (unlikely(dma_mapping_error(eth->dev, dma_addr))) {
 			skb_free_frag(new_data);
+			netdev->stats.rx_dropped++;
 			goto release_desc;
 		}
 
@@ -910,781 +1043,1700 @@ static int fe_poll_rx(struct napi_struct *napi, int budget,
 		skb = build_skb(data, ring->frag_size);
 		if (unlikely(!skb)) {
 			skb_free_frag(new_data);
+			netdev->stats.rx_dropped++;
 			goto release_desc;
 		}
 		skb_reserve(skb, NET_SKB_PAD + NET_IP_ALIGN);
 
-		dma_unmap_single(&netdev->dev, trxd.rxd1,
-				 ring->rx_buf_size, DMA_FROM_DEVICE);
+		dma_unmap_single(eth->dev, trxd.rxd1,
+				 ring->buf_size, DMA_FROM_DEVICE);
 		pktlen = RX_DMA_GET_PLEN0(trxd.rxd2);
 		skb->dev = netdev;
 		skb_put(skb, pktlen);
-		if (trxd.rxd4 & checksum_bit)
+		if (trxd.rxd4 & RX_DMA_L4_VALID)
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
 		else
 			skb_checksum_none_assert(skb);
 		skb->protocol = eth_type_trans(skb, netdev);
 
-#ifdef CONFIG_NET_MEDIATEK_OFFLOAD
-		if (mtk_offload_check_rx(priv, skb, trxd.rxd4) == 0) {
-#endif
-			stats->rx_packets++;
-			stats->rx_bytes += pktlen;
+		if (netdev->features & NETIF_F_HW_VLAN_CTAG_RX &&
+		    RX_DMA_VID(trxd.rxd3))
+			__vlan_hwaccel_put_tag(skb, htons(ETH_P_8021Q),
+					       RX_DMA_VID(trxd.rxd3));
+		skb_record_rx_queue(skb, 0);
+		napi_gro_receive(napi, skb);
 
-			napi_gro_receive(napi, skb);
-#ifdef CONFIG_NET_MEDIATEK_OFFLOAD
-		} else {
-			dev_kfree_skb(skb);
-		}
-#endif
-		ring->rx_data[idx] = new_data;
+		ring->data[idx] = new_data;
 		rxd->rxd1 = (unsigned int)dma_addr;
 
 release_desc:
-		if (priv->flags & FE_FLAG_RX_SG_DMA)
-			rxd->rxd2 = RX_DMA_PLEN0(ring->rx_buf_size);
-		else
-			rxd->rxd2 = RX_DMA_LSO;
+		rxd->rxd2 = RX_DMA_PLEN0(ring->buf_size);
+
+		ring->calc_idx = idx;
+
+		done++;
+	}
 
-		ring->rx_calc_idx = idx;
+rx_done:
+	if (done) {
 		/* make sure that all changes to the dma ring are flushed before
 		 * we continue
 		 */
 		wmb();
-		fe_reg_w32(ring->rx_calc_idx, FE_REG_RX_CALC_IDX0);
-		done++;
+		mtk_update_rx_cpu_idx(eth);
 	}
 
-	if (done < budget)
-		fe_reg_w32(rx_intr, FE_REG_FE_INT_STATUS);
-
 	return done;
 }
 
-static int fe_poll_tx(struct fe_priv *priv, int budget, u32 tx_intr,
-		      int *tx_again)
+static int mtk_poll_tx(struct mtk_eth *eth, int budget)
 {
-	struct net_device *netdev = priv->netdev;
-	struct device *dev = &netdev->dev;
-	unsigned int bytes_compl = 0;
+	struct mtk_tx_ring *ring = &eth->tx_ring;
+	struct mtk_tx_dma *desc;
 	struct sk_buff *skb;
-	struct fe_tx_buf *tx_buf;
-	int done = 0;
-	u32 idx, hwidx;
-	struct fe_tx_ring *ring = &priv->tx_ring;
+	struct mtk_tx_buf *tx_buf;
+	int total = 0, done = 0;
+	unsigned int bytes = 0;
+	u32 cpu, dma;
+	int i;
 
-	idx = ring->tx_free_idx;
-	hwidx = fe_reg_r32(FE_REG_TX_DTX_IDX0);
+	cpu = mtk_r32(eth, MTK_QTX_CRX_PTR);
+	dma = mtk_r32(eth, MTK_QTX_DRX_PTR);
 
-	while ((idx != hwidx) && budget) {
-		tx_buf = &ring->tx_buf[idx];
-		skb = tx_buf->skb;
+	desc = mtk_qdma_phys_to_virt(ring, cpu);
 
+	while ((cpu != dma) && (done < budget)) {
+		u32 next_cpu = desc->txd2;
+		int mac = 0;
+
+		desc = mtk_qdma_phys_to_virt(ring, desc->txd2);
+		if ((desc->txd3 & TX_DMA_OWNER_CPU) == 0)
+			break;
+
+		tx_buf = mtk_desc_to_tx_buf(ring, desc);
+		if (tx_buf->flags & MTK_TX_FLAGS_FPORT1)
+			mac = 1;
+
+		skb = tx_buf->skb;
 		if (!skb)
 			break;
 
-		if (skb != (struct sk_buff *)DMA_DUMMY_DESC) {
-			bytes_compl += skb->len;
+		if (skb != (struct sk_buff *)MTK_DMA_DUMMY_DESC) {
+			bytes += skb->len;
 			done++;
-			budget--;
 		}
-		fe_txd_unmap(dev, tx_buf);
-		idx = NEXT_TX_DESP_IDX(idx);
-	}
-	ring->tx_free_idx = idx;
+		mtk_tx_unmap(eth, tx_buf);
 
-	if (idx == hwidx) {
-		/* read hw index again make sure no new tx packet */
-		hwidx = fe_reg_r32(FE_REG_TX_DTX_IDX0);
-		if (idx == hwidx)
-			fe_reg_w32(tx_intr, FE_REG_FE_INT_STATUS);
-		else
-			*tx_again = 1;
-	} else {
-		*tx_again = 1;
+		ring->last_free = desc;
+		atomic_inc(&ring->free_count);
+
+		cpu = next_cpu;
 	}
 
-	if (done) {
-		netdev_completed_queue(netdev, done, bytes_compl);
-		smp_mb();
-		if (unlikely(netif_queue_stopped(netdev) &&
-			     (fe_empty_txd(ring) > ring->tx_thresh)))
-			netif_wake_queue(netdev);
+	mtk_w32(eth, cpu, MTK_QTX_CRX_PTR);
+
+	/* we have a single DMA ring so BQL needs to be updated for all devices
+	 * sitting on this ring
+	 */
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		netdev_completed_queue(eth->netdev[i], done, bytes);
 	}
 
-	return done;
+	if (mtk_queue_stopped(eth) &&
+	    (atomic_read(&ring->free_count) > ring->thresh))
+		mtk_wake_queue(eth);
+
+	return total;
 }
 
-static int fe_poll(struct napi_struct *napi, int budget)
+static void mtk_handle_status_irq(struct mtk_eth *eth)
 {
-	struct fe_priv *priv = container_of(napi, struct fe_priv, rx_napi);
-	struct fe_hw_stats *hwstat = priv->hw_stats;
-	int tx_done, rx_done, tx_again;
-	u32 status, fe_status, status_reg, mask;
-	u32 tx_intr, rx_intr, status_intr;
+	u32 status2 = mtk_r32(eth, MTK_INT_STATUS2);
 
-	status = fe_reg_r32(FE_REG_FE_INT_STATUS);
-	fe_status = status;
-	tx_intr = priv->soc->tx_int;
-	rx_intr = priv->soc->rx_int;
-	status_intr = priv->soc->status_int;
-	tx_done = 0;
-	rx_done = 0;
-	tx_again = 0;
+	if (unlikely(status2 & (MTK_GDM1_AF | MTK_GDM2_AF))) {
+		mtk_stats_update(eth);
+		mtk_w32(eth, (MTK_GDM1_AF | MTK_GDM2_AF),
+			MTK_INT_STATUS2);
+	}
+}
 
-	if (fe_reg_table[FE_REG_FE_INT_STATUS2]) {
-		fe_status = fe_reg_r32(FE_REG_FE_INT_STATUS2);
-		status_reg = FE_REG_FE_INT_STATUS2;
-	} else {
-		status_reg = FE_REG_FE_INT_STATUS;
+static int mtk_napi_tx(struct napi_struct *napi, int budget)
+{
+	struct mtk_eth *eth = container_of(napi, struct mtk_eth, tx_napi);
+	u32 status, mask;
+	int tx_done = 0;
+
+	mtk_handle_status_irq(eth);
+	mtk_w32(eth, MTK_TX_DONE_INT, MTK_QMTK_INT_STATUS);
+	tx_done = mtk_poll_tx(eth, budget);
+
+	if (unlikely(netif_msg_intr(eth))) {
+		status = mtk_r32(eth, MTK_QMTK_INT_STATUS);
+		mask = mtk_r32(eth, MTK_QDMA_INT_MASK);
+		dev_info(eth->dev,
+			 "done tx %d, intr 0x%08x/0x%x\n",
+			 tx_done, status, mask);
 	}
 
-	if (status & tx_intr)
-		tx_done = fe_poll_tx(priv, budget, tx_intr, &tx_again);
+	if (tx_done == budget)
+		return budget;
 
-	if (status & rx_intr)
-		rx_done = fe_poll_rx(napi, budget, priv, rx_intr);
+	status = mtk_r32(eth, MTK_QMTK_INT_STATUS);
+	if (status & MTK_TX_DONE_INT)
+		return budget;
 
-	if (unlikely(fe_status & status_intr)) {
-		if (hwstat && spin_trylock(&hwstat->stats_lock)) {
-			fe_stats_update(priv);
-			spin_unlock(&hwstat->stats_lock);
-		}
-		fe_reg_w32(status_intr, status_reg);
-	}
+	napi_complete(napi);
+	mtk_tx_irq_enable(eth, MTK_TX_DONE_INT);
 
-	if (unlikely(netif_msg_intr(priv))) {
-		mask = fe_reg_r32(FE_REG_FE_INT_ENABLE);
-		netdev_info(priv->netdev,
-			    "done tx %d, rx %d, intr 0x%08x/0x%x\n",
-			    tx_done, rx_done, status, mask);
-	}
+	return tx_done;
+}
 
-	if (!tx_again && (rx_done < budget)) {
-		status = fe_reg_r32(FE_REG_FE_INT_STATUS);
-		if (status & (tx_intr | rx_intr)) {
-			/* let napi poll again */
-			rx_done = budget;
-			goto poll_again;
-		}
+static int mtk_napi_rx(struct napi_struct *napi, int budget)
+{
+	struct mtk_eth *eth = container_of(napi, struct mtk_eth, rx_napi);
+	u32 status, mask;
+	int rx_done = 0;
+	int remain_budget = budget;
 
-		napi_complete_done(napi, rx_done);
-		fe_int_enable(tx_intr | rx_intr);
-	} else {
-		rx_done = budget;
-	}
+	mtk_handle_status_irq(eth);
 
 poll_again:
-	return rx_done;
+	mtk_w32(eth, MTK_RX_DONE_INT, MTK_PDMA_INT_STATUS);
+	rx_done = mtk_poll_rx(napi, remain_budget, eth);
+
+	if (unlikely(netif_msg_intr(eth))) {
+		status = mtk_r32(eth, MTK_PDMA_INT_STATUS);
+		mask = mtk_r32(eth, MTK_PDMA_INT_MASK);
+		dev_info(eth->dev,
+			 "done rx %d, intr 0x%08x/0x%x\n",
+			 rx_done, status, mask);
+	}
+	if (rx_done == remain_budget)
+		return budget;
+
+	status = mtk_r32(eth, MTK_PDMA_INT_STATUS);
+	if (status & MTK_RX_DONE_INT) {
+		remain_budget -= rx_done;
+		goto poll_again;
+	}
+	napi_complete(napi);
+	mtk_rx_irq_enable(eth, MTK_RX_DONE_INT);
+
+	return rx_done + budget - remain_budget;
 }
 
-static void fe_tx_timeout(struct net_device *dev)
+static int mtk_tx_alloc(struct mtk_eth *eth)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	struct fe_tx_ring *ring = &priv->tx_ring;
+	struct mtk_tx_ring *ring = &eth->tx_ring;
+	int i, sz = sizeof(*ring->dma);
 
-	priv->netdev->stats.tx_errors++;
-	netif_err(priv, tx_err, dev,
-		  "transmit timed out\n");
-	netif_info(priv, drv, dev, "dma_cfg:%08x\n",
-		   fe_reg_r32(FE_REG_PDMA_GLO_CFG));
-	netif_info(priv, drv, dev, "tx_ring=%d, "
-		   "base=%08x, max=%u, ctx=%u, dtx=%u, fdx=%hu, next=%hu\n",
-		   0, fe_reg_r32(FE_REG_TX_BASE_PTR0),
-		   fe_reg_r32(FE_REG_TX_MAX_CNT0),
-		   fe_reg_r32(FE_REG_TX_CTX_IDX0),
-		   fe_reg_r32(FE_REG_TX_DTX_IDX0),
-		   ring->tx_free_idx,
-		   ring->tx_next_idx);
-	netif_info(priv, drv, dev,
-		   "rx_ring=%d, base=%08x, max=%u, calc=%u, drx=%u\n",
-		   0, fe_reg_r32(FE_REG_RX_BASE_PTR0),
-		   fe_reg_r32(FE_REG_RX_MAX_CNT0),
-		   fe_reg_r32(FE_REG_RX_CALC_IDX0),
-		   fe_reg_r32(FE_REG_RX_DRX_IDX0));
-
-	if (!test_and_set_bit(FE_FLAG_RESET_PENDING, priv->pending_flags))
-		schedule_work(&priv->pending_work);
-}
-
-static irqreturn_t fe_handle_irq(int irq, void *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	u32 status, int_mask;
-
-	status = fe_reg_r32(FE_REG_FE_INT_STATUS);
-
-	if (unlikely(!status))
-		return IRQ_NONE;
-
-	int_mask = (priv->soc->rx_int | priv->soc->tx_int);
-	if (likely(status & int_mask)) {
-		if (likely(napi_schedule_prep(&priv->rx_napi))) {
-			fe_int_disable(int_mask);
-			__napi_schedule(&priv->rx_napi);
-		}
-	} else {
-		fe_reg_w32(status, FE_REG_FE_INT_STATUS);
+	ring->buf = kcalloc(MTK_DMA_SIZE, sizeof(*ring->buf),
+			       GFP_KERNEL);
+	if (!ring->buf)
+		goto no_tx_mem;
+
+	ring->dma = dma_alloc_coherent(eth->dev,
+					  MTK_DMA_SIZE * sz,
+					  &ring->phys,
+					  GFP_ATOMIC | __GFP_ZERO);
+	if (!ring->dma)
+		goto no_tx_mem;
+
+	memset(ring->dma, 0, MTK_DMA_SIZE * sz);
+	for (i = 0; i < MTK_DMA_SIZE; i++) {
+		int next = (i + 1) % MTK_DMA_SIZE;
+		u32 next_ptr = ring->phys + next * sz;
+
+		ring->dma[i].txd2 = next_ptr;
+		ring->dma[i].txd3 = TX_DMA_LS0 | TX_DMA_OWNER_CPU;
 	}
 
-	return IRQ_HANDLED;
-}
+	atomic_set(&ring->free_count, MTK_DMA_SIZE - 2);
+	ring->next_free = &ring->dma[0];
+	ring->last_free = &ring->dma[MTK_DMA_SIZE - 1];
+	ring->thresh = MAX_SKB_FRAGS;
 
-#ifdef CONFIG_NET_POLL_CONTROLLER
-static void fe_poll_controller(struct net_device *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	u32 int_mask = priv->soc->tx_int | priv->soc->rx_int;
+	/* make sure that all changes to the dma ring are flushed before we
+	 * continue
+	 */
+	wmb();
+
+	mtk_w32(eth, ring->phys, MTK_QTX_CTX_PTR);
+	mtk_w32(eth, ring->phys, MTK_QTX_DTX_PTR);
+	mtk_w32(eth,
+		ring->phys + ((MTK_DMA_SIZE - 1) * sz),
+		MTK_QTX_CRX_PTR);
+	mtk_w32(eth,
+		ring->phys + ((MTK_DMA_SIZE - 1) * sz),
+		MTK_QTX_DRX_PTR);
+	mtk_w32(eth, (QDMA_RES_THRES << 8) | QDMA_RES_THRES, MTK_QTX_CFG(0));
 
-	fe_int_disable(int_mask);
-	fe_handle_irq(dev->irq, dev);
-	fe_int_enable(int_mask);
+	return 0;
+
+no_tx_mem:
+	return -ENOMEM;
 }
-#endif
 
-int fe_set_clock_cycle(struct fe_priv *priv)
+static void mtk_tx_clean(struct mtk_eth *eth)
 {
-	unsigned long sysclk = priv->sysclk;
+	struct mtk_tx_ring *ring = &eth->tx_ring;
+	int i;
 
-	sysclk /= FE_US_CYC_CNT_DIVISOR;
-	sysclk <<= FE_US_CYC_CNT_SHIFT;
+	if (ring->buf) {
+		for (i = 0; i < MTK_DMA_SIZE; i++)
+			mtk_tx_unmap(eth, &ring->buf[i]);
+		kfree(ring->buf);
+		ring->buf = NULL;
+	}
 
-	fe_w32((fe_r32(FE_FE_GLO_CFG) &
-			~(FE_US_CYC_CNT_MASK << FE_US_CYC_CNT_SHIFT)) |
-			sysclk,
-			FE_FE_GLO_CFG);
-	return 0;
+	if (ring->dma) {
+		dma_free_coherent(eth->dev,
+				  MTK_DMA_SIZE * sizeof(*ring->dma),
+				  ring->dma,
+				  ring->phys);
+		ring->dma = NULL;
+	}
 }
 
-void fe_fwd_config(struct fe_priv *priv)
+static int mtk_rx_alloc(struct mtk_eth *eth, int ring_no, int rx_flag)
 {
-	u32 fwd_cfg;
+	struct mtk_rx_ring *ring;
+	int rx_data_len, rx_dma_size;
+	int i;
+	u32 offset = 0;
 
-	fwd_cfg = fe_r32(FE_GDMA1_FWD_CFG);
+	if (rx_flag == MTK_RX_FLAGS_QDMA) {
+		if (ring_no)
+			return -EINVAL;
+		ring = &eth->rx_ring_qdma;
+		offset = 0x1000;
+	} else {
+		ring = &eth->rx_ring[ring_no];
+	}
 
-	/* disable jumbo frame */
-	if (priv->flags & FE_FLAG_JUMBO_FRAME)
-		fwd_cfg &= ~FE_GDM1_JMB_EN;
+	if (rx_flag == MTK_RX_FLAGS_HWLRO) {
+		rx_data_len = MTK_MAX_LRO_RX_LENGTH;
+		rx_dma_size = MTK_HW_LRO_DMA_SIZE;
+	} else {
+		rx_data_len = ETH_DATA_LEN;
+		rx_dma_size = MTK_DMA_SIZE;
+	}
 
-	/* set unicast/multicast/broadcast frame to cpu */
-	fwd_cfg &= ~0xffff;
+	ring->frag_size = mtk_max_frag_size(rx_data_len);
+	ring->buf_size = mtk_max_buf_size(ring->frag_size);
+	ring->data = kcalloc(rx_dma_size, sizeof(*ring->data),
+			     GFP_KERNEL);
+	if (!ring->data)
+		return -ENOMEM;
+
+	for (i = 0; i < rx_dma_size; i++) {
+		ring->data[i] = netdev_alloc_frag(ring->frag_size);
+		if (!ring->data[i])
+			return -ENOMEM;
+	}
 
-	fe_w32(fwd_cfg, FE_GDMA1_FWD_CFG);
-}
+	ring->dma = dma_alloc_coherent(eth->dev,
+				       rx_dma_size * sizeof(*ring->dma),
+				       &ring->phys,
+				       GFP_ATOMIC | __GFP_ZERO);
+	if (!ring->dma)
+		return -ENOMEM;
+
+	for (i = 0; i < rx_dma_size; i++) {
+		dma_addr_t dma_addr = dma_map_single(eth->dev,
+				ring->data[i] + NET_SKB_PAD,
+				ring->buf_size,
+				DMA_FROM_DEVICE);
+		if (unlikely(dma_mapping_error(eth->dev, dma_addr)))
+			return -ENOMEM;
+		ring->dma[i].rxd1 = (unsigned int)dma_addr;
 
-static void fe_rxcsum_config(bool enable)
-{
-	if (enable)
-		fe_w32(fe_r32(FE_GDMA1_FWD_CFG) | (FE_GDM1_ICS_EN |
-					FE_GDM1_TCS_EN | FE_GDM1_UCS_EN),
-				FE_GDMA1_FWD_CFG);
-	else
-		fe_w32(fe_r32(FE_GDMA1_FWD_CFG) & ~(FE_GDM1_ICS_EN |
-					FE_GDM1_TCS_EN | FE_GDM1_UCS_EN),
-				FE_GDMA1_FWD_CFG);
-}
+		ring->dma[i].rxd2 = RX_DMA_PLEN0(ring->buf_size);
+	}
+	ring->dma_size = rx_dma_size;
+	ring->calc_idx_update = false;
+	ring->calc_idx = rx_dma_size - 1;
+	ring->crx_idx_reg = MTK_PRX_CRX_IDX_CFG(ring_no);
+	/* make sure that all changes to the dma ring are flushed before we
+	 * continue
+	 */
+	wmb();
 
-static void fe_txcsum_config(bool enable)
-{
-	if (enable)
-		fe_w32(fe_r32(FE_CDMA_CSG_CFG) | (FE_ICS_GEN_EN |
-					FE_TCS_GEN_EN | FE_UCS_GEN_EN),
-				FE_CDMA_CSG_CFG);
-	else
-		fe_w32(fe_r32(FE_CDMA_CSG_CFG) & ~(FE_ICS_GEN_EN |
-					FE_TCS_GEN_EN | FE_UCS_GEN_EN),
-				FE_CDMA_CSG_CFG);
+	mtk_w32(eth, ring->phys, MTK_PRX_BASE_PTR_CFG(ring_no) + offset);
+	mtk_w32(eth, rx_dma_size, MTK_PRX_MAX_CNT_CFG(ring_no) + offset);
+	mtk_w32(eth, ring->calc_idx, ring->crx_idx_reg + offset);
+	mtk_w32(eth, MTK_PST_DRX_IDX_CFG(ring_no), MTK_PDMA_RST_IDX + offset);
+
+	return 0;
 }
 
-void fe_csum_config(struct fe_priv *priv)
+static void mtk_rx_clean(struct mtk_eth *eth, struct mtk_rx_ring *ring)
 {
-	struct net_device *dev = priv_netdev(priv);
+	int i;
+
+	if (ring->data && ring->dma) {
+		for (i = 0; i < ring->dma_size; i++) {
+			if (!ring->data[i])
+				continue;
+			if (!ring->dma[i].rxd1)
+				continue;
+			dma_unmap_single(eth->dev,
+					 ring->dma[i].rxd1,
+					 ring->buf_size,
+					 DMA_FROM_DEVICE);
+			skb_free_frag(ring->data[i]);
+		}
+		kfree(ring->data);
+		ring->data = NULL;
+	}
 
-	fe_txcsum_config((dev->features & NETIF_F_IP_CSUM));
-	fe_rxcsum_config((dev->features & NETIF_F_RXCSUM));
+	if (ring->dma) {
+		dma_free_coherent(eth->dev,
+				  ring->dma_size * sizeof(*ring->dma),
+				  ring->dma,
+				  ring->phys);
+		ring->dma = NULL;
+	}
 }
 
-static int fe_hw_init(struct net_device *dev)
+static int mtk_hwlro_rx_init(struct mtk_eth *eth)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	int i, err;
-
-	err = devm_request_irq(priv->dev, dev->irq, fe_handle_irq, 0,
-			       dev_name(priv->dev), dev);
-	if (err)
-		return err;
+	int i;
+	u32 ring_ctrl_dw1 = 0, ring_ctrl_dw2 = 0, ring_ctrl_dw3 = 0;
+	u32 lro_ctrl_dw0 = 0, lro_ctrl_dw3 = 0;
 
-	if (priv->soc->set_mac)
-		priv->soc->set_mac(priv, dev->dev_addr);
-	else
-		fe_hw_set_macaddr(priv, dev->dev_addr);
+	/* set LRO rings to auto-learn modes */
+	ring_ctrl_dw2 |= MTK_RING_AUTO_LERAN_MODE;
 
-	/* disable delay interrupt */
-	fe_reg_w32(0, FE_REG_DLY_INT_CFG);
+	/* validate LRO ring */
+	ring_ctrl_dw2 |= MTK_RING_VLD;
 
-	fe_int_disable(priv->soc->tx_int | priv->soc->rx_int);
+	/* set AGE timer (unit: 20us) */
+	ring_ctrl_dw2 |= MTK_RING_AGE_TIME_H;
+	ring_ctrl_dw1 |= MTK_RING_AGE_TIME_L;
 
-	/* frame engine will push VLAN tag regarding to VIDX feild in Tx desc */
-	if (fe_reg_table[FE_REG_FE_DMA_VID_BASE])
-		for (i = 0; i < 16; i += 2)
-			fe_w32(((i + 1) << 16) + i,
-			       fe_reg_table[FE_REG_FE_DMA_VID_BASE] +
-			       (i * 2));
+	/* set max AGG timer (unit: 20us) */
+	ring_ctrl_dw2 |= MTK_RING_MAX_AGG_TIME;
 
-	if (priv->soc->fwd_config(priv))
-		netdev_err(dev, "unable to get clock\n");
+	/* set max LRO AGG count */
+	ring_ctrl_dw2 |= MTK_RING_MAX_AGG_CNT_L;
+	ring_ctrl_dw3 |= MTK_RING_MAX_AGG_CNT_H;
 
-	if (fe_reg_table[FE_REG_FE_RST_GL]) {
-		fe_reg_w32(1, FE_REG_FE_RST_GL);
-		fe_reg_w32(0, FE_REG_FE_RST_GL);
+	for (i = 1; i < MTK_MAX_RX_RING_NUM; i++) {
+		mtk_w32(eth, ring_ctrl_dw1, MTK_LRO_CTRL_DW1_CFG(i));
+		mtk_w32(eth, ring_ctrl_dw2, MTK_LRO_CTRL_DW2_CFG(i));
+		mtk_w32(eth, ring_ctrl_dw3, MTK_LRO_CTRL_DW3_CFG(i));
 	}
 
-	return 0;
-}
+	/* IPv4 checksum update enable */
+	lro_ctrl_dw0 |= MTK_L3_CKS_UPD_EN;
 
-static int fe_open(struct net_device *dev)
-{
-	struct fe_priv *priv = netdev_priv(dev);
-	unsigned long flags;
-	u32 val;
-	int err;
+	/* switch priority comparison to packet count mode */
+	lro_ctrl_dw0 |= MTK_LRO_ALT_PKT_CNT_MODE;
 
-	err = fe_init_dma(priv);
-	if (err) {
-		fe_free_dma(priv);
-		return err;
-	}
+	/* bandwidth threshold setting */
+	mtk_w32(eth, MTK_HW_LRO_BW_THRE, MTK_PDMA_LRO_CTRL_DW2);
 
-	spin_lock_irqsave(&priv->page_lock, flags);
+	/* auto-learn score delta setting */
+	mtk_w32(eth, MTK_HW_LRO_REPLACE_DELTA, MTK_PDMA_LRO_ALT_SCORE_DELTA);
 
-	val = FE_TX_WB_DDONE | FE_RX_DMA_EN | FE_TX_DMA_EN;
-	if (priv->flags & FE_FLAG_RX_2B_OFFSET)
-		val |= FE_RX_2B_OFFSET;
-	val |= priv->soc->pdma_glo_cfg;
-	fe_reg_w32(val, FE_REG_PDMA_GLO_CFG);
+	/* set refresh timer for altering flows to 1 sec. (unit: 20us) */
+	mtk_w32(eth, (MTK_HW_LRO_TIMER_UNIT << 16) | MTK_HW_LRO_REFRESH_TIME,
+		MTK_PDMA_LRO_ALT_REFRESH_TIMER);
 
-	spin_unlock_irqrestore(&priv->page_lock, flags);
+	/* set HW LRO mode & the max aggregation count for rx packets */
+	lro_ctrl_dw3 |= MTK_ADMA_MODE | (MTK_HW_LRO_MAX_AGG_CNT & 0xff);
 
-	if (priv->phy)
-		priv->phy->start(priv);
+	/* the minimal remaining room of SDL0 in RXD for lro aggregation */
+	lro_ctrl_dw3 |= MTK_LRO_MIN_RXD_SDL;
 
-	if (priv->soc->has_carrier && priv->soc->has_carrier(priv))
-		netif_carrier_on(dev);
+	/* enable HW LRO */
+	lro_ctrl_dw0 |= MTK_LRO_EN;
 
-	napi_enable(&priv->rx_napi);
-	fe_int_enable(priv->soc->tx_int | priv->soc->rx_int);
-	netif_start_queue(dev);
-#ifdef CONFIG_NET_MEDIATEK_OFFLOAD
-	mtk_ppe_probe(priv);
-#endif
+	mtk_w32(eth, lro_ctrl_dw3, MTK_PDMA_LRO_CTRL_DW3);
+	mtk_w32(eth, lro_ctrl_dw0, MTK_PDMA_LRO_CTRL_DW0);
 
 	return 0;
 }
 
-static int fe_stop(struct net_device *dev)
+static void mtk_hwlro_rx_uninit(struct mtk_eth *eth)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	unsigned long flags;
 	int i;
+	u32 val;
 
-	netif_tx_disable(dev);
-	fe_int_disable(priv->soc->tx_int | priv->soc->rx_int);
-	napi_disable(&priv->rx_napi);
-
-	if (priv->phy)
-		priv->phy->stop(priv);
-
-	spin_lock_irqsave(&priv->page_lock, flags);
-
-	fe_reg_w32(fe_reg_r32(FE_REG_PDMA_GLO_CFG) &
-		     ~(FE_TX_WB_DDONE | FE_RX_DMA_EN | FE_TX_DMA_EN),
-		     FE_REG_PDMA_GLO_CFG);
-	spin_unlock_irqrestore(&priv->page_lock, flags);
+	/* relinquish lro rings, flush aggregated packets */
+	mtk_w32(eth, MTK_LRO_RING_RELINQUISH_REQ, MTK_PDMA_LRO_CTRL_DW0);
 
-	/* wait dma stop */
+	/* wait for relinquishments done */
 	for (i = 0; i < 10; i++) {
-		if (fe_reg_r32(FE_REG_PDMA_GLO_CFG) &
-				(FE_TX_DMA_BUSY | FE_RX_DMA_BUSY)) {
-			msleep(20);
+		val = mtk_r32(eth, MTK_PDMA_LRO_CTRL_DW0);
+		if (val & MTK_LRO_RING_RELINQUISH_DONE) {
+			if (in_atomic())
+				mdelay(20);
+			else
+				msleep(20);
 			continue;
 		}
 		break;
 	}
 
-	fe_free_dma(priv);
-
-#ifdef CONFIG_NET_MEDIATEK_OFFLOAD
-	mtk_ppe_remove(priv);
-#endif
+	/* invalidate lro rings */
+	for (i = 1; i < MTK_MAX_RX_RING_NUM; i++)
+		mtk_w32(eth, 0, MTK_LRO_CTRL_DW2_CFG(i));
 
-	return 0;
+	/* disable HW LRO */
+	mtk_w32(eth, 0, MTK_PDMA_LRO_CTRL_DW0);
 }
 
-static int __init fe_init(struct net_device *dev)
+static void mtk_hwlro_val_ipaddr(struct mtk_eth *eth, int idx, __be32 ip)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	struct device_node *port;
-	const char *mac_addr;
-	int err;
+	u32 reg_val;
 
-	priv->soc->reset_fe();
+	reg_val = mtk_r32(eth, MTK_LRO_CTRL_DW2_CFG(idx));
 
-	if (priv->soc->switch_init)
-		if (priv->soc->switch_init(priv)) {
-			netdev_err(dev, "failed to initialize switch core\n");
-			return -ENODEV;
-		}
+	/* invalidate the IP setting */
+	mtk_w32(eth, (reg_val & ~MTK_RING_MYIP_VLD), MTK_LRO_CTRL_DW2_CFG(idx));
 
-	mac_addr = of_get_mac_address(priv->dev->of_node);
-	if (mac_addr)
-		ether_addr_copy(dev->dev_addr, mac_addr);
+	mtk_w32(eth, ip, MTK_LRO_DIP_DW0_CFG(idx));
 
-	/* If the mac address is invalid, use random mac address  */
-	if (!is_valid_ether_addr(dev->dev_addr)) {
-		random_ether_addr(dev->dev_addr);
-		dev_err(priv->dev, "generated random MAC address %pM\n",
-			dev->dev_addr);
-	}
+	/* validate the IP setting */
+	mtk_w32(eth, (reg_val | MTK_RING_MYIP_VLD), MTK_LRO_CTRL_DW2_CFG(idx));
+}
 
-	err = fe_mdio_init(priv);
-	if (err)
-		return err;
+static void mtk_hwlro_inval_ipaddr(struct mtk_eth *eth, int idx)
+{
+	u32 reg_val;
 
-	if (priv->soc->port_init)
-		for_each_child_of_node(priv->dev->of_node, port)
-			if (of_device_is_compatible(port, "mediatek,eth-port") &&
-			    of_device_is_available(port))
-				priv->soc->port_init(priv, port);
+	reg_val = mtk_r32(eth, MTK_LRO_CTRL_DW2_CFG(idx));
 
-	if (priv->phy) {
-		err = priv->phy->connect(priv);
-		if (err)
-			goto err_phy_disconnect;
+	/* invalidate the IP setting */
+	mtk_w32(eth, (reg_val & ~MTK_RING_MYIP_VLD), MTK_LRO_CTRL_DW2_CFG(idx));
+
+	mtk_w32(eth, 0, MTK_LRO_DIP_DW0_CFG(idx));
+}
+
+static int mtk_hwlro_get_ip_cnt(struct mtk_mac *mac)
+{
+	int cnt = 0;
+	int i;
+
+	for (i = 0; i < MTK_MAX_LRO_IP_CNT; i++) {
+		if (mac->hwlro_ip[i])
+			cnt++;
 	}
 
-	err = fe_hw_init(dev);
-	if (err)
-		goto err_phy_disconnect;
+	return cnt;
+}
+
+static int mtk_hwlro_add_ipaddr(struct net_device *dev,
+				struct ethtool_rxnfc *cmd)
+{
+	struct ethtool_rx_flow_spec *fsp =
+		(struct ethtool_rx_flow_spec *)&cmd->fs;
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	int hwlro_idx;
+
+	if ((fsp->flow_type != TCP_V4_FLOW) ||
+	    (!fsp->h_u.tcp_ip4_spec.ip4dst) ||
+	    (fsp->location > 1))
+		return -EINVAL;
 
-	if ((priv->flags & FE_FLAG_HAS_SWITCH) && priv->soc->switch_config)
-		priv->soc->switch_config(priv);
+	mac->hwlro_ip[fsp->location] = htonl(fsp->h_u.tcp_ip4_spec.ip4dst);
+	hwlro_idx = (mac->id * MTK_MAX_LRO_IP_CNT) + fsp->location;
 
-	return 0;
+	mac->hwlro_ip_cnt = mtk_hwlro_get_ip_cnt(mac);
 
-err_phy_disconnect:
-	if (priv->phy)
-		priv->phy->disconnect(priv);
-	fe_mdio_cleanup(priv);
+	mtk_hwlro_val_ipaddr(eth, hwlro_idx, mac->hwlro_ip[fsp->location]);
 
-	return err;
+	return 0;
 }
 
-static void fe_uninit(struct net_device *dev)
+static int mtk_hwlro_del_ipaddr(struct net_device *dev,
+				struct ethtool_rxnfc *cmd)
 {
-	struct fe_priv *priv = netdev_priv(dev);
+	struct ethtool_rx_flow_spec *fsp =
+		(struct ethtool_rx_flow_spec *)&cmd->fs;
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	int hwlro_idx;
 
-	if (priv->phy)
-		priv->phy->disconnect(priv);
-	fe_mdio_cleanup(priv);
+	if (fsp->location > 1)
+		return -EINVAL;
+
+	mac->hwlro_ip[fsp->location] = 0;
+	hwlro_idx = (mac->id * MTK_MAX_LRO_IP_CNT) + fsp->location;
+
+	mac->hwlro_ip_cnt = mtk_hwlro_get_ip_cnt(mac);
+
+	mtk_hwlro_inval_ipaddr(eth, hwlro_idx);
 
-	fe_reg_w32(0, FE_REG_FE_INT_ENABLE);
-	free_irq(dev->irq, dev);
+	return 0;
 }
 
-static int fe_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+static void mtk_hwlro_netdev_disable(struct net_device *dev)
 {
-	struct fe_priv *priv = netdev_priv(dev);
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	int i, hwlro_idx;
 
-	if (!priv->phy_dev)
-		return -ENODEV;
+	for (i = 0; i < MTK_MAX_LRO_IP_CNT; i++) {
+		mac->hwlro_ip[i] = 0;
+		hwlro_idx = (mac->id * MTK_MAX_LRO_IP_CNT) + i;
 
-	switch (cmd) {
-	case SIOCETHTOOL:
-		return phy_ethtool_ioctl(priv->phy_dev,
-				(void *) ifr->ifr_data);
-	case SIOCGMIIPHY:
-	case SIOCGMIIREG:
-	case SIOCSMIIREG:
-		return phy_mii_ioctl(priv->phy_dev, ifr, cmd);
-	default:
-		break;
+		mtk_hwlro_inval_ipaddr(eth, hwlro_idx);
 	}
 
-	return -EOPNOTSUPP;
+	mac->hwlro_ip_cnt = 0;
 }
 
-static int fe_change_mtu(struct net_device *dev, int new_mtu)
+static int mtk_hwlro_get_fdir_entry(struct net_device *dev,
+				    struct ethtool_rxnfc *cmd)
 {
-	struct fe_priv *priv = netdev_priv(dev);
-	int frag_size, old_mtu;
-	u32 fwd_cfg;
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct ethtool_rx_flow_spec *fsp =
+		(struct ethtool_rx_flow_spec *)&cmd->fs;
+
+	/* only tcp dst ipv4 is meaningful, others are meaningless */
+	fsp->flow_type = TCP_V4_FLOW;
+	fsp->h_u.tcp_ip4_spec.ip4dst = ntohl(mac->hwlro_ip[fsp->location]);
+	fsp->m_u.tcp_ip4_spec.ip4dst = 0;
+
+	fsp->h_u.tcp_ip4_spec.ip4src = 0;
+	fsp->m_u.tcp_ip4_spec.ip4src = 0xffffffff;
+	fsp->h_u.tcp_ip4_spec.psrc = 0;
+	fsp->m_u.tcp_ip4_spec.psrc = 0xffff;
+	fsp->h_u.tcp_ip4_spec.pdst = 0;
+	fsp->m_u.tcp_ip4_spec.pdst = 0xffff;
+	fsp->h_u.tcp_ip4_spec.tos = 0;
+	fsp->m_u.tcp_ip4_spec.tos = 0xff;
 
-	old_mtu = dev->mtu;
-	dev->mtu = new_mtu;
+	return 0;
+}
 
-	if (!(priv->flags & FE_FLAG_JUMBO_FRAME))
-		return 0;
+static int mtk_hwlro_get_fdir_all(struct net_device *dev,
+				  struct ethtool_rxnfc *cmd,
+				  u32 *rule_locs)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	int cnt = 0;
+	int i;
 
-	/* return early if the buffer sizes will not change */
-	if (old_mtu <= ETH_DATA_LEN && new_mtu <= ETH_DATA_LEN)
-		return 0;
-	if (old_mtu > ETH_DATA_LEN && new_mtu > ETH_DATA_LEN)
-		return 0;
+	for (i = 0; i < MTK_MAX_LRO_IP_CNT; i++) {
+		if (mac->hwlro_ip[i]) {
+			rule_locs[cnt] = i;
+			cnt++;
+		}
+	}
 
-	if (new_mtu <= ETH_DATA_LEN)
-		priv->rx_ring.frag_size = fe_max_frag_size(ETH_DATA_LEN);
-	else
-		priv->rx_ring.frag_size = PAGE_SIZE;
-	priv->rx_ring.rx_buf_size = fe_max_buf_size(priv->rx_ring.frag_size);
+	cmd->rule_cnt = cnt;
 
-	if (!netif_running(dev))
-		return 0;
+	return 0;
+}
+
+static netdev_features_t mtk_fix_features(struct net_device *dev,
+					  netdev_features_t features)
+{
+	if (!(features & NETIF_F_LRO)) {
+		struct mtk_mac *mac = netdev_priv(dev);
+		int ip_cnt = mtk_hwlro_get_ip_cnt(mac);
 
-	fe_stop(dev);
-	if (!IS_ENABLED(CONFIG_SOC_MT7621)) {
-		fwd_cfg = fe_r32(FE_GDMA1_FWD_CFG);
-		if (new_mtu <= ETH_DATA_LEN) {
-			fwd_cfg &= ~FE_GDM1_JMB_EN;
-		} else {
-			frag_size = fe_max_frag_size(new_mtu);
-			fwd_cfg &= ~(FE_GDM1_JMB_LEN_MASK << FE_GDM1_JMB_LEN_SHIFT);
-			fwd_cfg |= (DIV_ROUND_UP(frag_size, 1024) <<
-			FE_GDM1_JMB_LEN_SHIFT) | FE_GDM1_JMB_EN;
+		if (ip_cnt) {
+			netdev_info(dev, "RX flow is programmed, LRO should keep on\n");
+
+			features |= NETIF_F_LRO;
 		}
-		fe_w32(fwd_cfg, FE_GDMA1_FWD_CFG);
 	}
 
-	return fe_open(dev);
+	return features;
 }
 
-#ifdef CONFIG_NET_MEDIATEK_OFFLOAD
-static int
-fe_flow_offload(enum flow_offload_type type, struct flow_offload *flow,
-		struct flow_offload_hw_path *src,
-		struct flow_offload_hw_path *dest)
+static int mtk_set_features(struct net_device *dev, netdev_features_t features)
 {
-	struct fe_priv *priv;
+	int err = 0;
 
-	if (src->dev != dest->dev)
-		return -EINVAL;
+	if (!((dev->features ^ features) & NETIF_F_LRO))
+		return 0;
 
-	priv = netdev_priv(src->dev);
+	if (!(features & NETIF_F_LRO))
+		mtk_hwlro_netdev_disable(dev);
 
-	return mtk_flow_offload(priv, type, flow, src, dest);
+	return err;
+}
+
+/* wait for DMA to finish whatever it is doing before we start using it again */
+static int mtk_dma_busy_wait(struct mtk_eth *eth)
+{
+	unsigned long t_start = jiffies;
+
+	while (1) {
+		if (!(mtk_r32(eth, MTK_QDMA_GLO_CFG) &
+		      (MTK_RX_DMA_BUSY | MTK_TX_DMA_BUSY)))
+			return 0;
+		if (time_after(jiffies, t_start + MTK_DMA_BUSY_TIMEOUT))
+			break;
+	}
+
+	dev_err(eth->dev, "DMA init timeout\n");
+	return -1;
+}
+
+static int mtk_dma_init(struct mtk_eth *eth)
+{
+	int err;
+	u32 i;
+
+	if (mtk_dma_busy_wait(eth))
+		return -EBUSY;
+
+	/* QDMA needs scratch memory for internal reordering of the
+	 * descriptors
+	 */
+	err = mtk_init_fq_dma(eth);
+	if (err)
+		return err;
+
+	err = mtk_tx_alloc(eth);
+	if (err)
+		return err;
+
+	err = mtk_rx_alloc(eth, 0, MTK_RX_FLAGS_QDMA);
+	if (err)
+		return err;
+
+	err = mtk_rx_alloc(eth, 0, MTK_RX_FLAGS_NORMAL);
+	if (err)
+		return err;
+
+	if (eth->hwlro) {
+		for (i = 1; i < MTK_MAX_RX_RING_NUM; i++) {
+			err = mtk_rx_alloc(eth, i, MTK_RX_FLAGS_HWLRO);
+			if (err)
+				return err;
+		}
+		err = mtk_hwlro_rx_init(eth);
+		if (err)
+			return err;
+	}
+
+	/* Enable random early drop and set drop threshold automatically */
+	mtk_w32(eth, FC_THRES_DROP_MODE | FC_THRES_DROP_EN | FC_THRES_MIN,
+		MTK_QDMA_FC_THRES);
+	mtk_w32(eth, 0x0, MTK_QDMA_HRED2);
+
+	return 0;
+}
+
+static void mtk_dma_free(struct mtk_eth *eth)
+{
+	int i;
+
+	for (i = 0; i < MTK_MAC_COUNT; i++)
+		if (eth->netdev[i])
+			netdev_reset_queue(eth->netdev[i]);
+	if (eth->scratch_ring) {
+		dma_free_coherent(eth->dev,
+				  MTK_DMA_SIZE * sizeof(struct mtk_tx_dma),
+				  eth->scratch_ring,
+				  eth->phy_scratch_ring);
+		eth->scratch_ring = NULL;
+		eth->phy_scratch_ring = 0;
+	}
+	mtk_tx_clean(eth);
+	mtk_rx_clean(eth, &eth->rx_ring[0]);
+	mtk_rx_clean(eth, &eth->rx_ring_qdma);
+
+	if (eth->hwlro) {
+		mtk_hwlro_rx_uninit(eth);
+		for (i = 1; i < MTK_MAX_RX_RING_NUM; i++)
+			mtk_rx_clean(eth, &eth->rx_ring[i]);
+	}
+
+	kfree(eth->scratch_head);
+}
+
+static void mtk_tx_timeout(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	eth->netdev[mac->id]->stats.tx_errors++;
+	netif_err(eth, tx_err, dev,
+		  "transmit timed out\n");
+	schedule_work(&eth->pending_work);
+}
+
+static irqreturn_t mtk_handle_irq_rx(int irq, void *_eth)
+{
+	struct mtk_eth *eth = _eth;
+
+	if (likely(napi_schedule_prep(&eth->rx_napi))) {
+		__napi_schedule(&eth->rx_napi);
+		mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t mtk_handle_irq_tx(int irq, void *_eth)
+{
+	struct mtk_eth *eth = _eth;
+
+	if (likely(napi_schedule_prep(&eth->tx_napi))) {
+		__napi_schedule(&eth->tx_napi);
+		mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
+	}
+
+	return IRQ_HANDLED;
 }
-#endif
 
-static const struct net_device_ops fe_netdev_ops = {
-	.ndo_init		= fe_init,
-	.ndo_uninit		= fe_uninit,
-	.ndo_open		= fe_open,
-	.ndo_stop		= fe_stop,
-	.ndo_start_xmit		= fe_start_xmit,
-	.ndo_set_mac_address	= fe_set_mac_address,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= fe_do_ioctl,
-	.ndo_change_mtu		= fe_change_mtu,
-	.ndo_tx_timeout		= fe_tx_timeout,
-	.ndo_get_stats64        = fe_get_stats64,
-	.ndo_vlan_rx_add_vid	= fe_vlan_rx_add_vid,
-	.ndo_vlan_rx_kill_vid	= fe_vlan_rx_kill_vid,
 #ifdef CONFIG_NET_POLL_CONTROLLER
-	.ndo_poll_controller	= fe_poll_controller,
-#endif
-#ifdef CONFIG_NET_MEDIATEK_OFFLOAD
-	.ndo_flow_offload	= fe_flow_offload,
+static void mtk_poll_controller(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
+	mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
+	mtk_handle_irq_rx(eth->irq[2], dev);
+	mtk_tx_irq_enable(eth, MTK_TX_DONE_INT);
+	mtk_rx_irq_enable(eth, MTK_RX_DONE_INT);
+}
 #endif
-};
 
-static void fe_reset_pending(struct fe_priv *priv)
+static int mtk_start_dma(struct mtk_eth *eth)
 {
-	struct net_device *dev = priv->netdev;
 	int err;
 
+	err = mtk_dma_init(eth);
+	if (err) {
+		mtk_dma_free(eth);
+		return err;
+	}
+
+	mtk_w32(eth,
+		MTK_TX_WB_DDONE | MTK_TX_DMA_EN |
+		MTK_DMA_SIZE_16DWORDS | MTK_NDP_CO_PRO |
+		MTK_RX_DMA_EN | MTK_RX_2B_OFFSET |
+		MTK_RX_BT_32DWORDS,
+		MTK_QDMA_GLO_CFG);
+
+	mtk_w32(eth,
+		MTK_RX_DMA_EN | MTK_RX_2B_OFFSET |
+		MTK_RX_BT_32DWORDS | MTK_MULTI_EN,
+		MTK_PDMA_GLO_CFG);
+
+	return 0;
+}
+
+static int mtk_open(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	/* we run 2 netdevs on the same dma ring so we only bring it up once */
+	if (!atomic_read(&eth->dma_refcnt)) {
+		int err = mtk_start_dma(eth);
+
+		if (err)
+			return err;
+
+		napi_enable(&eth->tx_napi);
+		napi_enable(&eth->rx_napi);
+		mtk_tx_irq_enable(eth, MTK_TX_DONE_INT);
+		mtk_rx_irq_enable(eth, MTK_RX_DONE_INT);
+	}
+	atomic_inc(&eth->dma_refcnt);
+
+	phy_start(dev->phydev);
+	netif_start_queue(dev);
+
+	return 0;
+}
+
+static void mtk_stop_dma(struct mtk_eth *eth, u32 glo_cfg)
+{
+	u32 val;
+	int i;
+
+	/* stop the dma engine */
+	spin_lock_bh(&eth->page_lock);
+	val = mtk_r32(eth, glo_cfg);
+	mtk_w32(eth, val & ~(MTK_TX_WB_DDONE | MTK_RX_DMA_EN | MTK_TX_DMA_EN),
+		glo_cfg);
+	spin_unlock_bh(&eth->page_lock);
+
+	/* wait for dma stop */
+	for (i = 0; i < 10; i++) {
+		val = mtk_r32(eth, glo_cfg);
+		if (val & (MTK_TX_DMA_BUSY | MTK_RX_DMA_BUSY)) {
+			if (in_atomic())
+				mdelay(20);
+			else
+				msleep(20);
+			continue;
+		}
+		break;
+	}
+}
+
+static int mtk_stop(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	netif_tx_disable(dev);
+	phy_stop(dev->phydev);
+
+	/* only shutdown DMA if this is the last user */
+	if (!atomic_dec_and_test(&eth->dma_refcnt))
+		return 0;
+
+	mtk_tx_irq_disable(eth, MTK_TX_DONE_INT);
+	mtk_rx_irq_disable(eth, MTK_RX_DONE_INT);
+	napi_disable(&eth->tx_napi);
+	napi_disable(&eth->rx_napi);
+
+	mtk_stop_dma(eth, MTK_QDMA_GLO_CFG);
+	mtk_stop_dma(eth, MTK_PDMA_GLO_CFG);
+
+	mtk_dma_free(eth);
+
+	return 0;
+}
+
+static void ethsys_reset(struct mtk_eth *eth, u32 reset_bits)
+{
+	regmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL,
+			   reset_bits,
+			   reset_bits);
+
+	if (in_atomic())
+		udelay(1000);
+	else
+		usleep_range(1000, 1100);
+	regmap_update_bits(eth->ethsys, ETHSYS_RSTCTRL,
+			   reset_bits,
+			   ~reset_bits);
+	mdelay(10);
+}
+
+static void mtk_clk_disable(struct mtk_eth *eth)
+{
+	int clk;
+
+	for (clk = MTK_CLK_MAX - 1; clk >= 0; clk--)
+		clk_disable_unprepare(eth->clks[clk]);
+}
+
+static int mtk_clk_enable(struct mtk_eth *eth)
+{
+	int clk, ret;
+
+	for (clk = 0; clk < MTK_CLK_MAX ; clk++) {
+		ret = clk_prepare_enable(eth->clks[clk]);
+		if (ret)
+			goto err_disable_clks;
+	}
+
+	return 0;
+
+err_disable_clks:
+	while (--clk >= 0)
+		clk_disable_unprepare(eth->clks[clk]);
+
+	return ret;
+}
+
+static int mtk_hw_init(struct mtk_eth *eth)
+{
+	int i, val, ret;
+
+	if (test_and_set_bit(MTK_HW_INIT, &eth->state))
+		return 0;
+
+	pm_runtime_enable(eth->dev);
+	pm_runtime_get_sync(eth->dev);
+
+	ret = mtk_clk_enable(eth);
+	if (ret)
+		goto err_disable_pm;
+
+	ethsys_reset(eth, RSTCTRL_FE);
+	ethsys_reset(eth, RSTCTRL_PPE);
+
+	regmap_read(eth->ethsys, ETHSYS_SYSCFG0, &val);
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->mac[i])
+			continue;
+		val &= ~SYSCFG0_GE_MODE(SYSCFG0_GE_MASK, eth->mac[i]->id);
+		val |= SYSCFG0_GE_MODE(eth->mac[i]->ge_mode, eth->mac[i]->id);
+	}
+	regmap_write(eth->ethsys, ETHSYS_SYSCFG0, val);
+
+	if (eth->pctl) {
+		/* Set GE2 driving and slew rate */
+		regmap_write(eth->pctl, GPIO_DRV_SEL10, 0xa00);
+
+		/* set GE2 TDSEL */
+		regmap_write(eth->pctl, GPIO_OD33_CTRL8, 0x5);
+
+		/* set GE2 TUNE */
+		regmap_write(eth->pctl, GPIO_BIAS_CTRL, 0x0);
+	}
+
+	/* Set linkdown as the default for each GMAC. Its own MCR would be set
+	 * up with the more appropriate value when mtk_phy_link_adjust call is
+	 * being invoked.
+	 */
+	for (i = 0; i < MTK_MAC_COUNT; i++)
+		mtk_w32(eth, 0, MTK_MAC_MCR(i));
+
+	/* Indicates CDM to parse the MTK special tag from CPU
+	 * which also is working out for untag packets.
+	 */
+	val = mtk_r32(eth, MTK_CDMQ_IG_CTRL);
+	mtk_w32(eth, val | MTK_CDMQ_STAG_EN, MTK_CDMQ_IG_CTRL);
+	val = mtk_r32(eth, MTK_CDMP_IG_CTRL);
+	mtk_w32(eth, val | MTK_CDMP_STAG_EN, MTK_CDMP_IG_CTRL);
+
+	/* Enable RX VLan Offloading */
+	if (MTK_HW_FEATURES & NETIF_F_HW_VLAN_CTAG_RX)
+		mtk_w32(eth, 1, MTK_CDMP_EG_CTRL);
+	else
+		mtk_w32(eth, 0, MTK_CDMP_EG_CTRL);
+
+	/* enable interrupt delay for RX */
+	mtk_w32(eth, MTK_PDMA_DELAY_RX_DELAY, MTK_PDMA_DELAY_INT);
+	//mtk_w32(eth, MTK_PDMA_DELAY_RX_DELAY, MTK_QDMA_DELAY_INT);
+
+	/* disable delay and normal interrupt */
+	mtk_w32(eth, 0, MTK_QDMA_DELAY_INT);
+	mtk_tx_irq_disable(eth, ~0);
+	mtk_rx_irq_disable(eth, ~0);
+	mtk_w32(eth, RST_GL_PSE, MTK_RST_GL);
+	mtk_w32(eth, 0, MTK_RST_GL);
+
+	/* FE int grouping */
+	mtk_w32(eth, MTK_TX_DONE_INT, MTK_PDMA_INT_GRP1);
+	mtk_w32(eth, MTK_RX_DONE_INT, MTK_PDMA_INT_GRP2);
+	mtk_w32(eth, MTK_TX_DONE_INT, MTK_QDMA_INT_GRP1);
+	mtk_w32(eth, MTK_RX_DONE_INT, MTK_QDMA_INT_GRP2);
+	mtk_w32(eth, 0x21021000, MTK_FE_INT_GRP);
+
+	for (i = 0; i < 2; i++) {
+		u32 val = mtk_r32(eth, MTK_GDMA_FWD_CFG(i));
+
+		/* setup the forward port to send frame to PDMA */
+		val &= ~0xffff;
+
+		/* Enable RX checksum */
+		val |= MTK_GDMA_ICS_EN | MTK_GDMA_TCS_EN | MTK_GDMA_UCS_EN;
+
+		/* setup the mac dma */
+		mtk_w32(eth, val, MTK_GDMA_FWD_CFG(i));
+	}
+
+	return 0;
+
+err_disable_pm:
+	pm_runtime_put_sync(eth->dev);
+	pm_runtime_disable(eth->dev);
+
+	return ret;
+}
+
+static int mtk_hw_deinit(struct mtk_eth *eth)
+{
+	if (!test_and_clear_bit(MTK_HW_INIT, &eth->state))
+		return 0;
+
+	mtk_clk_disable(eth);
+
+	pm_runtime_put_sync(eth->dev);
+	pm_runtime_disable(eth->dev);
+
+	return 0;
+}
+
+static int __init mtk_init(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+	const char *mac_addr;
+
+	mac_addr = of_get_mac_address(mac->of_node);
+	if (mac_addr)
+		ether_addr_copy(dev->dev_addr, mac_addr);
+
+	/* If the mac address is invalid, use random mac address  */
+	if (!is_valid_ether_addr(dev->dev_addr)) {
+		eth_hw_addr_random(dev);
+		dev_err(eth->dev, "generated random MAC address %pM\n",
+			dev->dev_addr);
+	}
+
+	return mtk_phy_connect(dev);
+}
+
+static void mtk_uninit(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_eth *eth = mac->hw;
+
+	phy_disconnect(dev->phydev);
+	if (of_phy_is_fixed_link(mac->of_node))
+		of_phy_deregister_fixed_link(mac->of_node);
+	mtk_tx_irq_disable(eth, ~0);
+	mtk_rx_irq_disable(eth, ~0);
+}
+
+static int mtk_do_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	switch (cmd) {
+	case SIOCGMIIPHY:
+	case SIOCGMIIREG:
+	case SIOCSMIIREG:
+		return phy_mii_ioctl(dev->phydev, ifr, cmd);
+	default:
+		break;
+	}
+
+	return -EOPNOTSUPP;
+}
+
+static void mtk_pending_work(struct work_struct *work)
+{
+	struct mtk_eth *eth = container_of(work, struct mtk_eth, pending_work);
+	int err, i;
+	unsigned long restart = 0;
+
 	rtnl_lock();
-	fe_stop(dev);
 
-	err = fe_open(dev);
-	if (err) {
-		netif_alert(priv, ifup, dev,
-			    "Driver up/down cycle failed, closing device.\n");
-		dev_close(dev);
+	dev_dbg(eth->dev, "[%s][%d] reset\n", __func__, __LINE__);
+
+	while (test_and_set_bit_lock(MTK_RESETTING, &eth->state))
+		cpu_relax();
+
+	dev_dbg(eth->dev, "[%s][%d] mtk_stop starts\n", __func__, __LINE__);
+	/* stop all devices to make sure that dma is properly shut down */
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		mtk_stop(eth->netdev[i]);
+		__set_bit(i, &restart);
+	}
+	dev_dbg(eth->dev, "[%s][%d] mtk_stop ends\n", __func__, __LINE__);
+
+	/* restart underlying hardware such as power, clock, pin mux
+	 * and the connected phy
+	 */
+	mtk_hw_deinit(eth);
+
+	if (eth->dev->pins)
+		pinctrl_select_state(eth->dev->pins->p,
+				     eth->dev->pins->default_state);
+	mtk_hw_init(eth);
+
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->mac[i] ||
+		    of_phy_is_fixed_link(eth->mac[i]->of_node))
+			continue;
+		err = phy_init_hw(eth->netdev[i]->phydev);
+		if (err)
+			dev_err(eth->dev, "%s: PHY init failed.\n",
+				eth->netdev[i]->name);
 	}
+
+	/* restart DMA and enable IRQs */
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!test_bit(i, &restart))
+			continue;
+		err = mtk_open(eth->netdev[i]);
+		if (err) {
+			netif_alert(eth, ifup, eth->netdev[i],
+			      "Driver up/down cycle failed, closing device.\n");
+			dev_close(eth->netdev[i]);
+		}
+	}
+
+	dev_dbg(eth->dev, "[%s][%d] reset done\n", __func__, __LINE__);
+
+	clear_bit_unlock(MTK_RESETTING, &eth->state);
+
 	rtnl_unlock();
 }
 
-static const struct fe_work_t fe_work[] = {
-	{FE_FLAG_RESET_PENDING, fe_reset_pending},
-};
+static int mtk_free_dev(struct mtk_eth *eth)
+{
+	int i;
 
-static void fe_pending_work(struct work_struct *work)
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		free_netdev(eth->netdev[i]);
+	}
+
+	return 0;
+}
+
+static int mtk_unreg_dev(struct mtk_eth *eth)
 {
-	struct fe_priv *priv = container_of(work, struct fe_priv, pending_work);
 	int i;
-	bool pending;
 
-	for (i = 0; i < ARRAY_SIZE(fe_work); i++) {
-		pending = test_and_clear_bit(fe_work[i].bitnr,
-					     priv->pending_flags);
-		if (pending)
-			fe_work[i].action(priv);
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		unregister_netdev(eth->netdev[i]);
 	}
+
+	return 0;
 }
 
-static int fe_probe(struct platform_device *pdev)
+static int mtk_cleanup(struct mtk_eth *eth)
 {
-	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	const struct of_device_id *match;
-	struct fe_soc_data *soc;
-	struct net_device *netdev;
-	struct fe_priv *priv;
-	struct clk *sysclk;
-	int err, napi_weight;
+	mtk_unreg_dev(eth);
+	mtk_free_dev(eth);
+	cancel_work_sync(&eth->pending_work);
 
-	device_reset(&pdev->dev);
+	return 0;
+}
+
+static int mtk_get_link_ksettings(struct net_device *ndev,
+				  struct ethtool_link_ksettings *cmd)
+{
+	struct mtk_mac *mac = netdev_priv(ndev);
 
-	match = of_match_device(of_fe_match, &pdev->dev);
-	soc = (struct fe_soc_data *)match->data;
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return -EBUSY;
 
-	if (soc->reg_table)
-		fe_reg_table = soc->reg_table;
-	else
-		soc->reg_table = fe_reg_table;
+	phy_ethtool_ksettings_get(ndev->phydev, cmd);
+
+	return 0;
+}
+
+static int mtk_set_link_ksettings(struct net_device *ndev,
+				  const struct ethtool_link_ksettings *cmd)
+{
+	struct mtk_mac *mac = netdev_priv(ndev);
+
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return -EBUSY;
+
+	return phy_ethtool_ksettings_set(ndev->phydev, cmd);
+}
+
+static void mtk_get_drvinfo(struct net_device *dev,
+			    struct ethtool_drvinfo *info)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+
+	strlcpy(info->driver, mac->hw->dev->driver->name, sizeof(info->driver));
+	strlcpy(info->bus_info, dev_name(mac->hw->dev), sizeof(info->bus_info));
+	info->n_stats = ARRAY_SIZE(mtk_ethtool_stats);
+}
+
+static u32 mtk_get_msglevel(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+
+	return mac->hw->msg_enable;
+}
+
+static void mtk_set_msglevel(struct net_device *dev, u32 value)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+
+	mac->hw->msg_enable = value;
+}
+
+static int mtk_nway_reset(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return -EBUSY;
+
+	return genphy_restart_aneg(dev->phydev);
+}
+
+static u32 mtk_get_link(struct net_device *dev)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	int err;
+
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return -EBUSY;
+
+	err = genphy_update_link(dev->phydev);
+	if (err)
+		return ethtool_op_get_link(dev);
+
+	return dev->phydev->link;
+}
+
+static void mtk_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	int i;
 
-	fe_base = devm_ioremap_resource(&pdev->dev, res);
-	if (IS_ERR(fe_base)) {
-		err = -EADDRNOTAVAIL;
-		goto err_out;
+	switch (stringset) {
+	case ETH_SS_STATS:
+		for (i = 0; i < ARRAY_SIZE(mtk_ethtool_stats); i++) {
+			memcpy(data, mtk_ethtool_stats[i].str, ETH_GSTRING_LEN);
+			data += ETH_GSTRING_LEN;
+		}
+		break;
 	}
+}
 
-	netdev = alloc_etherdev(sizeof(*priv));
-	if (!netdev) {
-		dev_err(&pdev->dev, "alloc_etherdev failed\n");
+static int mtk_get_sset_count(struct net_device *dev, int sset)
+{
+	switch (sset) {
+	case ETH_SS_STATS:
+		return ARRAY_SIZE(mtk_ethtool_stats);
+	default:
+		return -EOPNOTSUPP;
+	}
+}
+
+static void mtk_get_ethtool_stats(struct net_device *dev,
+				  struct ethtool_stats *stats, u64 *data)
+{
+	struct mtk_mac *mac = netdev_priv(dev);
+	struct mtk_hw_stats *hwstats = mac->hw_stats;
+	u64 *data_src, *data_dst;
+	unsigned int start;
+	int i;
+
+	if (unlikely(test_bit(MTK_RESETTING, &mac->hw->state)))
+		return;
+
+	if (netif_running(dev) && netif_device_present(dev)) {
+		if (spin_trylock_bh(&hwstats->stats_lock)) {
+			mtk_stats_update_mac(mac);
+			spin_unlock_bh(&hwstats->stats_lock);
+		}
+	}
+
+	data_src = (u64 *)hwstats;
+
+	do {
+		data_dst = data;
+		start = u64_stats_fetch_begin_irq(&hwstats->syncp);
+
+		for (i = 0; i < ARRAY_SIZE(mtk_ethtool_stats); i++)
+			*data_dst++ = *(data_src + mtk_ethtool_stats[i].offset);
+	} while (u64_stats_fetch_retry_irq(&hwstats->syncp, start));
+}
+
+static int mtk_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+			 u32 *rule_locs)
+{
+	int ret = -EOPNOTSUPP;
+
+	switch (cmd->cmd) {
+	case ETHTOOL_GRXRINGS:
+		if (dev->features & NETIF_F_LRO) {
+			cmd->data = MTK_MAX_RX_RING_NUM;
+			ret = 0;
+		}
+		break;
+	case ETHTOOL_GRXCLSRLCNT:
+		if (dev->features & NETIF_F_LRO) {
+			struct mtk_mac *mac = netdev_priv(dev);
+
+			cmd->rule_cnt = mac->hwlro_ip_cnt;
+			ret = 0;
+		}
+		break;
+	case ETHTOOL_GRXCLSRULE:
+		if (dev->features & NETIF_F_LRO)
+			ret = mtk_hwlro_get_fdir_entry(dev, cmd);
+		break;
+	case ETHTOOL_GRXCLSRLALL:
+		if (dev->features & NETIF_F_LRO)
+			ret = mtk_hwlro_get_fdir_all(dev, cmd,
+						     rule_locs);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static int mtk_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
+{
+	int ret = -EOPNOTSUPP;
+
+	switch (cmd->cmd) {
+	case ETHTOOL_SRXCLSRLINS:
+		if (dev->features & NETIF_F_LRO)
+			ret = mtk_hwlro_add_ipaddr(dev, cmd);
+		break;
+	case ETHTOOL_SRXCLSRLDEL:
+		if (dev->features & NETIF_F_LRO)
+			ret = mtk_hwlro_del_ipaddr(dev, cmd);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+}
+
+static const struct ethtool_ops mtk_ethtool_ops = {
+	.get_link_ksettings	= mtk_get_link_ksettings,
+	.set_link_ksettings	= mtk_set_link_ksettings,
+	.get_drvinfo		= mtk_get_drvinfo,
+	.get_msglevel		= mtk_get_msglevel,
+	.set_msglevel		= mtk_set_msglevel,
+	.nway_reset		= mtk_nway_reset,
+	.get_link		= mtk_get_link,
+	.get_strings		= mtk_get_strings,
+	.get_sset_count		= mtk_get_sset_count,
+	.get_ethtool_stats	= mtk_get_ethtool_stats,
+	.get_rxnfc		= mtk_get_rxnfc,
+	.set_rxnfc              = mtk_set_rxnfc,
+};
+
+static const struct net_device_ops mtk_netdev_ops = {
+	.ndo_init		= mtk_init,
+	.ndo_uninit		= mtk_uninit,
+	.ndo_open		= mtk_open,
+	.ndo_stop		= mtk_stop,
+	.ndo_start_xmit		= mtk_start_xmit,
+	.ndo_set_mac_address	= mtk_set_mac_address,
+	.ndo_validate_addr	= eth_validate_addr,
+	.ndo_do_ioctl		= mtk_do_ioctl,
+	.ndo_tx_timeout		= mtk_tx_timeout,
+	.ndo_get_stats64        = mtk_get_stats64,
+	.ndo_fix_features	= mtk_fix_features,
+	.ndo_set_features	= mtk_set_features,
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	.ndo_poll_controller	= mtk_poll_controller,
+#endif
+};
+
+static int mtk_add_mac(struct mtk_eth *eth, struct device_node *np)
+{
+	struct mtk_mac *mac;
+	const __be32 *_id = of_get_property(np, "reg", NULL);
+	int id, err;
+
+	if (!_id) {
+		dev_err(eth->dev, "missing mac id\n");
+		return -EINVAL;
+	}
+
+	id = be32_to_cpup(_id);
+	if (id >= MTK_MAC_COUNT) {
+		dev_err(eth->dev, "%d is not a valid mac id\n", id);
+		return -EINVAL;
+	}
+
+	if (eth->netdev[id]) {
+		dev_err(eth->dev, "duplicate mac id found: %d\n", id);
+		return -EINVAL;
+	}
+
+	eth->netdev[id] = alloc_etherdev(sizeof(*mac));
+	if (!eth->netdev[id]) {
+		dev_err(eth->dev, "alloc_etherdev failed\n");
+		return -ENOMEM;
+	}
+	mac = netdev_priv(eth->netdev[id]);
+	eth->mac[id] = mac;
+	mac->id = id;
+	mac->hw = eth;
+	mac->of_node = np;
+
+	memset(mac->hwlro_ip, 0, sizeof(mac->hwlro_ip));
+	mac->hwlro_ip_cnt = 0;
+
+	mac->hw_stats = devm_kzalloc(eth->dev,
+				     sizeof(*mac->hw_stats),
+				     GFP_KERNEL);
+	if (!mac->hw_stats) {
+		dev_err(eth->dev, "failed to allocate counter memory\n");
 		err = -ENOMEM;
-		goto err_iounmap;
+		goto free_netdev;
 	}
+	spin_lock_init(&mac->hw_stats->stats_lock);
+	u64_stats_init(&mac->hw_stats->syncp);
+	mac->hw_stats->reg_offset = id * MTK_STAT_OFFSET;
 
-	SET_NETDEV_DEV(netdev, &pdev->dev);
-	netdev->netdev_ops = &fe_netdev_ops;
-	netdev->base_addr = (unsigned long)fe_base;
+	SET_NETDEV_DEV(eth->netdev[id], eth->dev);
+	eth->netdev[id]->watchdog_timeo = 30 * HZ;
+	eth->netdev[id]->netdev_ops = &mtk_netdev_ops;
+	eth->netdev[id]->base_addr = (unsigned long)eth->base;
 
-	netdev->irq = platform_get_irq(pdev, 0);
-	if (netdev->irq < 0) {
-		dev_err(&pdev->dev, "no IRQ resource found\n");
-		err = -ENXIO;
-		goto err_free_dev;
+	eth->netdev[id]->hw_features = MTK_HW_FEATURES;
+	if (eth->hwlro)
+		eth->netdev[id]->hw_features |= NETIF_F_LRO;
+
+	eth->netdev[id]->vlan_features = MTK_HW_FEATURES &
+		~(NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_HW_VLAN_CTAG_RX);
+	eth->netdev[id]->features |= MTK_HW_FEATURES;
+	eth->netdev[id]->ethtool_ops = &mtk_ethtool_ops;
+
+	eth->netdev[id]->irq = eth->irq[0];
+	eth->netdev[id]->dev.of_node = np;
+
+	return 0;
+
+free_netdev:
+	free_netdev(eth->netdev[id]);
+	return err;
+}
+
+static int mtk_get_chip_id(struct mtk_eth *eth, u32 *chip_id)
+{
+	u32 val[2], id[4];
+
+	regmap_read(eth->ethsys, ETHSYS_CHIPID0_3, &val[0]);
+	regmap_read(eth->ethsys, ETHSYS_CHIPID4_7, &val[1]);
+
+	id[3] = ((val[0] >> 16) & 0xff) - '0';
+	id[2] = ((val[0] >> 24) & 0xff) - '0';
+	id[1] = (val[1] & 0xff) - '0';
+	id[0] = ((val[1] >> 8) & 0xff) - '0';
+
+	*chip_id = (id[3] * 1000) + (id[2] * 100) +
+		   (id[1] * 10) + id[0];
+
+	if (!(*chip_id)) {
+		dev_err(eth->dev, "failed to get chip id\n");
+		return -ENODEV;
 	}
 
-	if (soc->init_data)
-		soc->init_data(soc, netdev);
-	netdev->vlan_features = netdev->hw_features & ~NETIF_F_HW_VLAN_CTAG_TX;
-	netdev->features |= netdev->hw_features;
+	dev_info(eth->dev, "chip id = %d\n", *chip_id);
 
-	if (IS_ENABLED(CONFIG_SOC_MT7621))
-		netdev->max_mtu = 2048;
+	return 0;
+}
 
-	/* fake rx vlan filter func. to support tx vlan offload func */
-	if (fe_reg_table[FE_REG_FE_DMA_VID_BASE])
-		netdev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+static bool mtk_is_hwlro_supported(struct mtk_eth *eth)
+{
+	switch (eth->chip_id) {
+	case MT7622_ETH:
+	case MT7623_ETH:
+		return true;
+	}
+
+	return false;
+}
 
-	priv = netdev_priv(netdev);
-	spin_lock_init(&priv->page_lock);
-	if (fe_reg_table[FE_REG_FE_COUNTER_BASE]) {
-		priv->hw_stats = kzalloc(sizeof(*priv->hw_stats), GFP_KERNEL);
-		if (!priv->hw_stats) {
-			err = -ENOMEM;
-			goto err_free_dev;
+static int mtk_probe(struct platform_device *pdev)
+{
+	struct resource *res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	struct device_node *mac_np;
+	const struct of_device_id *match;
+	struct mtk_eth *eth;
+	int err;
+	int i;
+
+	eth = devm_kzalloc(&pdev->dev, sizeof(*eth), GFP_KERNEL);
+	if (!eth)
+		return -ENOMEM;
+
+	match = of_match_device(of_mtk_match, &pdev->dev);
+	eth->soc = (struct mtk_soc_data *)match->data;
+
+	eth->dev = &pdev->dev;
+	eth->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(eth->base))
+		return PTR_ERR(eth->base);
+
+	spin_lock_init(&eth->page_lock);
+	spin_lock_init(&eth->tx_irq_lock);
+	spin_lock_init(&eth->rx_irq_lock);
+
+	eth->ethsys = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+						      "mediatek,ethsys");
+	if (IS_ERR(eth->ethsys)) {
+		dev_err(&pdev->dev, "no ethsys regmap found\n");
+		return PTR_ERR(eth->ethsys);
+	}
+
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_SGMII)) {
+		eth->sgmiisys =
+		syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+						"mediatek,sgmiisys");
+		if (IS_ERR(eth->sgmiisys)) {
+			dev_err(&pdev->dev, "no sgmiisys regmap found\n");
+			return PTR_ERR(eth->sgmiisys);
 		}
-		spin_lock_init(&priv->hw_stats->stats_lock);
 	}
 
-	sysclk = devm_clk_get(&pdev->dev, NULL);
-	if (!IS_ERR(sysclk)) {
-		priv->sysclk = clk_get_rate(sysclk);
-	} else if ((priv->flags & FE_FLAG_CALIBRATE_CLK)) {
-		dev_err(&pdev->dev, "this soc needs a clk for calibration\n");
-		err = -ENXIO;
-		goto err_free_dev;
+	if (eth->soc->required_pctl) {
+		eth->pctl = syscon_regmap_lookup_by_phandle(pdev->dev.of_node,
+							    "mediatek,pctl");
+		if (IS_ERR(eth->pctl)) {
+			dev_err(&pdev->dev, "no pctl regmap found\n");
+			return PTR_ERR(eth->pctl);
+		}
 	}
 
-	priv->switch_np = of_parse_phandle(pdev->dev.of_node, "mediatek,switch", 0);
-	if ((priv->flags & FE_FLAG_HAS_SWITCH) && !priv->switch_np) {
-		dev_err(&pdev->dev, "failed to read switch phandle\n");
-		err = -ENODEV;
-		goto err_free_dev;
+	for (i = 0; i < 3; i++) {
+		eth->irq[i] = platform_get_irq(pdev, i);
+		if (eth->irq[i] < 0) {
+			dev_err(&pdev->dev, "no IRQ%d resource found\n", i);
+			return -ENXIO;
+		}
 	}
+	for (i = 0; i < ARRAY_SIZE(eth->clks); i++) {
+		eth->clks[i] = devm_clk_get(eth->dev,
+					    mtk_clks_source_name[i]);
+		if (IS_ERR(eth->clks[i])) {
+			if (PTR_ERR(eth->clks[i]) == -EPROBE_DEFER)
+				return -EPROBE_DEFER;
+			if (eth->soc->required_clks & BIT(i)) {
+				dev_err(&pdev->dev, "clock %s not found\n",
+					mtk_clks_source_name[i]);
+				return -EINVAL;
+			}
+			eth->clks[i] = NULL;
+		}
+	}
+
+	eth->msg_enable = netif_msg_init(mtk_msg_level, MTK_DEFAULT_MSG_ENABLE);
+	INIT_WORK(&eth->pending_work, mtk_pending_work);
+
+	err = mtk_hw_init(eth);
+	if (err)
+		return err;
+
+	err = mtk_get_chip_id(eth, &eth->chip_id);
+	if (err)
+		return err;
+
+	eth->hwlro = mtk_is_hwlro_supported(eth);
+
+	for_each_child_of_node(pdev->dev.of_node, mac_np) {
+		if (!of_device_is_compatible(mac_np,
+					     "mediatek,eth-mac"))
+			continue;
 
-	priv->netdev = netdev;
-	priv->dev = &pdev->dev;
-	priv->soc = soc;
-	priv->msg_enable = netif_msg_init(fe_msg_level, FE_DEFAULT_MSG_ENABLE);
-	priv->rx_ring.frag_size = fe_max_frag_size(ETH_DATA_LEN);
-	priv->rx_ring.rx_buf_size = fe_max_buf_size(priv->rx_ring.frag_size);
-	priv->tx_ring.tx_ring_size = NUM_DMA_DESC;
-	priv->rx_ring.rx_ring_size = NUM_DMA_DESC;
-	INIT_WORK(&priv->pending_work, fe_pending_work);
-	u64_stats_init(&priv->hw_stats->syncp);
+		if (!of_device_is_available(mac_np))
+			continue;
 
-	napi_weight = 16;
-	if (priv->flags & FE_FLAG_NAPI_WEIGHT) {
-		napi_weight *= 4;
-		priv->tx_ring.tx_ring_size *= 4;
-		priv->rx_ring.rx_ring_size *= 4;
+		err = mtk_add_mac(eth, mac_np);
+		if (err)
+			goto err_deinit_hw;
 	}
-	netif_napi_add(netdev, &priv->rx_napi, fe_poll, napi_weight);
-	fe_set_ethtool_ops(netdev);
 
-	err = register_netdev(netdev);
-	if (err) {
-		dev_err(&pdev->dev, "error bringing up device\n");
+	err = devm_request_irq(eth->dev, eth->irq[1], mtk_handle_irq_tx, 0,
+			       dev_name(eth->dev), eth);
+	if (err)
+		goto err_free_dev;
+
+	err = devm_request_irq(eth->dev, eth->irq[2], mtk_handle_irq_rx, 0,
+			       dev_name(eth->dev), eth);
+	if (err)
 		goto err_free_dev;
+
+	err = mtk_mdio_init(eth);
+	if (err)
+		goto err_free_dev;
+
+	for (i = 0; i < MTK_MAX_DEVS; i++) {
+		if (!eth->netdev[i])
+			continue;
+
+		err = register_netdev(eth->netdev[i]);
+		if (err) {
+			dev_err(eth->dev, "error bringing up device\n");
+			goto err_deinit_mdio;
+		} else
+			netif_info(eth, probe, eth->netdev[i],
+				   "mediatek frame engine at 0x%08lx, irq %d\n",
+				   eth->netdev[i]->base_addr, eth->irq[0]);
 	}
 
-	platform_set_drvdata(pdev, netdev);
+	/* we run 2 devices on the same DMA ring so we need a dummy device
+	 * for NAPI to work
+	 */
+	init_dummy_netdev(&eth->dummy_dev);
+	netif_napi_add(&eth->dummy_dev, &eth->tx_napi, mtk_napi_tx,
+		       MTK_NAPI_WEIGHT);
+	netif_napi_add(&eth->dummy_dev, &eth->rx_napi, mtk_napi_rx,
+		       MTK_NAPI_WEIGHT);
 
-	netif_info(priv, probe, netdev, "mediatek frame engine at 0x%08lx, irq %d\n",
-		   netdev->base_addr, netdev->irq);
+	platform_set_drvdata(pdev, eth);
 
 	return 0;
 
+err_deinit_mdio:
+	mtk_mdio_cleanup(eth);
 err_free_dev:
-	free_netdev(netdev);
-err_iounmap:
-	devm_iounmap(&pdev->dev, fe_base);
-err_out:
+	mtk_free_dev(eth);
+err_deinit_hw:
+	mtk_hw_deinit(eth);
+
 	return err;
 }
 
-static int fe_remove(struct platform_device *pdev)
+static int mtk_remove(struct platform_device *pdev)
 {
-	struct net_device *dev = platform_get_drvdata(pdev);
-	struct fe_priv *priv = netdev_priv(dev);
+	struct mtk_eth *eth = platform_get_drvdata(pdev);
+	int i;
 
-	netif_napi_del(&priv->rx_napi);
-	kfree(priv->hw_stats);
+	/* stop all devices to make sure that dma is properly shut down */
+	for (i = 0; i < MTK_MAC_COUNT; i++) {
+		if (!eth->netdev[i])
+			continue;
+		mtk_stop(eth->netdev[i]);
+	}
 
-	cancel_work_sync(&priv->pending_work);
+	mtk_hw_deinit(eth);
 
-	unregister_netdev(dev);
-	free_netdev(dev);
-	platform_set_drvdata(pdev, NULL);
+	netif_napi_del(&eth->tx_napi);
+	netif_napi_del(&eth->rx_napi);
+	mtk_cleanup(eth);
+	mtk_mdio_cleanup(eth);
 
 	return 0;
 }
 
-static struct platform_driver fe_driver = {
-	.probe = fe_probe,
-	.remove = fe_remove,
+static const struct mtk_soc_data mt2701_data = {
+	.caps = MTK_GMAC1_TRGMII,
+	.required_clks = MT7623_CLKS_BITMAP,
+	.required_pctl = true,
+};
+
+static const struct mtk_soc_data mt7622_data = {
+	.caps = MTK_DUAL_GMAC_SHARED_SGMII | MTK_GMAC1_ESW,
+	.required_clks = MT7622_CLKS_BITMAP,
+	.required_pctl = false,
+};
+
+static const struct mtk_soc_data mt7623_data = {
+	.caps = MTK_GMAC1_TRGMII,
+	.required_clks = MT7623_CLKS_BITMAP,
+	.required_pctl = true,
+};
+
+const struct of_device_id of_mtk_match[] = {
+	{ .compatible = "mediatek,mt2701-eth", .data = &mt2701_data},
+	{ .compatible = "mediatek,mt7622-eth", .data = &mt7622_data},
+	{ .compatible = "mediatek,mt7623-eth", .data = &mt7623_data},
+	{},
+};
+MODULE_DEVICE_TABLE(of, of_mtk_match);
+
+static struct platform_driver mtk_driver = {
+	.probe = mtk_probe,
+	.remove = mtk_remove,
 	.driver = {
 		.name = "mtk_soc_eth",
-		.owner = THIS_MODULE,
-		.of_match_table = of_fe_match,
+		.of_match_table = of_mtk_match,
 	},
 };
 
-module_platform_driver(fe_driver);
+module_platform_driver(mtk_driver);
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("John Crispin <blogic@openwrt.org>");
-MODULE_DESCRIPTION("Ethernet driver for Ralink SoC");
-MODULE_VERSION(MTK_FE_DRV_VERSION);
+MODULE_DESCRIPTION("Ethernet driver for MediaTek SoC");
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
index c42126116fc6..8c657616a102 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -7,527 +7,683 @@
  *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  *   GNU General Public License for more details.
  *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
+ *   Copyright (C) 2009-2016 John Crispin <blogic@openwrt.org>
+ *   Copyright (C) 2009-2016 Felix Fietkau <nbd@openwrt.org>
+ *   Copyright (C) 2013-2016 Michael Lee <igvtee@gmail.com>
  */
 
-#ifndef FE_ETH_H
-#define FE_ETH_H
-
-#include <linux/mii.h>
-#include <linux/interrupt.h>
-#include <linux/netdevice.h>
-#include <linux/dma-mapping.h>
-#include <linux/phy.h>
-#include <linux/ethtool.h>
-#include <linux/version.h>
-
-enum fe_reg {
-	FE_REG_PDMA_GLO_CFG = 0,
-	FE_REG_PDMA_RST_CFG,
-	FE_REG_DLY_INT_CFG,
-	FE_REG_TX_BASE_PTR0,
-	FE_REG_TX_MAX_CNT0,
-	FE_REG_TX_CTX_IDX0,
-	FE_REG_TX_DTX_IDX0,
-	FE_REG_RX_BASE_PTR0,
-	FE_REG_RX_MAX_CNT0,
-	FE_REG_RX_CALC_IDX0,
-	FE_REG_RX_DRX_IDX0,
-	FE_REG_FE_INT_ENABLE,
-	FE_REG_FE_INT_STATUS,
-	FE_REG_FE_DMA_VID_BASE,
-	FE_REG_FE_COUNTER_BASE,
-	FE_REG_FE_RST_GL,
-	FE_REG_FE_INT_STATUS2,
-	FE_REG_COUNT
-};
+#ifndef MTK_ETH_H
+#define MTK_ETH_H
+
+#define MTK_QDMA_PAGE_SIZE	2048
+#define	MTK_MAX_RX_LENGTH	1536
+#define MTK_TX_DMA_BUF_LEN	0x3fff
+#define MTK_DMA_SIZE		256
+#define MTK_NAPI_WEIGHT		64
+#define MTK_MAC_COUNT		2
+#define MTK_RX_ETH_HLEN		(VLAN_ETH_HLEN + VLAN_HLEN + ETH_FCS_LEN)
+#define MTK_RX_HLEN		(NET_SKB_PAD + MTK_RX_ETH_HLEN + NET_IP_ALIGN)
+#define MTK_DMA_DUMMY_DESC	0xffffffff
+#define MTK_DEFAULT_MSG_ENABLE	(NETIF_MSG_DRV | \
+				 NETIF_MSG_PROBE | \
+				 NETIF_MSG_LINK | \
+				 NETIF_MSG_TIMER | \
+				 NETIF_MSG_IFDOWN | \
+				 NETIF_MSG_IFUP | \
+				 NETIF_MSG_RX_ERR | \
+				 NETIF_MSG_TX_ERR)
+#define MTK_HW_FEATURES		(NETIF_F_IP_CSUM | \
+				 NETIF_F_RXCSUM | \
+				 NETIF_F_SG | NETIF_F_TSO | \
+				 NETIF_F_TSO6 | \
+				 NETIF_F_IPV6_CSUM)
+#define NEXT_RX_DESP_IDX(X, Y)	(((X) + 1) & ((Y) - 1))
+
+#define MTK_MAX_RX_RING_NUM	4
+#define MTK_HW_LRO_DMA_SIZE	8
+
+#define	MTK_MAX_LRO_RX_LENGTH		(4096 * 3)
+#define	MTK_MAX_LRO_IP_CNT		2
+#define	MTK_HW_LRO_TIMER_UNIT		1	/* 20 us */
+#define	MTK_HW_LRO_REFRESH_TIME		50000	/* 1 sec. */
+#define	MTK_HW_LRO_AGG_TIME		10	/* 200us */
+#define	MTK_HW_LRO_AGE_TIME		50	/* 1ms */
+#define	MTK_HW_LRO_MAX_AGG_CNT		64
+#define	MTK_HW_LRO_BW_THRE		3000
+#define	MTK_HW_LRO_REPLACE_DELTA	1000
+#define	MTK_HW_LRO_SDL_REMAIN_ROOM	1522
+
+/* Frame Engine Global Reset Register */
+#define MTK_RST_GL		0x04
+#define RST_GL_PSE		BIT(0)
+
+/* Frame Engine Interrupt Status Register */
+#define MTK_INT_STATUS2		0x08
+#define MTK_GDM1_AF		BIT(28)
+#define MTK_GDM2_AF		BIT(29)
+
+/* PDMA HW LRO Alter Flow Timer Register */
+#define MTK_PDMA_LRO_ALT_REFRESH_TIMER	0x1c
+
+/* Frame Engine Interrupt Grouping Register */
+#define MTK_FE_INT_GRP		0x20
+
+/* CDMP Ingress Control Register */
+#define MTK_CDMQ_IG_CTRL	0x1400
+#define MTK_CDMQ_STAG_EN	BIT(0)
+
+/* CDMP Ingress Control Register */
+#define MTK_CDMP_IG_CTRL	0x400
+#define MTK_CDMP_STAG_EN	BIT(0)
+
+/* CDMP Exgress Control Register */
+#define MTK_CDMP_EG_CTRL	0x404
+
+/* GDM Exgress Control Register */
+#define MTK_GDMA_FWD_CFG(x)	(0x500 + (x * 0x1000))
+#define MTK_GDMA_ICS_EN		BIT(22)
+#define MTK_GDMA_TCS_EN		BIT(21)
+#define MTK_GDMA_UCS_EN		BIT(20)
+
+/* Unicast Filter MAC Address Register - Low */
+#define MTK_GDMA_MAC_ADRL(x)	(0x508 + (x * 0x1000))
+
+/* Unicast Filter MAC Address Register - High */
+#define MTK_GDMA_MAC_ADRH(x)	(0x50C + (x * 0x1000))
+
+/* PDMA RX Base Pointer Register */
+#define MTK_PRX_BASE_PTR0	0x900
+#define MTK_PRX_BASE_PTR_CFG(x)	(MTK_PRX_BASE_PTR0 + (x * 0x10))
+
+/* PDMA RX Maximum Count Register */
+#define MTK_PRX_MAX_CNT0	0x904
+#define MTK_PRX_MAX_CNT_CFG(x)	(MTK_PRX_MAX_CNT0 + (x * 0x10))
+
+/* PDMA RX CPU Pointer Register */
+#define MTK_PRX_CRX_IDX0	0x908
+#define MTK_PRX_CRX_IDX_CFG(x)	(MTK_PRX_CRX_IDX0 + (x * 0x10))
+
+/* PDMA HW LRO Control Registers */
+#define MTK_PDMA_LRO_CTRL_DW0	0x980
+#define MTK_LRO_EN			BIT(0)
+#define MTK_L3_CKS_UPD_EN		BIT(7)
+#define MTK_LRO_ALT_PKT_CNT_MODE	BIT(21)
+#define MTK_LRO_RING_RELINQUISH_REQ	(0x7 << 26)
+#define MTK_LRO_RING_RELINQUISH_DONE	(0x7 << 29)
+
+#define MTK_PDMA_LRO_CTRL_DW1	0x984
+#define MTK_PDMA_LRO_CTRL_DW2	0x988
+#define MTK_PDMA_LRO_CTRL_DW3	0x98c
+#define MTK_ADMA_MODE		BIT(15)
+#define MTK_LRO_MIN_RXD_SDL	(MTK_HW_LRO_SDL_REMAIN_ROOM << 16)
+
+/* PDMA Global Configuration Register */
+#define MTK_PDMA_GLO_CFG	0xa04
+#define MTK_MULTI_EN		BIT(10)
+
+/* PDMA Reset Index Register */
+#define MTK_PDMA_RST_IDX	0xa08
+#define MTK_PST_DRX_IDX0	BIT(16)
+#define MTK_PST_DRX_IDX_CFG(x)	(MTK_PST_DRX_IDX0 << (x))
+
+/* PDMA Delay Interrupt Register */
+#define MTK_PDMA_DELAY_INT		0xa0c
+#define MTK_PDMA_DELAY_RX_EN		BIT(15)
+#define MTK_PDMA_DELAY_RX_PINT		4
+#define MTK_PDMA_DELAY_RX_PINT_SHIFT	8
+#define MTK_PDMA_DELAY_RX_PTIME		4
+#define MTK_PDMA_DELAY_RX_DELAY		\
+	(MTK_PDMA_DELAY_RX_EN | MTK_PDMA_DELAY_RX_PTIME | \
+	(MTK_PDMA_DELAY_RX_PINT << MTK_PDMA_DELAY_RX_PINT_SHIFT))
+
+/* PDMA Interrupt Status Register */
+#define MTK_PDMA_INT_STATUS	0xa20
+
+/* PDMA Interrupt Mask Register */
+#define MTK_PDMA_INT_MASK	0xa28
+
+/* PDMA HW LRO Alter Flow Delta Register */
+#define MTK_PDMA_LRO_ALT_SCORE_DELTA	0xa4c
+
+/* PDMA Interrupt grouping registers */
+#define MTK_PDMA_INT_GRP1	0xa50
+#define MTK_PDMA_INT_GRP2	0xa54
+
+/* PDMA HW LRO IP Setting Registers */
+#define MTK_LRO_RX_RING0_DIP_DW0	0xb04
+#define MTK_LRO_DIP_DW0_CFG(x)		(MTK_LRO_RX_RING0_DIP_DW0 + (x * 0x40))
+#define MTK_RING_MYIP_VLD		BIT(9)
+
+/* PDMA HW LRO Ring Control Registers */
+#define MTK_LRO_RX_RING0_CTRL_DW1	0xb28
+#define MTK_LRO_RX_RING0_CTRL_DW2	0xb2c
+#define MTK_LRO_RX_RING0_CTRL_DW3	0xb30
+#define MTK_LRO_CTRL_DW1_CFG(x)		(MTK_LRO_RX_RING0_CTRL_DW1 + (x * 0x40))
+#define MTK_LRO_CTRL_DW2_CFG(x)		(MTK_LRO_RX_RING0_CTRL_DW2 + (x * 0x40))
+#define MTK_LRO_CTRL_DW3_CFG(x)		(MTK_LRO_RX_RING0_CTRL_DW3 + (x * 0x40))
+#define MTK_RING_AGE_TIME_L		((MTK_HW_LRO_AGE_TIME & 0x3ff) << 22)
+#define MTK_RING_AGE_TIME_H		((MTK_HW_LRO_AGE_TIME >> 10) & 0x3f)
+#define MTK_RING_AUTO_LERAN_MODE	(3 << 6)
+#define MTK_RING_VLD			BIT(8)
+#define MTK_RING_MAX_AGG_TIME		((MTK_HW_LRO_AGG_TIME & 0xffff) << 10)
+#define MTK_RING_MAX_AGG_CNT_L		((MTK_HW_LRO_MAX_AGG_CNT & 0x3f) << 26)
+#define MTK_RING_MAX_AGG_CNT_H		((MTK_HW_LRO_MAX_AGG_CNT >> 6) & 0x3)
+
+/* QDMA TX Queue Configuration Registers */
+#define MTK_QTX_CFG(x)		(0x1800 + (x * 0x10))
+#define QDMA_RES_THRES		4
+
+/* QDMA TX Queue Scheduler Registers */
+#define MTK_QTX_SCH(x)		(0x1804 + (x * 0x10))
+
+/* QDMA RX Base Pointer Register */
+#define MTK_QRX_BASE_PTR0	0x1900
+
+/* QDMA RX Maximum Count Register */
+#define MTK_QRX_MAX_CNT0	0x1904
+
+/* QDMA RX CPU Pointer Register */
+#define MTK_QRX_CRX_IDX0	0x1908
+
+/* QDMA RX DMA Pointer Register */
+#define MTK_QRX_DRX_IDX0	0x190C
+
+/* QDMA Global Configuration Register */
+#define MTK_QDMA_GLO_CFG	0x1A04
+#define MTK_RX_2B_OFFSET	BIT(31)
+#define MTK_RX_BT_32DWORDS	(3 << 11)
+#define MTK_NDP_CO_PRO		BIT(10)
+#define MTK_TX_WB_DDONE		BIT(6)
+#define MTK_DMA_SIZE_16DWORDS	(2 << 4)
+#define MTK_RX_DMA_BUSY		BIT(3)
+#define MTK_TX_DMA_BUSY		BIT(1)
+#define MTK_RX_DMA_EN		BIT(2)
+#define MTK_TX_DMA_EN		BIT(0)
+#define MTK_DMA_BUSY_TIMEOUT	HZ
+
+/* QDMA Reset Index Register */
+#define MTK_QDMA_RST_IDX	0x1A08
+
+/* QDMA Delay Interrupt Register */
+#define MTK_QDMA_DELAY_INT	0x1A0C
+
+/* QDMA Flow Control Register */
+#define MTK_QDMA_FC_THRES	0x1A10
+#define FC_THRES_DROP_MODE	BIT(20)
+#define FC_THRES_DROP_EN	(7 << 16)
+#define FC_THRES_MIN		0x4444
+
+/* QDMA Interrupt Status Register */
+#define MTK_QMTK_INT_STATUS	0x1A18
+#define MTK_RX_DONE_DLY		BIT(30)
+#define MTK_RX_DONE_INT3	BIT(19)
+#define MTK_RX_DONE_INT2	BIT(18)
+#define MTK_RX_DONE_INT1	BIT(17)
+#define MTK_RX_DONE_INT0	BIT(16)
+#define MTK_TX_DONE_INT3	BIT(3)
+#define MTK_TX_DONE_INT2	BIT(2)
+#define MTK_TX_DONE_INT1	BIT(1)
+#define MTK_TX_DONE_INT0	BIT(0)
+#define MTK_RX_DONE_INT		MTK_RX_DONE_DLY
+#define MTK_TX_DONE_INT		(MTK_TX_DONE_INT0 | MTK_TX_DONE_INT1 | \
+				 MTK_TX_DONE_INT2 | MTK_TX_DONE_INT3)
+
+/* QDMA Interrupt grouping registers */
+#define MTK_QDMA_INT_GRP1	0x1a20
+#define MTK_QDMA_INT_GRP2	0x1a24
+#define MTK_RLS_DONE_INT	BIT(0)
+
+/* QDMA Interrupt Status Register */
+#define MTK_QDMA_INT_MASK	0x1A1C
+
+/* QDMA Interrupt Mask Register */
+#define MTK_QDMA_HRED2		0x1A44
+
+/* QDMA TX Forward CPU Pointer Register */
+#define MTK_QTX_CTX_PTR		0x1B00
+
+/* QDMA TX Forward DMA Pointer Register */
+#define MTK_QTX_DTX_PTR		0x1B04
+
+/* QDMA TX Release CPU Pointer Register */
+#define MTK_QTX_CRX_PTR		0x1B10
+
+/* QDMA TX Release DMA Pointer Register */
+#define MTK_QTX_DRX_PTR		0x1B14
+
+/* QDMA FQ Head Pointer Register */
+#define MTK_QDMA_FQ_HEAD	0x1B20
+
+/* QDMA FQ Head Pointer Register */
+#define MTK_QDMA_FQ_TAIL	0x1B24
+
+/* QDMA FQ Free Page Counter Register */
+#define MTK_QDMA_FQ_CNT		0x1B28
+
+/* QDMA FQ Free Page Buffer Length Register */
+#define MTK_QDMA_FQ_BLEN	0x1B2C
+
+/* GMA1 Received Good Byte Count Register */
+#define MTK_GDM1_TX_GBCNT	0x2400
+#define MTK_STAT_OFFSET		0x40
+
+/* QDMA descriptor txd4 */
+#define TX_DMA_CHKSUM		(0x7 << 29)
+#define TX_DMA_TSO		BIT(28)
+#define TX_DMA_FPORT_SHIFT	25
+#define TX_DMA_FPORT_MASK	0x7
+#define TX_DMA_INS_VLAN		BIT(16)
 
-enum fe_work_flag {
-	FE_FLAG_RESET_PENDING,
-	FE_FLAG_MAX
-};
+/* QDMA descriptor txd3 */
+#define TX_DMA_OWNER_CPU	BIT(31)
+#define TX_DMA_LS0		BIT(30)
+#define TX_DMA_PLEN0(_x)	(((_x) & MTK_TX_DMA_BUF_LEN) << 16)
+#define TX_DMA_SWC		BIT(14)
+#define TX_DMA_SDL(_x)		(((_x) & 0x3fff) << 16)
 
-#define MTK_FE_DRV_VERSION		"0.1.2"
-
-/* power of 2 to let NEXT_TX_DESP_IDX work */
-#define NUM_DMA_DESC		BIT(10)
-#define MAX_DMA_DESC		0xfff
-
-#define FE_DELAY_EN_INT		0x80
-#define FE_DELAY_MAX_INT	0x04
-#define FE_DELAY_MAX_TOUT	0x04
-#define FE_DELAY_TIME		20
-#define FE_DELAY_CHAN		(((FE_DELAY_EN_INT | FE_DELAY_MAX_INT) << 8) | \
-				 FE_DELAY_MAX_TOUT)
-#define FE_DELAY_INIT		((FE_DELAY_CHAN << 16) | FE_DELAY_CHAN)
-#define FE_PSE_FQFC_CFG_INIT	0x80504000
-#define FE_PSE_FQFC_CFG_256Q	0xff908000
-
-/* interrupt bits */
-#define FE_CNT_PPE_AF		BIT(31)
-#define FE_CNT_GDM_AF		BIT(29)
-#define FE_PSE_P2_FC		BIT(26)
-#define FE_PSE_BUF_DROP		BIT(24)
-#define FE_GDM_OTHER_DROP	BIT(23)
-#define FE_PSE_P1_FC		BIT(22)
-#define FE_PSE_P0_FC		BIT(21)
-#define FE_PSE_FQ_EMPTY		BIT(20)
-#define FE_GE1_STA_CHG		BIT(18)
-#define FE_TX_COHERENT		BIT(17)
-#define FE_RX_COHERENT		BIT(16)
-#define FE_TX_DONE_INT3		BIT(11)
-#define FE_TX_DONE_INT2		BIT(10)
-#define FE_TX_DONE_INT1		BIT(9)
-#define FE_TX_DONE_INT0		BIT(8)
-#define FE_RX_DONE_INT0		BIT(2)
-#define FE_TX_DLY_INT		BIT(1)
-#define FE_RX_DLY_INT		BIT(0)
-
-#define FE_RX_DONE_INT		FE_RX_DONE_INT0
-#define FE_TX_DONE_INT		(FE_TX_DONE_INT0 | FE_TX_DONE_INT1 | \
-				 FE_TX_DONE_INT2 | FE_TX_DONE_INT3)
-
-#define RT5350_RX_DLY_INT	BIT(30)
-#define RT5350_TX_DLY_INT	BIT(28)
-#define RT5350_RX_DONE_INT1	BIT(17)
-#define RT5350_RX_DONE_INT0	BIT(16)
-#define RT5350_TX_DONE_INT3	BIT(3)
-#define RT5350_TX_DONE_INT2	BIT(2)
-#define RT5350_TX_DONE_INT1	BIT(1)
-#define RT5350_TX_DONE_INT0	BIT(0)
-
-#define RT5350_RX_DONE_INT	(RT5350_RX_DONE_INT0 | RT5350_RX_DONE_INT1)
-#define RT5350_TX_DONE_INT	(RT5350_TX_DONE_INT0 | RT5350_TX_DONE_INT1 | \
-				 RT5350_TX_DONE_INT2 | RT5350_TX_DONE_INT3)
-
-/* registers */
-#define FE_FE_OFFSET		0x0000
-#define FE_GDMA_OFFSET		0x0020
-#define FE_PSE_OFFSET		0x0040
-#define FE_GDMA2_OFFSET		0x0060
-#define FE_CDMA_OFFSET		0x0080
-#define FE_DMA_VID0		0x00a8
-#define FE_PDMA_OFFSET		0x0100
-#define FE_PPE_OFFSET		0x0200
-#define FE_CMTABLE_OFFSET	0x0400
-#define FE_POLICYTABLE_OFFSET	0x1000
-
-#define RT5350_PDMA_OFFSET	0x0800
-#define RT5350_SDM_OFFSET	0x0c00
-
-#define FE_MDIO_ACCESS		(FE_FE_OFFSET + 0x00)
-#define FE_MDIO_CFG		(FE_FE_OFFSET + 0x04)
-#define FE_FE_GLO_CFG		(FE_FE_OFFSET + 0x08)
-#define FE_FE_RST_GL		(FE_FE_OFFSET + 0x0C)
-#define FE_FE_INT_STATUS	(FE_FE_OFFSET + 0x10)
-#define FE_FE_INT_ENABLE	(FE_FE_OFFSET + 0x14)
-#define FE_MDIO_CFG2		(FE_FE_OFFSET + 0x18)
-#define FE_FOC_TS_T		(FE_FE_OFFSET + 0x1C)
-
-#define	FE_GDMA1_FWD_CFG	(FE_GDMA_OFFSET + 0x00)
-#define FE_GDMA1_SCH_CFG	(FE_GDMA_OFFSET + 0x04)
-#define FE_GDMA1_SHPR_CFG	(FE_GDMA_OFFSET + 0x08)
-#define FE_GDMA1_MAC_ADRL	(FE_GDMA_OFFSET + 0x0C)
-#define FE_GDMA1_MAC_ADRH	(FE_GDMA_OFFSET + 0x10)
-
-#define	FE_GDMA2_FWD_CFG	(FE_GDMA2_OFFSET + 0x00)
-#define FE_GDMA2_SCH_CFG	(FE_GDMA2_OFFSET + 0x04)
-#define FE_GDMA2_SHPR_CFG	(FE_GDMA2_OFFSET + 0x08)
-#define FE_GDMA2_MAC_ADRL	(FE_GDMA2_OFFSET + 0x0C)
-#define FE_GDMA2_MAC_ADRH	(FE_GDMA2_OFFSET + 0x10)
-
-#define FE_PSE_FQ_CFG		(FE_PSE_OFFSET + 0x00)
-#define FE_CDMA_FC_CFG		(FE_PSE_OFFSET + 0x04)
-#define FE_GDMA1_FC_CFG		(FE_PSE_OFFSET + 0x08)
-#define FE_GDMA2_FC_CFG		(FE_PSE_OFFSET + 0x0C)
-
-#define FE_CDMA_CSG_CFG		(FE_CDMA_OFFSET + 0x00)
-#define FE_CDMA_SCH_CFG		(FE_CDMA_OFFSET + 0x04)
-
-#ifdef CONFIG_SOC_MT7621
-#define MT7620A_GDMA_OFFSET		0x0500
-#else
-#define MT7620A_GDMA_OFFSET		0x0600
-#endif
-#define	MT7620A_GDMA1_FWD_CFG		(MT7620A_GDMA_OFFSET + 0x00)
-#define MT7620A_FE_GDMA1_SCH_CFG	(MT7620A_GDMA_OFFSET + 0x04)
-#define MT7620A_FE_GDMA1_SHPR_CFG	(MT7620A_GDMA_OFFSET + 0x08)
-#define MT7620A_FE_GDMA1_MAC_ADRL	(MT7620A_GDMA_OFFSET + 0x0C)
-#define MT7620A_FE_GDMA1_MAC_ADRH	(MT7620A_GDMA_OFFSET + 0x10)
-
-#define RT5350_TX_BASE_PTR0	(RT5350_PDMA_OFFSET + 0x00)
-#define RT5350_TX_MAX_CNT0	(RT5350_PDMA_OFFSET + 0x04)
-#define RT5350_TX_CTX_IDX0	(RT5350_PDMA_OFFSET + 0x08)
-#define RT5350_TX_DTX_IDX0	(RT5350_PDMA_OFFSET + 0x0C)
-#define RT5350_TX_BASE_PTR1	(RT5350_PDMA_OFFSET + 0x10)
-#define RT5350_TX_MAX_CNT1	(RT5350_PDMA_OFFSET + 0x14)
-#define RT5350_TX_CTX_IDX1	(RT5350_PDMA_OFFSET + 0x18)
-#define RT5350_TX_DTX_IDX1	(RT5350_PDMA_OFFSET + 0x1C)
-#define RT5350_TX_BASE_PTR2	(RT5350_PDMA_OFFSET + 0x20)
-#define RT5350_TX_MAX_CNT2	(RT5350_PDMA_OFFSET + 0x24)
-#define RT5350_TX_CTX_IDX2	(RT5350_PDMA_OFFSET + 0x28)
-#define RT5350_TX_DTX_IDX2	(RT5350_PDMA_OFFSET + 0x2C)
-#define RT5350_TX_BASE_PTR3	(RT5350_PDMA_OFFSET + 0x30)
-#define RT5350_TX_MAX_CNT3	(RT5350_PDMA_OFFSET + 0x34)
-#define RT5350_TX_CTX_IDX3	(RT5350_PDMA_OFFSET + 0x38)
-#define RT5350_TX_DTX_IDX3	(RT5350_PDMA_OFFSET + 0x3C)
-#define RT5350_RX_BASE_PTR0	(RT5350_PDMA_OFFSET + 0x100)
-#define RT5350_RX_MAX_CNT0	(RT5350_PDMA_OFFSET + 0x104)
-#define RT5350_RX_CALC_IDX0	(RT5350_PDMA_OFFSET + 0x108)
-#define RT5350_RX_DRX_IDX0	(RT5350_PDMA_OFFSET + 0x10C)
-#define RT5350_RX_BASE_PTR1	(RT5350_PDMA_OFFSET + 0x110)
-#define RT5350_RX_MAX_CNT1	(RT5350_PDMA_OFFSET + 0x114)
-#define RT5350_RX_CALC_IDX1	(RT5350_PDMA_OFFSET + 0x118)
-#define RT5350_RX_DRX_IDX1	(RT5350_PDMA_OFFSET + 0x11C)
-#define RT5350_PDMA_GLO_CFG	(RT5350_PDMA_OFFSET + 0x204)
-#define RT5350_PDMA_RST_CFG	(RT5350_PDMA_OFFSET + 0x208)
-#define RT5350_DLY_INT_CFG	(RT5350_PDMA_OFFSET + 0x20c)
-#define RT5350_FE_INT_STATUS	(RT5350_PDMA_OFFSET + 0x220)
-#define RT5350_FE_INT_ENABLE	(RT5350_PDMA_OFFSET + 0x228)
-#define RT5350_PDMA_SCH_CFG	(RT5350_PDMA_OFFSET + 0x280)
-
-#define FE_PDMA_GLO_CFG		(FE_PDMA_OFFSET + 0x00)
-#define FE_PDMA_RST_CFG		(FE_PDMA_OFFSET + 0x04)
-#define FE_PDMA_SCH_CFG		(FE_PDMA_OFFSET + 0x08)
-#define FE_DLY_INT_CFG		(FE_PDMA_OFFSET + 0x0C)
-#define FE_TX_BASE_PTR0		(FE_PDMA_OFFSET + 0x10)
-#define FE_TX_MAX_CNT0		(FE_PDMA_OFFSET + 0x14)
-#define FE_TX_CTX_IDX0		(FE_PDMA_OFFSET + 0x18)
-#define FE_TX_DTX_IDX0		(FE_PDMA_OFFSET + 0x1C)
-#define FE_TX_BASE_PTR1		(FE_PDMA_OFFSET + 0x20)
-#define FE_TX_MAX_CNT1		(FE_PDMA_OFFSET + 0x24)
-#define FE_TX_CTX_IDX1		(FE_PDMA_OFFSET + 0x28)
-#define FE_TX_DTX_IDX1		(FE_PDMA_OFFSET + 0x2C)
-#define FE_RX_BASE_PTR0		(FE_PDMA_OFFSET + 0x30)
-#define FE_RX_MAX_CNT0		(FE_PDMA_OFFSET + 0x34)
-#define FE_RX_CALC_IDX0		(FE_PDMA_OFFSET + 0x38)
-#define FE_RX_DRX_IDX0		(FE_PDMA_OFFSET + 0x3C)
-#define FE_TX_BASE_PTR2		(FE_PDMA_OFFSET + 0x40)
-#define FE_TX_MAX_CNT2		(FE_PDMA_OFFSET + 0x44)
-#define FE_TX_CTX_IDX2		(FE_PDMA_OFFSET + 0x48)
-#define FE_TX_DTX_IDX2		(FE_PDMA_OFFSET + 0x4C)
-#define FE_TX_BASE_PTR3		(FE_PDMA_OFFSET + 0x50)
-#define FE_TX_MAX_CNT3		(FE_PDMA_OFFSET + 0x54)
-#define FE_TX_CTX_IDX3		(FE_PDMA_OFFSET + 0x58)
-#define FE_TX_DTX_IDX3		(FE_PDMA_OFFSET + 0x5C)
-#define FE_RX_BASE_PTR1		(FE_PDMA_OFFSET + 0x60)
-#define FE_RX_MAX_CNT1		(FE_PDMA_OFFSET + 0x64)
-#define FE_RX_CALC_IDX1		(FE_PDMA_OFFSET + 0x68)
-#define FE_RX_DRX_IDX1		(FE_PDMA_OFFSET + 0x6C)
-
-/* Switch DMA configuration */
-#define RT5350_SDM_CFG		(RT5350_SDM_OFFSET + 0x00)
-#define RT5350_SDM_RRING	(RT5350_SDM_OFFSET + 0x04)
-#define RT5350_SDM_TRING	(RT5350_SDM_OFFSET + 0x08)
-#define RT5350_SDM_MAC_ADRL	(RT5350_SDM_OFFSET + 0x0C)
-#define RT5350_SDM_MAC_ADRH	(RT5350_SDM_OFFSET + 0x10)
-#define RT5350_SDM_TPCNT	(RT5350_SDM_OFFSET + 0x100)
-#define RT5350_SDM_TBCNT	(RT5350_SDM_OFFSET + 0x104)
-#define RT5350_SDM_RPCNT	(RT5350_SDM_OFFSET + 0x108)
-#define RT5350_SDM_RBCNT	(RT5350_SDM_OFFSET + 0x10C)
-#define RT5350_SDM_CS_ERR	(RT5350_SDM_OFFSET + 0x110)
-
-#define RT5350_SDM_ICS_EN	BIT(16)
-#define RT5350_SDM_TCS_EN	BIT(17)
-#define RT5350_SDM_UCS_EN	BIT(18)
-
-/* MDIO_CFG register bits */
-#define FE_MDIO_CFG_AUTO_POLL_EN	BIT(29)
-#define FE_MDIO_CFG_GP1_BP_EN		BIT(16)
-#define FE_MDIO_CFG_GP1_FRC_EN		BIT(15)
-#define FE_MDIO_CFG_GP1_SPEED_10	(0 << 13)
-#define FE_MDIO_CFG_GP1_SPEED_100	(1 << 13)
-#define FE_MDIO_CFG_GP1_SPEED_1000	(2 << 13)
-#define FE_MDIO_CFG_GP1_DUPLEX		BIT(12)
-#define FE_MDIO_CFG_GP1_FC_TX		BIT(11)
-#define FE_MDIO_CFG_GP1_FC_RX		BIT(10)
-#define FE_MDIO_CFG_GP1_LNK_DWN		BIT(9)
-#define FE_MDIO_CFG_GP1_AN_FAIL		BIT(8)
-#define FE_MDIO_CFG_MDC_CLK_DIV_1	(0 << 6)
-#define FE_MDIO_CFG_MDC_CLK_DIV_2	(1 << 6)
-#define FE_MDIO_CFG_MDC_CLK_DIV_4	(2 << 6)
-#define FE_MDIO_CFG_MDC_CLK_DIV_8	(3 << 6)
-#define FE_MDIO_CFG_TURBO_MII_FREQ	BIT(5)
-#define FE_MDIO_CFG_TURBO_MII_MODE	BIT(4)
-#define FE_MDIO_CFG_RX_CLK_SKEW_0	(0 << 2)
-#define FE_MDIO_CFG_RX_CLK_SKEW_200	(1 << 2)
-#define FE_MDIO_CFG_RX_CLK_SKEW_400	(2 << 2)
-#define FE_MDIO_CFG_RX_CLK_SKEW_INV	(3 << 2)
-#define FE_MDIO_CFG_TX_CLK_SKEW_0	0
-#define FE_MDIO_CFG_TX_CLK_SKEW_200	1
-#define FE_MDIO_CFG_TX_CLK_SKEW_400	2
-#define FE_MDIO_CFG_TX_CLK_SKEW_INV	3
-
-/* uni-cast port */
-#define FE_GDM1_JMB_LEN_MASK	0xf
-#define FE_GDM1_JMB_LEN_SHIFT	28
-#define FE_GDM1_ICS_EN		BIT(22)
-#define FE_GDM1_TCS_EN		BIT(21)
-#define FE_GDM1_UCS_EN		BIT(20)
-#define FE_GDM1_JMB_EN		BIT(19)
-#define FE_GDM1_STRPCRC		BIT(16)
-#define FE_GDM1_UFRC_P_CPU	(0 << 12)
-#define FE_GDM1_UFRC_P_GDMA1	(1 << 12)
-#define FE_GDM1_UFRC_P_PPE	(6 << 12)
-
-/* checksums */
-#define FE_ICS_GEN_EN		BIT(2)
-#define FE_UCS_GEN_EN		BIT(1)
-#define FE_TCS_GEN_EN		BIT(0)
-
-/* dma ring */
-#define FE_PST_DRX_IDX0		BIT(16)
-#define FE_PST_DTX_IDX3		BIT(3)
-#define FE_PST_DTX_IDX2		BIT(2)
-#define FE_PST_DTX_IDX1		BIT(1)
-#define FE_PST_DTX_IDX0		BIT(0)
-
-#define FE_RX_2B_OFFSET		BIT(31)
-#define FE_TX_WB_DDONE		BIT(6)
-#define FE_RX_DMA_BUSY		BIT(3)
-#define FE_TX_DMA_BUSY		BIT(1)
-#define FE_RX_DMA_EN		BIT(2)
-#define FE_TX_DMA_EN		BIT(0)
-
-#define FE_PDMA_SIZE_4DWORDS	(0 << 4)
-#define FE_PDMA_SIZE_8DWORDS	(1 << 4)
-#define FE_PDMA_SIZE_16DWORDS	(2 << 4)
-
-#define FE_US_CYC_CNT_MASK	0xff
-#define FE_US_CYC_CNT_SHIFT	0x8
-#define FE_US_CYC_CNT_DIVISOR	1000000
-
-/* rxd2 */
+/* QDMA descriptor rxd2 */
 #define RX_DMA_DONE		BIT(31)
-#define RX_DMA_LSO		BIT(30)
 #define RX_DMA_PLEN0(_x)	(((_x) & 0x3fff) << 16)
 #define RX_DMA_GET_PLEN0(_x)	(((_x) >> 16) & 0x3fff)
-#define RX_DMA_TAG		BIT(15)
-/* rxd3 */
-#define RX_DMA_TPID(_x)		(((_x) >> 16) & 0xffff)
-#define RX_DMA_VID(_x)		((_x) & 0xffff)
-/* rxd4 */
-#define RX_DMA_L4VALID		BIT(30)
-
-struct fe_rx_dma {
+
+/* QDMA descriptor rxd3 */
+#define RX_DMA_VID(_x)		((_x) & 0xfff)
+
+/* QDMA descriptor rxd4 */
+#define RX_DMA_L4_VALID		BIT(24)
+#define RX_DMA_SP_TAG		BIT(22)
+#define RX_DMA_FPORT_SHIFT	19
+#define RX_DMA_FPORT_MASK	0x7
+
+/* PHY Indirect Access Control registers */
+#define MTK_PHY_IAC		0x10004
+#define PHY_IAC_ACCESS		BIT(31)
+#define PHY_IAC_READ		BIT(19)
+#define PHY_IAC_WRITE		BIT(18)
+#define PHY_IAC_START		BIT(16)
+#define PHY_IAC_ADDR_SHIFT	20
+#define PHY_IAC_REG_SHIFT	25
+#define PHY_IAC_TIMEOUT		HZ
+
+#define MTK_MAC_MISC		0x1000c
+#define MTK_MUX_TO_ESW		BIT(0)
+
+/* Mac control registers */
+#define MTK_MAC_MCR(x)		(0x10100 + (x * 0x100))
+#define MAC_MCR_MAX_RX_1536	BIT(24)
+#define MAC_MCR_IPG_CFG		(BIT(18) | BIT(16))
+#define MAC_MCR_FORCE_MODE	BIT(15)
+#define MAC_MCR_TX_EN		BIT(14)
+#define MAC_MCR_RX_EN		BIT(13)
+#define MAC_MCR_BACKOFF_EN	BIT(9)
+#define MAC_MCR_BACKPR_EN	BIT(8)
+#define MAC_MCR_FORCE_RX_FC	BIT(5)
+#define MAC_MCR_FORCE_TX_FC	BIT(4)
+#define MAC_MCR_SPEED_1000	BIT(3)
+#define MAC_MCR_SPEED_100	BIT(2)
+#define MAC_MCR_FORCE_DPX	BIT(1)
+#define MAC_MCR_FORCE_LINK	BIT(0)
+#define MAC_MCR_FIXED_LINK	(MAC_MCR_MAX_RX_1536 | MAC_MCR_IPG_CFG | \
+				 MAC_MCR_FORCE_MODE | MAC_MCR_TX_EN | \
+				 MAC_MCR_RX_EN | MAC_MCR_BACKOFF_EN | \
+				 MAC_MCR_BACKPR_EN | MAC_MCR_FORCE_RX_FC | \
+				 MAC_MCR_FORCE_TX_FC | MAC_MCR_SPEED_1000 | \
+				 MAC_MCR_FORCE_DPX | MAC_MCR_FORCE_LINK)
+
+/* TRGMII RXC control register */
+#define TRGMII_RCK_CTRL		0x10300
+#define DQSI0(x)		((x << 0) & GENMASK(6, 0))
+#define DQSI1(x)		((x << 8) & GENMASK(14, 8))
+#define RXCTL_DMWTLAT(x)	((x << 16) & GENMASK(18, 16))
+#define RXC_DQSISEL		BIT(30)
+#define RCK_CTRL_RGMII_1000	(RXC_DQSISEL | RXCTL_DMWTLAT(2) | DQSI1(16))
+#define RCK_CTRL_RGMII_10_100	RXCTL_DMWTLAT(2)
+
+/* TRGMII RXC control register */
+#define TRGMII_TCK_CTRL		0x10340
+#define TXCTL_DMWTLAT(x)	((x << 16) & GENMASK(18, 16))
+#define TXC_INV			BIT(30)
+#define TCK_CTRL_RGMII_1000	TXCTL_DMWTLAT(2)
+#define TCK_CTRL_RGMII_10_100	(TXC_INV | TXCTL_DMWTLAT(2))
+
+/* TRGMII Interface mode register */
+#define INTF_MODE		0x10390
+#define TRGMII_INTF_DIS		BIT(0)
+#define TRGMII_MODE		BIT(1)
+#define TRGMII_CENTRAL_ALIGNED	BIT(2)
+#define INTF_MODE_RGMII_1000    (TRGMII_MODE | TRGMII_CENTRAL_ALIGNED)
+#define INTF_MODE_RGMII_10_100  0
+
+/* GPIO port control registers for GMAC 2*/
+#define GPIO_OD33_CTRL8		0x4c0
+#define GPIO_BIAS_CTRL		0xed0
+#define GPIO_DRV_SEL10		0xf00
+
+/* ethernet subsystem chip id register */
+#define ETHSYS_CHIPID0_3	0x0
+#define ETHSYS_CHIPID4_7	0x4
+#define MT7623_ETH		7623
+#define MT7622_ETH		7622
+
+/* ethernet subsystem config register */
+#define ETHSYS_SYSCFG0		0x14
+#define SYSCFG0_GE_MASK		0x3
+#define SYSCFG0_GE_MODE(x, y)	(x << (12 + (y * 2)))
+#define SYSCFG0_SGMII_MASK	(3 << 8)
+#define SYSCFG0_SGMII_GMAC1	((2 << 8) & GENMASK(9, 8))
+#define SYSCFG0_SGMII_GMAC2	((3 << 8) & GENMASK(9, 8))
+
+/* ethernet subsystem clock register */
+#define ETHSYS_CLKCFG0		0x2c
+#define ETHSYS_TRGMII_CLK_SEL362_5	BIT(11)
+
+/* ethernet reset control register */
+#define ETHSYS_RSTCTRL		0x34
+#define RSTCTRL_FE		BIT(6)
+#define RSTCTRL_PPE		BIT(31)
+
+/* SGMII subsystem config registers */
+/* Register to auto-negotiation restart */
+#define SGMSYS_PCS_CONTROL_1	0x0
+#define SGMII_AN_RESTART	BIT(9)
+
+/* Register to programmable link timer, the unit in 2 * 8ns */
+#define SGMSYS_PCS_LINK_TIMER	0x18
+#define SGMII_LINK_TIMER_DEFAULT	(0x186a0 & GENMASK(19, 0))
+
+/* Register to control remote fault */
+#define SGMSYS_SGMII_MODE	0x20
+#define SGMII_REMOTE_FAULT_DIS	BIT(8)
+
+/* Register to power up QPHY */
+#define SGMSYS_QPHY_PWR_STATE_CTRL 0xe8
+#define	SGMII_PHYA_PWD		BIT(4)
+
+struct mtk_rx_dma {
 	unsigned int rxd1;
 	unsigned int rxd2;
 	unsigned int rxd3;
 	unsigned int rxd4;
 } __packed __aligned(4);
 
-#define TX_DMA_BUF_LEN		0x3fff
-#define TX_DMA_PLEN0_MASK	(TX_DMA_BUF_LEN << 16)
-#define TX_DMA_PLEN0(_x)	(((_x) & TX_DMA_BUF_LEN) << 16)
-#define TX_DMA_PLEN1(_x)	((_x) & TX_DMA_BUF_LEN)
-#define TX_DMA_GET_PLEN0(_x)    (((_x) >> 16) & TX_DMA_BUF_LEN)
-#define TX_DMA_GET_PLEN1(_x)    ((_x) & TX_DMA_BUF_LEN)
-#define TX_DMA_LS1		BIT(14)
-#define TX_DMA_LS0		BIT(30)
-#define TX_DMA_DONE		BIT(31)
-
-#define TX_DMA_INS_VLAN_MT7621	BIT(16)
-#define TX_DMA_INS_VLAN		BIT(7)
-#define TX_DMA_INS_PPPOE	BIT(12)
-#define TX_DMA_QN(_x)		((_x) << 16)
-#define TX_DMA_PN(_x)		((_x) << 24)
-#define TX_DMA_QN_MASK		TX_DMA_QN(0x7)
-#define TX_DMA_PN_MASK		TX_DMA_PN(0x7)
-#define TX_DMA_UDF		BIT(20)
-#define TX_DMA_CHKSUM		(0x7 << 29)
-#define TX_DMA_TSO		BIT(28)
-
-/* frame engine counters */
-#define FE_PPE_AC_BCNT0		(FE_CMTABLE_OFFSET + 0x00)
-#define FE_GDMA1_TX_GBCNT	(FE_CMTABLE_OFFSET + 0x300)
-#define FE_GDMA2_TX_GBCNT	(FE_GDMA1_TX_GBCNT + 0x40)
-
-/* phy device flags */
-#define FE_PHY_FLAG_PORT	BIT(0)
-#define FE_PHY_FLAG_ATTACH	BIT(1)
-
-struct fe_tx_dma {
+struct mtk_tx_dma {
 	unsigned int txd1;
 	unsigned int txd2;
 	unsigned int txd3;
 	unsigned int txd4;
 } __packed __aligned(4);
 
-struct fe_priv;
-
-struct fe_phy {
-	/* make sure that phy operations are atomic */
-	spinlock_t		lock;
-
-	struct phy_device	*phy[8];
-	struct device_node	*phy_node[8];
-	const __be32		*phy_fixed[8];
-	int			duplex[8];
-	int			speed[8];
-	int			tx_fc[8];
-	int			rx_fc[8];
-	int (*connect)(struct fe_priv *priv);
-	void (*disconnect)(struct fe_priv *priv);
-	void (*start)(struct fe_priv *priv);
-	void (*stop)(struct fe_priv *priv);
+struct mtk_eth;
+struct mtk_mac;
+
+/* struct mtk_hw_stats - the structure that holds the traffic statistics.
+ * @stats_lock:		make sure that stats operations are atomic
+ * @reg_offset:		the status register offset of the SoC
+ * @syncp:		the refcount
+ *
+ * All of the supported SoCs have hardware counters for traffic statistics.
+ * Whenever the status IRQ triggers we can read the latest stats from these
+ * counters and store them in this struct.
+ */
+struct mtk_hw_stats {
+	u64 tx_bytes;
+	u64 tx_packets;
+	u64 tx_skip;
+	u64 tx_collisions;
+	u64 rx_bytes;
+	u64 rx_packets;
+	u64 rx_overflow;
+	u64 rx_fcs_errors;
+	u64 rx_short_errors;
+	u64 rx_long_errors;
+	u64 rx_checksum_errors;
+	u64 rx_flow_control_packets;
+
+	spinlock_t		stats_lock;
+	u32			reg_offset;
+	struct u64_stats_sync	syncp;
+};
+
+enum mtk_tx_flags {
+	/* PDMA descriptor can point at 1-2 segments. This enum allows us to
+	 * track how memory was allocated so that it can be freed properly.
+	 */
+	MTK_TX_FLAGS_SINGLE0	= 0x01,
+	MTK_TX_FLAGS_PAGE0	= 0x02,
+
+	/* MTK_TX_FLAGS_FPORTx allows tracking which port the transmitted
+	 * SKB out instead of looking up through hardware TX descriptor.
+	 */
+	MTK_TX_FLAGS_FPORT0	= 0x04,
+	MTK_TX_FLAGS_FPORT1	= 0x08,
 };
 
-struct fe_soc_data {
-	const u16 *reg_table;
-
-	void (*init_data)(struct fe_soc_data *data, struct net_device *netdev);
-	void (*reset_fe)(void);
-	void (*set_mac)(struct fe_priv *priv, unsigned char *mac);
-	int (*fwd_config)(struct fe_priv *priv);
-	void (*tx_dma)(struct fe_tx_dma *txd);
-	int (*switch_init)(struct fe_priv *priv);
-	int (*switch_config)(struct fe_priv *priv);
-	void (*port_init)(struct fe_priv *priv, struct device_node *port);
-	int (*has_carrier)(struct fe_priv *priv);
-	int (*mdio_init)(struct fe_priv *priv);
-	void (*mdio_cleanup)(struct fe_priv *priv);
-	int (*mdio_write)(struct mii_bus *bus, int phy_addr, int phy_reg,
-			  u16 val);
-	int (*mdio_read)(struct mii_bus *bus, int phy_addr, int phy_reg);
-	void (*mdio_adjust_link)(struct fe_priv *priv, int port);
-
-	void *swpriv;
-	u32 pdma_glo_cfg;
-	u32 rx_int;
-	u32 tx_int;
-	u32 status_int;
-	u32 checksum_bit;
+/* This enum allows us to identify how the clock is defined on the array of the
+ * clock in the order
+ */
+enum mtk_clks_map {
+	MTK_CLK_ETHIF,
+	MTK_CLK_ESW,
+	MTK_CLK_GP0,
+	MTK_CLK_GP1,
+	MTK_CLK_GP2,
+	MTK_CLK_TRGPLL,
+	MTK_CLK_SGMII_TX_250M,
+	MTK_CLK_SGMII_RX_250M,
+	MTK_CLK_SGMII_CDR_REF,
+	MTK_CLK_SGMII_CDR_FB,
+	MTK_CLK_SGMII_CK,
+	MTK_CLK_ETH2PLL,
+	MTK_CLK_MAX
 };
 
-#define FE_FLAG_PADDING_64B		BIT(0)
-#define FE_FLAG_PADDING_BUG		BIT(1)
-#define FE_FLAG_JUMBO_FRAME		BIT(2)
-#define FE_FLAG_RX_2B_OFFSET		BIT(3)
-#define FE_FLAG_RX_SG_DMA		BIT(4)
-#define FE_FLAG_RX_VLAN_CTAG		BIT(5)
-#define FE_FLAG_NAPI_WEIGHT		BIT(6)
-#define FE_FLAG_CALIBRATE_CLK		BIT(7)
-#define FE_FLAG_HAS_SWITCH		BIT(8)
-
-#define FE_STAT_REG_DECLARE		\
-	_FE(tx_bytes)			\
-	_FE(tx_packets)			\
-	_FE(tx_skip)			\
-	_FE(tx_collisions)		\
-	_FE(rx_bytes)			\
-	_FE(rx_packets)			\
-	_FE(rx_overflow)		\
-	_FE(rx_fcs_errors)		\
-	_FE(rx_short_errors)		\
-	_FE(rx_long_errors)		\
-	_FE(rx_checksum_errors)		\
-	_FE(rx_flow_control_packets)
-
-struct fe_hw_stats {
-	/* make sure that stats operations are atomic */
-	spinlock_t stats_lock;
-
-	struct u64_stats_sync syncp;
-#define _FE(x) u64 x;
-	FE_STAT_REG_DECLARE
-#undef _FE
+#define MT7623_CLKS_BITMAP	(BIT(MTK_CLK_ETHIF) | BIT(MTK_CLK_ESW) |  \
+				 BIT(MTK_CLK_GP1) | BIT(MTK_CLK_GP2) | \
+				 BIT(MTK_CLK_TRGPLL))
+#define MT7622_CLKS_BITMAP	(BIT(MTK_CLK_ETHIF) | BIT(MTK_CLK_ESW) |  \
+				 BIT(MTK_CLK_GP0) | BIT(MTK_CLK_GP1) | \
+				 BIT(MTK_CLK_GP2) | \
+				 BIT(MTK_CLK_SGMII_TX_250M) | \
+				 BIT(MTK_CLK_SGMII_RX_250M) | \
+				 BIT(MTK_CLK_SGMII_CDR_REF) | \
+				 BIT(MTK_CLK_SGMII_CDR_FB) | \
+				 BIT(MTK_CLK_SGMII_CK) | \
+				 BIT(MTK_CLK_ETH2PLL))
+enum mtk_dev_state {
+	MTK_HW_INIT,
+	MTK_RESETTING
 };
 
-struct fe_tx_buf {
+/* struct mtk_tx_buf -	This struct holds the pointers to the memory pointed at
+ *			by the TX descriptor	s
+ * @skb:		The SKB pointer of the packet being sent
+ * @dma_addr0:		The base addr of the first segment
+ * @dma_len0:		The length of the first segment
+ * @dma_addr1:		The base addr of the second segment
+ * @dma_len1:		The length of the second segment
+ */
+struct mtk_tx_buf {
 	struct sk_buff *skb;
+	u32 flags;
 	DEFINE_DMA_UNMAP_ADDR(dma_addr0);
+	DEFINE_DMA_UNMAP_LEN(dma_len0);
 	DEFINE_DMA_UNMAP_ADDR(dma_addr1);
-	u16 dma_len0;
-	u16 dma_len1;
+	DEFINE_DMA_UNMAP_LEN(dma_len1);
 };
 
-struct fe_tx_ring {
-	struct fe_tx_dma *tx_dma;
-	struct fe_tx_buf *tx_buf;
-	dma_addr_t tx_phys;
-	u16 tx_ring_size;
-	u16 tx_free_idx;
-	u16 tx_next_idx;
-	u16 tx_thresh;
+/* struct mtk_tx_ring -	This struct holds info describing a TX ring
+ * @dma:		The descriptor ring
+ * @buf:		The memory pointed at by the ring
+ * @phys:		The physical addr of tx_buf
+ * @next_free:		Pointer to the next free descriptor
+ * @last_free:		Pointer to the last free descriptor
+ * @thresh:		The threshold of minimum amount of free descriptors
+ * @free_count:		QDMA uses a linked list. Track how many free descriptors
+ *			are present
+ */
+struct mtk_tx_ring {
+	struct mtk_tx_dma *dma;
+	struct mtk_tx_buf *buf;
+	dma_addr_t phys;
+	struct mtk_tx_dma *next_free;
+	struct mtk_tx_dma *last_free;
+	u16 thresh;
+	atomic_t free_count;
 };
 
-struct fe_rx_ring {
-	struct page_frag_cache frag_cache;
-	struct fe_rx_dma *rx_dma;
-	u8 **rx_data;
-	dma_addr_t rx_phys;
-	u16 rx_ring_size;
+/* PDMA rx ring mode */
+enum mtk_rx_flags {
+	MTK_RX_FLAGS_NORMAL = 0,
+	MTK_RX_FLAGS_HWLRO,
+	MTK_RX_FLAGS_QDMA,
+};
+
+/* struct mtk_rx_ring -	This struct holds info describing a RX ring
+ * @dma:		The descriptor ring
+ * @data:		The memory pointed at by the ring
+ * @phys:		The physical addr of rx_buf
+ * @frag_size:		How big can each fragment be
+ * @buf_size:		The size of each packet buffer
+ * @calc_idx:		The current head of ring
+ */
+struct mtk_rx_ring {
+	struct mtk_rx_dma *dma;
+	u8 **data;
+	dma_addr_t phys;
 	u16 frag_size;
-	u16 rx_buf_size;
-	u16 rx_calc_idx;
+	u16 buf_size;
+	u16 dma_size;
+	bool calc_idx_update;
+	u16 calc_idx;
+	u32 crx_idx_reg;
 };
 
-struct fe_priv {
-	/* make sure that register operations are atomic */
-	spinlock_t			page_lock;
+#define MTK_TRGMII			BIT(0)
+#define MTK_GMAC1_TRGMII		(BIT(1) | MTK_TRGMII)
+#define MTK_ESW				BIT(4)
+#define MTK_GMAC1_ESW			(BIT(5) | MTK_ESW)
+#define MTK_SGMII			BIT(8)
+#define MTK_GMAC1_SGMII			(BIT(9) | MTK_SGMII)
+#define MTK_GMAC2_SGMII			(BIT(10) | MTK_SGMII)
+#define MTK_DUAL_GMAC_SHARED_SGMII	(BIT(11) | MTK_GMAC1_SGMII | \
+					 MTK_GMAC2_SGMII)
+#define MTK_HAS_CAPS(caps, _x)		(((caps) & (_x)) == (_x))
+
+/* struct mtk_eth_data -	This is the structure holding all differences
+ *				among various plaforms
+ * @caps			Flags shown the extra capability for the SoC
+ * @required_clks		Flags shown the bitmap for required clocks on
+ *				the target SoC
+ * @required_pctl		A bool value to show whether the SoC requires
+ *				the extra setup for those pins used by GMAC.
+ */
+struct mtk_soc_data {
+	u32		caps;
+	u32		required_clks;
+	bool		required_pctl;
+};
 
-	struct fe_soc_data		*soc;
-	struct net_device		*netdev;
-	struct device_node		*switch_np;
-	u32				msg_enable;
-	u32				flags;
+/* currently no SoC has more than 2 macs */
+#define MTK_MAX_DEVS			2
+
+/* struct mtk_eth -	This is the main datasructure for holding the state
+ *			of the driver
+ * @dev:		The device pointer
+ * @base:		The mapped register i/o base
+ * @page_lock:		Make sure that register operations are atomic
+ * @tx_irq__lock:	Make sure that IRQ register operations are atomic
+ * @rx_irq__lock:	Make sure that IRQ register operations are atomic
+ * @dummy_dev:		we run 2 netdevs on 1 physical DMA ring and need a
+ *			dummy for NAPI to work
+ * @netdev:		The netdev instances
+ * @mac:		Each netdev is linked to a physical MAC
+ * @irq:		The IRQ that we are using
+ * @msg_enable:		Ethtool msg level
+ * @ethsys:		The register map pointing at the range used to setup
+ *			MII modes
+ * @sgmiisys:		The register map pointing at the range used to setup
+ *			SGMII modes
+ * @pctl:		The register map pointing at the range used to setup
+ *			GMAC port drive/slew values
+ * @dma_refcnt:		track how many netdevs are using the DMA engine
+ * @tx_ring:		Pointer to the memory holding info about the TX ring
+ * @rx_ring:		Pointer to the memory holding info about the RX ring
+ * @rx_ring_qdma:	Pointer to the memory holding info about the QDMA RX ring
+ * @tx_napi:		The TX NAPI struct
+ * @rx_napi:		The RX NAPI struct
+ * @scratch_ring:	Newer SoCs need memory for a second HW managed TX ring
+ * @phy_scratch_ring:	physical address of scratch_ring
+ * @scratch_head:	The scratch memory that scratch_ring points to.
+ * @clks:		clock array for all clocks required
+ * @mii_bus:		If there is a bus we need to create an instance for it
+ * @pending_work:	The workqueue used to reset the dma ring
+ * @state:		Initialization and runtime state of the device
+ * @soc:		Holding specific data among vaious SoCs
+ */
 
+struct mtk_eth {
 	struct device			*dev;
+	void __iomem			*base;
+	spinlock_t			page_lock;
+	spinlock_t			tx_irq_lock;
+	spinlock_t			rx_irq_lock;
+	struct net_device		dummy_dev;
+	struct net_device		*netdev[MTK_MAX_DEVS];
+	struct mtk_mac			*mac[MTK_MAX_DEVS];
+	int				irq[3];
+	u32				msg_enable;
 	unsigned long			sysclk;
-
-	struct fe_rx_ring		rx_ring;
+	struct regmap			*ethsys;
+	struct regmap			*sgmiisys;
+	struct regmap			*pctl;
+	u32				chip_id;
+	bool				hwlro;
+	atomic_t			dma_refcnt;
+	struct mtk_tx_ring		tx_ring;
+	struct mtk_rx_ring		rx_ring[MTK_MAX_RX_RING_NUM];
+	struct mtk_rx_ring		rx_ring_qdma;
+	struct napi_struct		tx_napi;
 	struct napi_struct		rx_napi;
+	struct mtk_tx_dma		*scratch_ring;
+	dma_addr_t			phy_scratch_ring;
+	void				*scratch_head;
+	struct clk			*clks[MTK_CLK_MAX];
 
-	struct fe_tx_ring               tx_ring;
-
-	struct fe_phy			*phy;
 	struct mii_bus			*mii_bus;
-	struct phy_device		*phy_dev;
-	u32				phy_flags;
-
-	int				link[8];
-
-	struct fe_hw_stats		*hw_stats;
-	unsigned long			vlan_map;
 	struct work_struct		pending_work;
-	DECLARE_BITMAP(pending_flags, FE_FLAG_MAX);
+	unsigned long			state;
 
-	struct reset_control		*rst_ppe;
-	struct mtk_foe_entry		*foe_table;
-	dma_addr_t			foe_table_phys;
-	struct flow_offload __rcu	**foe_flow_table;
+	const struct mtk_soc_data	*soc;
 };
 
-extern const struct of_device_id of_fe_match[];
-
-void fe_w32(u32 val, unsigned reg);
-void fe_m32(struct fe_priv *priv, u32 clear, u32 set, unsigned reg);
-u32 fe_r32(unsigned reg);
-
-int fe_set_clock_cycle(struct fe_priv *priv);
-void fe_csum_config(struct fe_priv *priv);
-void fe_stats_update(struct fe_priv *priv);
-void fe_fwd_config(struct fe_priv *priv);
-void fe_reg_w32(u32 val, enum fe_reg reg);
-u32 fe_reg_r32(enum fe_reg reg);
-
-void fe_reset(u32 reset_bits);
+/* struct mtk_mac -	the structure that holds the info about the MACs of the
+ *			SoC
+ * @id:			The number of the MAC
+ * @ge_mode:            Interface mode kept for setup restoring
+ * @of_node:		Our devicetree node
+ * @hw:			Backpointer to our main datastruture
+ * @hw_stats:		Packet statistics counter
+ * @trgmii		Indicate if the MAC uses TRGMII connected to internal
+			switch
+ */
+struct mtk_mac {
+	int				id;
+	int				ge_mode;
+	struct device_node		*of_node;
+	struct mtk_eth			*hw;
+	struct mtk_hw_stats		*hw_stats;
+	__be32				hwlro_ip[MTK_MAX_LRO_IP_CNT];
+	int				hwlro_ip_cnt;
+	bool				trgmii;
+};
 
-static inline void *priv_netdev(struct fe_priv *priv)
-{
-	return (char *)priv - ALIGN(sizeof(struct net_device), NETDEV_ALIGN);
-}
+/* the struct describing the SoC. these are declared in the soc_xyz.c files */
+extern const struct of_device_id of_mtk_match[];
 
-int mtk_ppe_probe(struct fe_priv *eth);
-void mtk_ppe_remove(struct fe_priv *eth);
-int mtk_flow_offload(struct fe_priv *eth,
-		     enum flow_offload_type type,
-		     struct flow_offload *flow,
-		     struct flow_offload_hw_path *src,
-		     struct flow_offload_hw_path *dest);
-int mtk_offload_check_rx(struct fe_priv *eth, struct sk_buff *skb, u32 rxd4);
+/* read the hardware status register */
+void mtk_stats_update_mac(struct mtk_mac *mac);
 
+void mtk_w32(struct mtk_eth *eth, u32 val, unsigned reg);
+u32 mtk_r32(struct mtk_eth *eth, unsigned reg);
 
-#endif /* FE_ETH_H */
+#endif /* MTK_ETH_H */
diff --git a/drivers/net/ethernet/mediatek/mtk_offload.c b/drivers/net/ethernet/mediatek/mtk_offload.c
deleted file mode 100644
index 3001c081f7c4..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_offload.c
+++ /dev/null
@@ -1,526 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2018 John Crispin <john@phrozen.org>
- */
-
-#include "mtk_offload.h"
-
-#define INVALID	0
-#define UNBIND	1
-#define BIND	2
-#define FIN	3
-
-#define IPV4_HNAPT			0
-#define IPV4_HNAT			1
-
-static u32
-mtk_flow_hash_v4(struct flow_offload_tuple *tuple)
-{
-	u32 ports = ntohs(tuple->src_port)  << 16 | ntohs(tuple->dst_port);
-	u32 src = ntohl(tuple->dst_v4.s_addr);
-	u32 dst = ntohl(tuple->src_v4.s_addr);
-	u32 hash = (ports & src) | ((~ports) & dst);
-	u32 hash_23_0 = hash & 0xffffff;
-	u32 hash_31_24 = hash & 0xff000000;
-
-	hash = ports ^ src ^ dst ^ ((hash_23_0 << 8) | (hash_31_24 >> 24));
-	hash = ((hash & 0xffff0000) >> 16 ) ^ (hash & 0xfffff);
-	hash &= 0x7ff;
-	hash *= 2;;
-
-	return hash;
-}
-
-static int
-mtk_foe_prepare_v4(struct mtk_foe_entry *entry,
-		   struct flow_offload_tuple *tuple,
-		   struct flow_offload_tuple *dest_tuple,
-		   struct flow_offload_hw_path *src,
-		   struct flow_offload_hw_path *dest)
-{
-	int is_mcast = !!is_multicast_ether_addr(dest->eth_dest);
-
-	if (tuple->l4proto == IPPROTO_UDP)
-		entry->ipv4_hnapt.bfib1.udp = 1;
-
-	entry->ipv4_hnapt.etype = htons(ETH_P_IP);
-	entry->ipv4_hnapt.bfib1.pkt_type = IPV4_HNAPT;
-	entry->ipv4_hnapt.iblk2.fqos = 0;
-	entry->ipv4_hnapt.bfib1.ttl = 1;
-	entry->ipv4_hnapt.bfib1.cah = 1;
-	entry->ipv4_hnapt.bfib1.ka = 1;
-	entry->ipv4_hnapt.iblk2.mcast = is_mcast;
-	entry->ipv4_hnapt.iblk2.dscp = 0;
-	entry->ipv4_hnapt.iblk2.port_mg = 0x3f;
-	entry->ipv4_hnapt.iblk2.port_ag = 0x1f;
-#ifdef CONFIG_NET_MEDIATEK_HW_QOS
-	entry->ipv4_hnapt.iblk2.qid = 1;
-	entry->ipv4_hnapt.iblk2.fqos = 1;
-#endif
-#ifdef CONFIG_RALINK
-	entry->ipv4_hnapt.iblk2.dp = 1;
-	if ((dest->flags & FLOW_OFFLOAD_PATH_VLAN) && (dest->vlan_id > 1))
-		entry->ipv4_hnapt.iblk2.qid += 8;
-#else
-	entry->ipv4_hnapt.iblk2.dp = (dest->dev->name[3] - '0') + 1;
-#endif
-
-	entry->ipv4_hnapt.sip = ntohl(tuple->src_v4.s_addr);
-	entry->ipv4_hnapt.dip = ntohl(tuple->dst_v4.s_addr);
-	entry->ipv4_hnapt.sport = ntohs(tuple->src_port);
-	entry->ipv4_hnapt.dport = ntohs(tuple->dst_port);
-
-	entry->ipv4_hnapt.new_sip = ntohl(dest_tuple->dst_v4.s_addr);
-	entry->ipv4_hnapt.new_dip = ntohl(dest_tuple->src_v4.s_addr);
-	entry->ipv4_hnapt.new_sport = ntohs(dest_tuple->dst_port);
-	entry->ipv4_hnapt.new_dport = ntohs(dest_tuple->src_port);
-
-	entry->bfib1.state = BIND;
-
-	if (dest->flags & FLOW_OFFLOAD_PATH_PPPOE) {
-		entry->bfib1.psn = 1;
-		entry->ipv4_hnapt.etype = htons(ETH_P_PPP_SES);
-		entry->ipv4_hnapt.pppoe_id = dest->pppoe_sid;
-	}
-
-	if (dest->flags & FLOW_OFFLOAD_PATH_VLAN) {
-		entry->ipv4_hnapt.vlan1 = dest->vlan_id;
-		entry->bfib1.vlan_layer = 1;
-
-		switch (dest->vlan_proto) {
-		case htons(ETH_P_8021Q):
-			entry->ipv4_hnapt.bfib1.vpm = 1;
-			break;
-		case htons(ETH_P_8021AD):
-			entry->ipv4_hnapt.bfib1.vpm = 2;
-			break;
-		default:
-			return -EINVAL;
-		}
-	}
-
-	return 0;
-}
-
-static void
-mtk_foe_set_mac(struct mtk_foe_entry *entry, u8 *smac, u8 *dmac)
-{
-	entry->ipv4_hnapt.dmac_hi = swab32(*((u32*) dmac));
-	entry->ipv4_hnapt.dmac_lo = swab16(*((u16*) &dmac[4]));
-	entry->ipv4_hnapt.smac_hi = swab32(*((u32*) smac));
-	entry->ipv4_hnapt.smac_lo = swab16(*((u16*) &smac[4]));
-}
-
-static void
-mtk_foe_write(struct mtk_eth *eth, u32 hash,
-	      struct mtk_foe_entry *entry)
-{
-	struct mtk_foe_entry *table = (struct mtk_foe_entry *)eth->foe_table;
-
-	memcpy(&table[hash], entry, sizeof(*entry));
-}
-
-int mtk_flow_offload(struct mtk_eth *eth,
-		     enum flow_offload_type type,
-		     struct flow_offload *flow,
-		     struct flow_offload_hw_path *src,
-		     struct flow_offload_hw_path *dest)
-{
-	struct flow_offload_tuple *otuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_ORIGINAL].tuple;
-	struct flow_offload_tuple *rtuple = &flow->tuplehash[FLOW_OFFLOAD_DIR_REPLY].tuple;
-	u32 time_stamp = mtk_r32(eth, 0x0010) & (0x7fff);
-	u32 ohash, rhash;
-	struct mtk_foe_entry orig = {
-		.bfib1.time_stamp = time_stamp,
-		.bfib1.psn = 0,
-	};
-	struct mtk_foe_entry reply = {
-		.bfib1.time_stamp = time_stamp,
-		.bfib1.psn = 0,
-	};
-
-	if (otuple->l4proto != IPPROTO_TCP && otuple->l4proto != IPPROTO_UDP)
-		return -EINVAL;
-
-	switch (otuple->l3proto) {
-	case AF_INET:
-		if (mtk_foe_prepare_v4(&orig, otuple, rtuple, src, dest) ||
-		    mtk_foe_prepare_v4(&reply, rtuple, otuple, dest, src))
-			return -EINVAL;
-
-		ohash = mtk_flow_hash_v4(otuple);
-		rhash = mtk_flow_hash_v4(rtuple);
-		break;
-
-	case AF_INET6:
-		return -EINVAL;
-
-	default:
-		return -EINVAL;
-	}
-
-	if (type == FLOW_OFFLOAD_DEL) {
-		orig.bfib1.state = INVALID;
-		reply.bfib1.state = INVALID;
-		flow = NULL;
-		goto write;
-	}
-
-	mtk_foe_set_mac(&orig, dest->eth_src, dest->eth_dest);
-	mtk_foe_set_mac(&reply, src->eth_src, src->eth_dest);
-
-write:
-	mtk_foe_write(eth, ohash, &orig);
-	mtk_foe_write(eth, rhash, &reply);
-	rcu_assign_pointer(eth->foe_flow_table[ohash], flow);
-	rcu_assign_pointer(eth->foe_flow_table[rhash], flow);
-
-	if (type == FLOW_OFFLOAD_DEL)
-		synchronize_rcu();
-
-	return 0;
-}
-
-#ifdef CONFIG_NET_MEDIATEK_HW_QOS
-
-#define QDMA_TX_SCH_TX	  0x1a14
-
-static void mtk_ppe_scheduler(struct mtk_eth *eth, int id, u32 rate)
-{
-	int exp = 0, shift = 0;
-	u32 reg = mtk_r32(eth, QDMA_TX_SCH_TX);
-	u32 val = 0;
-
-	if (rate)
-		val = BIT(11);
-
-	while (rate > 127) {
-		rate /= 10;
-		exp++;
-	}
-
-	val |= (rate & 0x7f) << 4;
-	val |= exp & 0xf;
-	if (id)
-		shift = 16;
-	reg &= ~(0xffff << shift);
-	reg |= val << shift;
-	mtk_w32(eth, val, QDMA_TX_SCH_TX);
-}
-
-#define QTX_CFG(x)	(0x1800 + (x * 0x10))
-#define QTX_SCH(x)	(0x1804 + (x * 0x10))
-
-static void mtk_ppe_queue(struct mtk_eth *eth, int id, int sched, int weight, int resv, u32 min_rate, u32 max_rate)
-{
-	int max_exp = 0, min_exp = 0;
-	u32 reg;
-
-	if (id >= 16)
-		return;
-
-	reg = mtk_r32(eth, QTX_SCH(id));
-	reg &= 0x70000000;
-
-	if (sched)
-		reg |= BIT(31);
-
-	if (min_rate)
-		reg |= BIT(27);
-
-	if (max_rate)
-		reg |= BIT(11);
-
-	while (max_rate > 127) {
-		max_rate /= 10;
-		max_exp++;
-	}
-
-	while (min_rate > 127) {
-		min_rate /= 10;
-		min_exp++;
-	}
-
-	reg |= (min_rate & 0x7f) << 20;
-	reg |= (min_exp & 0xf) << 16;
-	reg |= (weight & 0xf) << 12;
-	reg |= (max_rate & 0x7f) << 4;
-	reg |= max_exp & 0xf;
-	mtk_w32(eth, reg, QTX_SCH(id));
-
-	resv &= 0xff;
-	reg = mtk_r32(eth, QTX_CFG(id));
-	reg &= 0xffff0000;
-	reg |= (resv << 8) | resv;
-	mtk_w32(eth, reg, QTX_CFG(id));
-}
-#endif
-
-static int mtk_init_foe_table(struct mtk_eth *eth)
-{
-	if (eth->foe_table)
-		return 0;
-
-	eth->foe_flow_table = devm_kcalloc(eth->dev, MTK_PPE_ENTRY_CNT,
-					   sizeof(*eth->foe_flow_table),
-					   GFP_KERNEL);
-	if (!eth->foe_flow_table)
-		return -EINVAL;
-
-	/* map the FOE table */
-	eth->foe_table = dmam_alloc_coherent(eth->dev, MTK_PPE_TBL_SZ,
-					     &eth->foe_table_phys, GFP_KERNEL);
-	if (!eth->foe_table) {
-		dev_err(eth->dev, "failed to allocate foe table\n");
-		kfree(eth->foe_flow_table);
-		return -ENOMEM;
-	}
-
-
-	return 0;
-}
-
-static int mtk_ppe_start(struct mtk_eth *eth)
-{
-	int ret;
-
-	ret = mtk_init_foe_table(eth);
-	if (ret)
-		return ret;
-
-	/* tell the PPE about the tables base address */
-	mtk_w32(eth, eth->foe_table_phys, MTK_REG_PPE_TB_BASE);
-
-	/* flush the table */
-	memset(eth->foe_table, 0, MTK_PPE_TBL_SZ);
-
-	/* setup hashing */
-	mtk_m32(eth,
-		MTK_PPE_TB_CFG_HASH_MODE_MASK | MTK_PPE_TB_CFG_TBL_SZ_MASK,
-		MTK_PPE_TB_CFG_HASH_MODE1 | MTK_PPE_TB_CFG_TBL_SZ_4K,
-		MTK_REG_PPE_TB_CFG);
-
-	/* set the default hashing seed */
-	mtk_w32(eth, MTK_PPE_HASH_SEED, MTK_REG_PPE_HASH_SEED);
-
-	/* each foe entry is 64bytes and is setup by cpu forwarding*/
-	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE | MTK_PPE_TB_CFG_ENTRY_SZ_MASK |
-		MTK_PPE_TB_CFG_SMA_MASK,
-		MTK_PPE_TB_CFG_ENTRY_SZ_64B |  MTK_PPE_TB_CFG_SMA_FWD_CPU,
-		MTK_REG_PPE_TB_CFG);
-
-	/* set ip proto */
-	mtk_w32(eth, 0xFFFFFFFF, MTK_REG_PPE_IP_PROT_CHK);
-
-	/* setup caching */
-	mtk_m32(eth, 0, MTK_PPE_CAH_CTRL_X_MODE, MTK_REG_PPE_CAH_CTRL);
-	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE, MTK_PPE_CAH_CTRL_EN,
-		MTK_REG_PPE_CAH_CTRL);
-
-	/* enable FOE */
-	mtk_m32(eth, 0, MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN |
-		MTK_PPE_FLOW_CFG_IPV4_NAPT_EN | MTK_PPE_FLOW_CFG_IPV4_NAT_EN |
-		MTK_PPE_FLOW_CFG_IPV4_GREK_EN,
-		MTK_REG_PPE_FLOW_CFG);
-
-	/* setup flow entry un/bind aging */
-	mtk_m32(eth, 0,
-		MTK_PPE_TB_CFG_UNBD_AGE | MTK_PPE_TB_CFG_NTU_AGE |
-		MTK_PPE_TB_CFG_FIN_AGE | MTK_PPE_TB_CFG_UDP_AGE |
-		MTK_PPE_TB_CFG_TCP_AGE,
-		MTK_REG_PPE_TB_CFG);
-
-	mtk_m32(eth, MTK_PPE_UNB_AGE_MNP_MASK | MTK_PPE_UNB_AGE_DLTA_MASK,
-		MTK_PPE_UNB_AGE_MNP | MTK_PPE_UNB_AGE_DLTA,
-		MTK_REG_PPE_UNB_AGE);
-	mtk_m32(eth, MTK_PPE_BND_AGE0_NTU_DLTA_MASK |
-		MTK_PPE_BND_AGE0_UDP_DLTA_MASK,
-		MTK_PPE_BND_AGE0_NTU_DLTA | MTK_PPE_BND_AGE0_UDP_DLTA,
-		MTK_REG_PPE_BND_AGE0);
-	mtk_m32(eth, MTK_PPE_BND_AGE1_FIN_DLTA_MASK |
-		MTK_PPE_BND_AGE1_TCP_DLTA_MASK,
-		MTK_PPE_BND_AGE1_FIN_DLTA | MTK_PPE_BND_AGE1_TCP_DLTA,
-		MTK_REG_PPE_BND_AGE1);
-
-	/* setup flow entry keep alive */
-	mtk_m32(eth, MTK_PPE_TB_CFG_KA_MASK, MTK_PPE_TB_CFG_KA,
-		MTK_REG_PPE_TB_CFG);
-	mtk_w32(eth, MTK_PPE_KA_UDP | MTK_PPE_KA_TCP | MTK_PPE_KA_T, MTK_REG_PPE_KA);
-
-	/* setup flow entry rate limit */
-	mtk_w32(eth, (0x3fff << 16) | 0x3fff, MTK_REG_PPE_BIND_LMT_0);
-	mtk_w32(eth, MTK_PPE_NTU_KA | 0x3fff, MTK_REG_PPE_BIND_LMT_1);
-	mtk_m32(eth, MTK_PPE_BNDR_RATE_MASK, 1, MTK_REG_PPE_BNDR);
-
-	/* enable the PPE */
-	mtk_m32(eth, 0, MTK_PPE_GLO_CFG_EN, MTK_REG_PPE_GLO_CFG);
-
-#ifdef CONFIG_RALINK
-	/* set the default forwarding port to QDMA */
-	mtk_w32(eth, 0x0, MTK_REG_PPE_DFT_CPORT);
-#else
-	/* set the default forwarding port to QDMA */
-	mtk_w32(eth, 0x55555555, MTK_REG_PPE_DFT_CPORT);
-#endif
-
-	/* drop packets with TTL=0 */
-	mtk_m32(eth, 0, MTK_PPE_GLO_CFG_TTL0_DROP, MTK_REG_PPE_GLO_CFG);
-
-	/* send all traffic from gmac to the ppe */
-	mtk_m32(eth, 0xffff, 0x4444, MTK_GDMA_FWD_CFG(0));
-	mtk_m32(eth, 0xffff, 0x4444, MTK_GDMA_FWD_CFG(1));
-
-	dev_info(eth->dev, "PPE started\n");
-
-#ifdef CONFIG_NET_MEDIATEK_HW_QOS
-	mtk_ppe_scheduler(eth, 0, 500000);
-	mtk_ppe_scheduler(eth, 1, 500000);
-	mtk_ppe_queue(eth, 0, 0, 7, 32, 250000, 0);
-	mtk_ppe_queue(eth, 1, 0, 7, 32, 250000, 0);
-	mtk_ppe_queue(eth, 8, 1, 7, 32, 250000, 0);
-	mtk_ppe_queue(eth, 9, 1, 7, 32, 250000, 0);
-#endif
-
-	return 0;
-}
-
-static int mtk_ppe_busy_wait(struct mtk_eth *eth)
-{
-	unsigned long t_start = jiffies;
-	u32 r = 0;
-
-	while (1) {
-		r = mtk_r32(eth, MTK_REG_PPE_GLO_CFG);
-		if (!(r & MTK_PPE_GLO_CFG_BUSY))
-			return 0;
-		if (time_after(jiffies, t_start + HZ))
-			break;
-		usleep_range(10, 20);
-	}
-
-	dev_err(eth->dev, "ppe: table busy timeout - resetting\n");
-	reset_control_reset(eth->rst_ppe);
-
-	return -ETIMEDOUT;
-}
-
-static int mtk_ppe_stop(struct mtk_eth *eth)
-{
-	u32 r1 = 0, r2 = 0;
-	int i;
-
-	/* discard all traffic while we disable the PPE */
-	mtk_m32(eth, 0xffff, 0x7777, MTK_GDMA_FWD_CFG(0));
-	mtk_m32(eth, 0xffff, 0x7777, MTK_GDMA_FWD_CFG(1));
-
-	if (mtk_ppe_busy_wait(eth))
-		return -ETIMEDOUT;
-
-	/* invalidate all flow table entries */
-	for (i = 0; i < MTK_PPE_ENTRY_CNT; i++)
-		eth->foe_table[i].bfib1.state = FOE_STATE_INVALID;
-
-	/* disable caching */
-	mtk_m32(eth, 0, MTK_PPE_CAH_CTRL_X_MODE, MTK_REG_PPE_CAH_CTRL);
-	mtk_m32(eth, MTK_PPE_CAH_CTRL_X_MODE | MTK_PPE_CAH_CTRL_EN, 0,
-		MTK_REG_PPE_CAH_CTRL);
-
-	/* flush cache has to be ahead of hnat diable --*/
-	mtk_m32(eth, MTK_PPE_GLO_CFG_EN, 0, MTK_REG_PPE_GLO_CFG);
-
-	/* disable FOE */
-	mtk_m32(eth,
-		MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN |
-		MTK_PPE_FLOW_CFG_IPV4_NAPT_EN | MTK_PPE_FLOW_CFG_IPV4_NAT_EN |
-		MTK_PPE_FLOW_CFG_FUC_FOE | MTK_PPE_FLOW_CFG_FMC_FOE,
-		0, MTK_REG_PPE_FLOW_CFG);
-
-	/* disable FOE aging */
-	mtk_m32(eth, 0,
-		MTK_PPE_TB_CFG_FIN_AGE | MTK_PPE_TB_CFG_UDP_AGE |
-		MTK_PPE_TB_CFG_TCP_AGE | MTK_PPE_TB_CFG_UNBD_AGE |
-		MTK_PPE_TB_CFG_NTU_AGE, MTK_REG_PPE_TB_CFG);
-
-	r1 = mtk_r32(eth, 0x100);
-	r2 = mtk_r32(eth, 0x10c);
-
-	dev_info(eth->dev, "0x100 = 0x%x, 0x10c = 0x%x\n", r1, r2);
-
-	if (((r1 & 0xff00) >> 0x8) >= (r1 & 0xff) ||
-	    ((r1 & 0xff00) >> 0x8) >= (r2 & 0xff)) {
-		dev_info(eth->dev, "reset pse\n");
-		mtk_w32(eth, 0x1, 0x4);
-	}
-
-	/* set the foe entry base address to 0 */
-	mtk_w32(eth, 0, MTK_REG_PPE_TB_BASE);
-
-	if (mtk_ppe_busy_wait(eth))
-		return -ETIMEDOUT;
-
-	/* send all traffic back to the DMA engine */
-#ifdef CONFIG_RALINK
-	mtk_m32(eth, 0xffff, 0x0, MTK_GDMA_FWD_CFG(0));
-	mtk_m32(eth, 0xffff, 0x0, MTK_GDMA_FWD_CFG(1));
-#else
-	mtk_m32(eth, 0xffff, 0x5555, MTK_GDMA_FWD_CFG(0));
-	mtk_m32(eth, 0xffff, 0x5555, MTK_GDMA_FWD_CFG(1));
-#endif
-	return 0;
-}
-
-static void mtk_offload_keepalive(struct fe_priv *eth, unsigned int hash)
-{
-	struct flow_offload *flow;
-
-	rcu_read_lock();
-	flow = rcu_dereference(eth->foe_flow_table[hash]);
-	if (flow)
-		flow->timeout = jiffies + 30 * HZ;
-	rcu_read_unlock();
-}
-
-int mtk_offload_check_rx(struct fe_priv *eth, struct sk_buff *skb, u32 rxd4)
-{
-	unsigned int hash;
-
-	switch (FIELD_GET(MTK_RXD4_CPU_REASON, rxd4)) {
-	case MTK_CPU_REASON_KEEPALIVE_UC_OLD_HDR:
-	case MTK_CPU_REASON_KEEPALIVE_MC_NEW_HDR:
-	case MTK_CPU_REASON_KEEPALIVE_DUP_OLD_HDR:
-		hash = FIELD_GET(MTK_RXD4_FOE_ENTRY, rxd4);
-		mtk_offload_keepalive(eth, hash);
-		return -1;
-	case MTK_CPU_REASON_PACKET_SAMPLING:
-		return -1;
-	default:
-		return 0;
-	}
-}
-
-int mtk_ppe_probe(struct mtk_eth *eth)
-{
-	int err;
-
-	err = mtk_ppe_start(eth);
-	if (err)
-		return err;
-
-	err = mtk_ppe_debugfs_init(eth);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-void mtk_ppe_remove(struct mtk_eth *eth)
-{
-	mtk_ppe_stop(eth);
-}
diff --git a/drivers/net/ethernet/mediatek/mtk_offload.h b/drivers/net/ethernet/mediatek/mtk_offload.h
deleted file mode 100644
index f714c90f9225..000000000000
--- a/drivers/net/ethernet/mediatek/mtk_offload.h
+++ /dev/null
@@ -1,260 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2014-2016 Sean Wang <sean.wang@mediatek.com>
- *   Copyright (C) 2016-2017 John Crispin <blogic@openwrt.org>
- */
-
-#include <linux/dma-mapping.h>
-#include <linux/delay.h>
-#include <linux/if.h>
-#include <linux/io.h>
-#include <linux/module.h>
-#include <linux/of_device.h>
-#include <linux/platform_device.h>
-#include <linux/reset.h>
-#include <linux/netfilter.h>
-#include <linux/netdevice.h>
-#include <net/netfilter/nf_flow_table.h>
-#include <linux/debugfs.h>
-#include <linux/etherdevice.h>
-#include <linux/bitfield.h>
-
-#include "mtk_eth_soc.h"
-
-#ifdef CONFIG_RALINK
-/* ramips compat */
-#define mtk_eth					fe_priv
-#define MTK_GDMA_FWD_CFG(x)			(0x500 + (x * 0x1000))
-#define mtk_m32					fe_m32
-
-static inline u32
-mtk_r32(struct mtk_eth *eth, u32 reg)
-{
-	return fe_r32(reg);
-}
-
-static inline void
-mtk_w32(struct mtk_eth *eth, u32 val, u32 reg)
-{
-	fe_w32(val, reg);
-}
-#endif
-
-#define MTK_REG_PPE_GLO_CFG			0xe00
-#define   MTK_PPE_GLO_CFG_BUSY			BIT(31)
-#define   MTK_PPE_GLO_CFG_TTL0_DROP		BIT(4)
-#define   MTK_PPE_GLO_CFG_EN			BIT(0)
-
-#define MTK_REG_PPE_FLOW_CFG			0xe04
-#define   MTK_PPE_FLOW_CFG_IPV4_GREK_EN		BIT(19)
-#define   MTK_PPE_FLOW_CFG_IPV4_NAT_FRAG_EN	BIT(17)
-#define   MTK_PPE_FLOW_CFG_IPV4_NAPT_EN		BIT(13)
-#define   MTK_PPE_FLOW_CFG_IPV4_NAT_EN		BIT(12)
-#define   MTK_PPE_FLOW_CFG_FUC_FOE		BIT(2)
-#define   MTK_PPE_FLOW_CFG_FMC_FOE		BIT(1)
-
-#define MTK_REG_PPE_IP_PROT_CHK			0xe08
-
-#define MTK_REG_PPE_TB_BASE			0xe20
-
-#define MTK_REG_PPE_BNDR			0xe28
-#define   MTK_PPE_BNDR_RATE_MASK		0xffff
-
-#define MTK_REG_PPE_BIND_LMT_0			0xe2C
-
-#define MTK_REG_PPE_BIND_LMT_1			0xe30
-#define   MTK_PPE_NTU_KA			BIT(16)
-
-#define MTK_REG_PPE_KA				0xe34
-#define   MTK_PPE_KA_T				BIT(0)
-#define   MTK_PPE_KA_TCP			BIT(16)
-#define   MTK_PPE_KA_UDP			BIT(24)
-
-#define MTK_REG_PPE_UNB_AGE			0xe38
-#define   MTK_PPE_UNB_AGE_MNP_MASK		(0xffff << 16)
-#define   MTK_PPE_UNB_AGE_MNP			(1000 << 16)
-#define   MTK_PPE_UNB_AGE_DLTA_MASK		0xff
-#define   MTK_PPE_UNB_AGE_DLTA			3
-
-#define MTK_REG_PPE_BND_AGE0			0xe3c
-#define   MTK_PPE_BND_AGE0_NTU_DLTA_MASK	(0xffff << 16)
-#define   MTK_PPE_BND_AGE0_NTU_DLTA		(5 << 16)
-#define   MTK_PPE_BND_AGE0_UDP_DLTA_MASK	0xffff
-#define   MTK_PPE_BND_AGE0_UDP_DLTA		5
-
-#define MTK_REG_PPE_BND_AGE1			0xe40
-#define   MTK_PPE_BND_AGE1_FIN_DLTA_MASK	(0xffff << 16)
-#define   MTK_PPE_BND_AGE1_FIN_DLTA		(5 << 16)
-#define   MTK_PPE_BND_AGE1_TCP_DLTA_MASK	0xffff
-#define   MTK_PPE_BND_AGE1_TCP_DLTA		5
-
-#define MTK_REG_PPE_DFT_CPORT			0xe48
-
-#define MTK_REG_PPE_TB_CFG			0xe1c
-#define   MTK_PPE_TB_CFG_X_MODE_MASK		(3 << 18)
-#define   MTK_PPE_TB_CFG_HASH_MODE1		BIT(14)
-#define   MTK_PPE_TB_CFG_HASH_MODE_MASK		(0x3 << 14)
-#define   MTK_PPE_TB_CFG_KA			(3 << 12)
-#define   MTK_PPE_TB_CFG_KA_MASK		(0x3 << 12)
-#define   MTK_PPE_TB_CFG_FIN_AGE		BIT(11)
-#define   MTK_PPE_TB_CFG_UDP_AGE		BIT(10)
-#define   MTK_PPE_TB_CFG_TCP_AGE		BIT(9)
-#define   MTK_PPE_TB_CFG_UNBD_AGE		BIT(8)
-#define   MTK_PPE_TB_CFG_NTU_AGE		BIT(7)
-#define   MTK_PPE_TB_CFG_SMA_FWD_CPU		(0x3 << 4)
-#define   MTK_PPE_TB_CFG_SMA_MASK		(0x3 << 4)
-#define   MTK_PPE_TB_CFG_ENTRY_SZ_64B		0
-#define   MTK_PPE_TB_CFG_ENTRY_SZ_MASK		BIT(3)
-#define   MTK_PPE_TB_CFG_TBL_SZ_4K		2
-#define   MTK_PPE_TB_CFG_TBL_SZ_MASK		0x7
-
-#define MTK_REG_PPE_HASH_SEED			0xe44
-#define   MTK_PPE_HASH_SEED			0x12345678
-
-
-#define MTK_REG_PPE_CAH_CTRL			0xf20
-#define   MTK_PPE_CAH_CTRL_X_MODE		BIT(9)
-#define   MTK_PPE_CAH_CTRL_EN			BIT(0)
-
-struct mtk_foe_unbind_info_blk {
-	u32 time_stamp:8;
-	u32 pcnt:16;		/* packet count */
-	u32 preb:1;
-	u32 pkt_type:3;
-	u32 state:2;
-	u32 udp:1;
-	u32 sta:1;		/* static entry */
-} __attribute__ ((packed));
-
-struct mtk_foe_bind_info_blk {
-	u32 time_stamp:15;
-	u32 ka:1;		/* keep alive */
-	u32 vlan_layer:3;
-	u32 psn:1;		/* egress packet has PPPoE session */
-#ifdef CONFIG_RALINK
-	u32 vpm:2;		/* 0:ethertype remark, 1:0x8100(CR default) */
-#else
-	u32 vpm:1;		/* 0:ethertype remark, 1:0x8100(CR default) */
-	u32 ps:1;		/* packet sampling */
-#endif
-	u32 cah:1;		/* cacheable flag */
-	u32 rmt:1;		/* remove tunnel ip header (6rd/dslite only) */
-	u32 ttl:1;
-	u32 pkt_type:3;
-	u32 state:2;
-	u32 udp:1;
-	u32 sta:1;		/* static entry */
-} __attribute__ ((packed));
-
-struct mtk_foe_info_blk2 {
-	u32 qid:4;		/* QID in Qos Port */
-	u32 fqos:1;		/* force to PSE QoS port */
-	u32 dp:3;		/* force to PSE port x 
-				 0:PSE,1:GSW, 2:GMAC,4:PPE,5:QDMA,7=DROP */
-	u32 mcast:1;		/* multicast this packet to CPU */
-	u32 pcpl:1;		/* OSBN */
-	u32 mlen:1;		/* 0:post 1:pre packet length in meter */
-	u32 alen:1;		/* 0:post 1:pre packet length in accounting */
-	u32 port_mg:6;		/* port meter group */
-	u32 port_ag:6;		/* port account group */
-	u32 dscp:8;		/* DSCP value */
-} __attribute__ ((packed));
-
-struct mtk_foe_ipv4_hnapt {
-	union {
-		struct mtk_foe_bind_info_blk bfib1;
-		struct mtk_foe_unbind_info_blk udib1;
-		u32 info_blk1;
-	};
-	u32 sip;
-	u32 dip;
-	u16 dport;
-	u16 sport;
-	union {
-		struct mtk_foe_info_blk2 iblk2;
-		u32 info_blk2;
-	};
-	u32 new_sip;
-	u32 new_dip;
-	u16 new_dport;
-	u16 new_sport;
-	u32 resv1;
-	u32 resv2;
-	u32 resv3:26;
-	u32 act_dp:6;		/* UDF */
-	u16 vlan1;
-	u16 etype;
-	u32 dmac_hi;
-	u16 vlan2;
-	u16 dmac_lo;
-	u32 smac_hi;
-	u16 pppoe_id;
-	u16 smac_lo;
-} __attribute__ ((packed));
-
-struct mtk_foe_entry {
-	union {
-		struct mtk_foe_unbind_info_blk udib1;
-		struct mtk_foe_bind_info_blk bfib1;
-		struct mtk_foe_ipv4_hnapt ipv4_hnapt;
-	};
-};
-
-enum mtk_foe_entry_state {
-	FOE_STATE_INVALID = 0,
-	FOE_STATE_UNBIND = 1,
-	FOE_STATE_BIND = 2,
-	FOE_STATE_FIN = 3
-};
-
-
-#define MTK_RXD4_FOE_ENTRY		GENMASK(13, 0)
-#define MTK_RXD4_CPU_REASON		GENMASK(18, 14)
-#define MTK_RXD4_SRC_PORT		GENMASK(21, 19)
-#define MTK_RXD4_ALG			GENMASK(31, 22)
-
-enum mtk_foe_cpu_reason {
-	MTK_CPU_REASON_TTL_EXCEEDED		= 0x02,
-	MTK_CPU_REASON_OPTION_HEADER		= 0x03,
-	MTK_CPU_REASON_NO_FLOW			= 0x07,
-	MTK_CPU_REASON_IPV4_FRAG		= 0x08,
-	MTK_CPU_REASON_IPV4_DSLITE_FRAG		= 0x09,
-	MTK_CPU_REASON_IPV4_DSLITE_NO_TCP_UDP	= 0x0a,
-	MTK_CPU_REASON_IPV6_6RD_NO_TCP_UDP	= 0x0b,
-	MTK_CPU_REASON_TCP_FIN_SYN_RST		= 0x0c,
-	MTK_CPU_REASON_UN_HIT			= 0x0d,
-	MTK_CPU_REASON_HIT_UNBIND		= 0x0e,
-	MTK_CPU_REASON_HIT_UNBIND_RATE_REACHED	= 0x0f,
-	MTK_CPU_REASON_HIT_BIND_TCP_FIN		= 0x10,
-	MTK_CPU_REASON_HIT_TTL_1		= 0x11,
-	MTK_CPU_REASON_HIT_BIND_VLAN_VIOLATION	= 0x12,
-	MTK_CPU_REASON_KEEPALIVE_UC_OLD_HDR	= 0x13,
-	MTK_CPU_REASON_KEEPALIVE_MC_NEW_HDR	= 0x14,
-	MTK_CPU_REASON_KEEPALIVE_DUP_OLD_HDR	= 0x15,
-	MTK_CPU_REASON_HIT_BIND_FORCE_CPU	= 0x16,
-	MTK_CPU_REASON_TUNNEL_OPTION_HEADER	= 0x17,
-	MTK_CPU_REASON_MULTICAST_TO_CPU		= 0x18,
-	MTK_CPU_REASON_MULTICAST_TO_GMAC1_CPU	= 0x19,
-	MTK_CPU_REASON_HIT_PRE_BIND		= 0x1a,
-	MTK_CPU_REASON_PACKET_SAMPLING		= 0x1b,
-	MTK_CPU_REASON_EXCEED_MTU		= 0x1c,
-	MTK_CPU_REASON_PPE_BYPASS		= 0x1e,
-	MTK_CPU_REASON_INVALID			= 0x1f,
-};
-
-
-/* our table size is 4K */
-#define MTK_PPE_ENTRY_CNT		0x1000
-#define MTK_PPE_TBL_SZ			\
-			(MTK_PPE_ENTRY_CNT * sizeof(struct mtk_foe_entry))
-
-int mtk_ppe_debugfs_init(struct mtk_eth *eth);
-
-
diff --git a/drivers/net/ethernet/mediatek/soc_mt7620.c b/drivers/net/ethernet/mediatek/soc_mt7620.c
deleted file mode 100644
index 7f728d142de4..000000000000
--- a/drivers/net/ethernet/mediatek/soc_mt7620.c
+++ /dev/null
@@ -1,335 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/if_vlan.h>
-#include <linux/of_net.h>
-
-#include <asm/mach-ralink/ralink_regs.h>
-
-#include <mt7620.h>
-#include "mtk_eth_soc.h"
-#include "gsw_mt7620.h"
-#include "mt7530.h"
-#include "mdio.h"
-
-#define MT7620A_CDMA_CSG_CFG	0x400
-#define MT7620_DMA_VID		(MT7620A_CDMA_CSG_CFG | 0x30)
-#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
-#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
-#define MT7620A_RESET_FE	BIT(21)
-#define MT7621_RESET_FE		BIT(6)
-#define MT7620A_RESET_ESW	BIT(23)
-#define MT7620_L4_VALID		BIT(23)
-#define MT7621_L4_VALID		BIT(24)
-
-#define MT7620_TX_DMA_UDF	BIT(15)
-#define MT7621_TX_DMA_UDF	BIT(19)
-#define TX_DMA_FP_BMAP		((0xff) << 19)
-
-#define CDMA_ICS_EN		BIT(2)
-#define CDMA_UCS_EN		BIT(1)
-#define CDMA_TCS_EN		BIT(0)
-
-#define GDMA_ICS_EN		BIT(22)
-#define GDMA_TCS_EN		BIT(21)
-#define GDMA_UCS_EN		BIT(20)
-
-/* frame engine counters */
-#define MT7620_REG_MIB_OFFSET	0x1000
-#define MT7620_PPE_AC_BCNT0	(MT7620_REG_MIB_OFFSET + 0x00)
-#define MT7620_GDM1_TX_GBCNT	(MT7620_REG_MIB_OFFSET + 0x300)
-#define MT7620_GDM2_TX_GBCNT	(MT7620_GDM1_TX_GBCNT + 0x40)
-
-#define MT7621_REG_MIB_OFFSET	0x2000
-#define MT7621_PPE_AC_BCNT0	(MT7621_REG_MIB_OFFSET + 0x00)
-#define MT7621_GDM1_TX_GBCNT	(MT7621_REG_MIB_OFFSET + 0x400)
-#define MT7621_GDM2_TX_GBCNT	(MT7621_GDM1_TX_GBCNT + 0x40)
-
-#define GSW_REG_GDMA1_MAC_ADRL	0x508
-#define GSW_REG_GDMA1_MAC_ADRH	0x50C
-
-#define MT7621_FE_RST_GL	(FE_FE_OFFSET + 0x04)
-#define MT7620_FE_INT_STATUS2	(FE_FE_OFFSET + 0x08)
-
-/* FE_INT_STATUS reg on mt7620 define CNT_GDM1_AF at BIT(29)
- * but after test it should be BIT(13).
- */
-#define MT7620_FE_GDM1_AF	BIT(13)
-#define MT7621_FE_GDM1_AF	BIT(28)
-#define MT7621_FE_GDM2_AF	BIT(29)
-
-static const u16 mt7620_reg_table[FE_REG_COUNT] = {
-	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
-	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
-	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
-	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
-	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
-	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
-	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
-	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
-	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
-	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
-	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
-	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
-	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
-	[FE_REG_FE_DMA_VID_BASE] = MT7620_DMA_VID,
-	[FE_REG_FE_COUNTER_BASE] = MT7620_GDM1_TX_GBCNT,
-	[FE_REG_FE_RST_GL] = MT7621_FE_RST_GL,
-	[FE_REG_FE_INT_STATUS2] = MT7620_FE_INT_STATUS2,
-};
-
-static int mt7620_gsw_config(struct fe_priv *priv)
-{
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *) priv->soc->swpriv;
-
-	/* is the mt7530 internal or external */
-	if (priv->mii_bus && mdiobus_get_phy(priv->mii_bus, 0x1f)) {
-		mt7530_probe(priv->dev, gsw->base, NULL, 0);
-		mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);
-	} else {
-		mt7530_probe(priv->dev, gsw->base, NULL, 1);
-	}
-
-	return 0;
-}
-
-static void mt7620_set_mac(struct fe_priv *priv, unsigned char *mac)
-{
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->page_lock, flags);
-	mtk_switch_w32(gsw, (mac[0] << 8) | mac[1], GSW_REG_SMACCR1);
-	mtk_switch_w32(gsw, (mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
-		GSW_REG_SMACCR0);
-	spin_unlock_irqrestore(&priv->page_lock, flags);
-}
-
-static void mt7620_auto_poll(struct mt7620_gsw *gsw)
-{
-	int phy;
-	int lsb = -1, msb = 0;
-
-	for_each_set_bit(phy, &gsw->autopoll, 32) {
-		if (lsb < 0)
-			lsb = phy;
-		msb = phy;
-	}
-
-	if (lsb == msb)
-		lsb--;
-
-	mtk_switch_w32(gsw, PHY_AN_EN | PHY_PRE_EN | PMY_MDC_CONF(5) |
-		(msb << 8) | lsb, ESW_PHY_POLLING);
-}
-
-static void mt7620_port_init(struct fe_priv *priv, struct device_node *np)
-{
-	struct mt7620_gsw *gsw = (struct mt7620_gsw *)priv->soc->swpriv;
-	const __be32 *_id = of_get_property(np, "reg", NULL);
-	int phy_mode, size, id;
-	int shift = 12;
-	u32 val, mask = 0;
-	int min = (gsw->port4 == PORT4_EPHY) ? (5) : (4);
-
-	if (!_id || (be32_to_cpu(*_id) < min) || (be32_to_cpu(*_id) > 5)) {
-		if (_id)
-			pr_err("%s: invalid port id %d\n", np->name,
-			       be32_to_cpu(*_id));
-		else
-			pr_err("%s: invalid port id\n", np->name);
-		return;
-	}
-
-	id = be32_to_cpu(*_id);
-
-	if (id == 4)
-		shift = 14;
-
-	priv->phy->phy_fixed[id] = of_get_property(np, "mediatek,fixed-link",
-						   &size);
-	if (priv->phy->phy_fixed[id] &&
-	    (size != (4 * sizeof(*priv->phy->phy_fixed[id])))) {
-		pr_err("%s: invalid fixed link property\n", np->name);
-		priv->phy->phy_fixed[id] = NULL;
-		return;
-	}
-
-	phy_mode = of_get_phy_mode(np);
-	switch (phy_mode) {
-	case PHY_INTERFACE_MODE_RGMII:
-		mask = 0;
-		break;
-	case PHY_INTERFACE_MODE_MII:
-		mask = 1;
-		break;
-	case PHY_INTERFACE_MODE_RMII:
-		mask = 2;
-		break;
-	default:
-		dev_err(priv->dev, "port %d - invalid phy mode\n", id);
-		return;
-	}
-
-	priv->phy->phy_node[id] = of_parse_phandle(np, "phy-handle", 0);
-	if (!priv->phy->phy_node[id] && !priv->phy->phy_fixed[id])
-		return;
-
-	val = rt_sysc_r32(SYSC_REG_CFG1);
-	val &= ~(3 << shift);
-	val |= mask << shift;
-	rt_sysc_w32(val, SYSC_REG_CFG1);
-
-	if (priv->phy->phy_fixed[id]) {
-		const __be32 *link = priv->phy->phy_fixed[id];
-		int tx_fc, rx_fc;
-		u32 val = 0;
-
-		priv->phy->speed[id] = be32_to_cpup(link++);
-		tx_fc = be32_to_cpup(link++);
-		rx_fc = be32_to_cpup(link++);
-		priv->phy->duplex[id] = be32_to_cpup(link++);
-		priv->link[id] = 1;
-
-		switch (priv->phy->speed[id]) {
-		case SPEED_10:
-			val = 0;
-			break;
-		case SPEED_100:
-			val = 1;
-			break;
-		case SPEED_1000:
-			val = 2;
-			break;
-		default:
-			dev_err(priv->dev, "invalid link speed: %d\n",
-				priv->phy->speed[id]);
-			priv->phy->phy_fixed[id] = 0;
-			return;
-		}
-		val = PMCR_SPEED(val);
-		val |= PMCR_LINK | PMCR_BACKPRES | PMCR_BACKOFF | PMCR_RX_EN |
-			PMCR_TX_EN | PMCR_FORCE | PMCR_MAC_MODE | PMCR_IPG;
-		if (tx_fc)
-			val |= PMCR_TX_FC;
-		if (rx_fc)
-			val |= PMCR_RX_FC;
-		if (priv->phy->duplex[id])
-			val |= PMCR_DUPLEX;
-		mtk_switch_w32(gsw, val, GSW_REG_PORT_PMCR(id));
-		dev_info(priv->dev, "using fixed link parameters\n");
-		return;
-	}
-
-	if (priv->phy->phy_node[id] && mdiobus_get_phy(priv->mii_bus, id)) {
-		u32 val = PMCR_BACKPRES | PMCR_BACKOFF | PMCR_RX_EN |
-			PMCR_TX_EN |  PMCR_MAC_MODE | PMCR_IPG;
-
-		mtk_switch_w32(gsw, val, GSW_REG_PORT_PMCR(id));
-		fe_connect_phy_node(priv, priv->phy->phy_node[id]);
-		gsw->autopoll |= BIT(id);
-		mt7620_auto_poll(gsw);
-		return;
-	}
-}
-
-static void mt7620_fe_reset(void)
-{
-	fe_reset(MT7620A_RESET_FE | MT7620A_RESET_ESW);
-}
-
-static void mt7620_rxcsum_config(bool enable)
-{
-	if (enable)
-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) | (GDMA_ICS_EN |
-					GDMA_TCS_EN | GDMA_UCS_EN),
-				MT7620A_GDMA1_FWD_CFG);
-	else
-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~(GDMA_ICS_EN |
-					GDMA_TCS_EN | GDMA_UCS_EN),
-				MT7620A_GDMA1_FWD_CFG);
-}
-
-static void mt7620_txcsum_config(bool enable)
-{
-	if (enable)
-		fe_w32(fe_r32(MT7620A_CDMA_CSG_CFG) | (CDMA_ICS_EN |
-					CDMA_UCS_EN | CDMA_TCS_EN),
-				MT7620A_CDMA_CSG_CFG);
-	else
-		fe_w32(fe_r32(MT7620A_CDMA_CSG_CFG) & ~(CDMA_ICS_EN |
-					CDMA_UCS_EN | CDMA_TCS_EN),
-				MT7620A_CDMA_CSG_CFG);
-}
-
-static int mt7620_fwd_config(struct fe_priv *priv)
-{
-	struct net_device *dev = priv_netdev(priv);
-
-	fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~7, MT7620A_GDMA1_FWD_CFG);
-
-	mt7620_txcsum_config((dev->features & NETIF_F_IP_CSUM));
-	mt7620_rxcsum_config((dev->features & NETIF_F_RXCSUM));
-
-	return 0;
-}
-
-static void mt7620_tx_dma(struct fe_tx_dma *txd)
-{
-}
-
-static void mt7620_init_data(struct fe_soc_data *data,
-			     struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-
-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
-		FE_FLAG_RX_SG_DMA | FE_FLAG_HAS_SWITCH;
-
-	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
-		NETIF_F_HW_VLAN_CTAG_TX;
-	if (mt7620_get_eco() >= 5)
-		netdev->hw_features |= NETIF_F_SG | NETIF_F_TSO | NETIF_F_TSO6 |
-			NETIF_F_IPV6_CSUM;
-}
-
-static struct fe_soc_data mt7620_data = {
-	.init_data = mt7620_init_data,
-	.reset_fe = mt7620_fe_reset,
-	.set_mac = mt7620_set_mac,
-	.fwd_config = mt7620_fwd_config,
-	.tx_dma = mt7620_tx_dma,
-	.switch_init = mtk_gsw_init,
-	.switch_config = mt7620_gsw_config,
-	.port_init = mt7620_port_init,
-	.reg_table = mt7620_reg_table,
-	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
-	.rx_int = RT5350_RX_DONE_INT,
-	.tx_int = RT5350_TX_DONE_INT,
-	.status_int = MT7620_FE_GDM1_AF,
-	.checksum_bit = MT7620_L4_VALID,
-	.has_carrier = mt7620_has_carrier,
-	.mdio_read = mt7620_mdio_read,
-	.mdio_write = mt7620_mdio_write,
-	.mdio_adjust_link = mt7620_mdio_link_adjust,
-};
-
-const struct of_device_id of_fe_match[] = {
-	{ .compatible = "mediatek,mt7620-eth", .data = &mt7620_data },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, of_fe_match);
diff --git a/drivers/net/ethernet/mediatek/soc_mt7621.c b/drivers/net/ethernet/mediatek/soc_mt7621.c
deleted file mode 100644
index 392e0ea2e588..000000000000
--- a/drivers/net/ethernet/mediatek/soc_mt7621.c
+++ /dev/null
@@ -1,186 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/if_vlan.h>
-#include <linux/of_net.h>
-
-#include <asm/mach-ralink/ralink_regs.h>
-
-#include "mtk_eth_soc.h"
-#include "gsw_mt7620.h"
-#include "mt7530.h"
-#include "mdio.h"
-
-#define MT7620A_CDMA_CSG_CFG	0x400
-#define MT7621_CDMP_IG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x00)
-#define MT7621_CDMP_EG_CTRL	(MT7620A_CDMA_CSG_CFG + 0x04)
-#define MT7621_RESET_FE		BIT(6)
-#define MT7621_L4_VALID		BIT(24)
-
-#define MT7621_TX_DMA_UDF	BIT(19)
-#define MT7621_TX_DMA_FPORT	BIT(25)
-
-#define CDMA_ICS_EN		BIT(2)
-#define CDMA_UCS_EN		BIT(1)
-#define CDMA_TCS_EN		BIT(0)
-
-#define GDMA_ICS_EN		BIT(22)
-#define GDMA_TCS_EN		BIT(21)
-#define GDMA_UCS_EN		BIT(20)
-
-/* frame engine counters */
-#define MT7621_REG_MIB_OFFSET	0x2000
-#define MT7621_PPE_AC_BCNT0	(MT7621_REG_MIB_OFFSET + 0x00)
-#define MT7621_GDM1_TX_GBCNT	(MT7621_REG_MIB_OFFSET + 0x400)
-#define MT7621_GDM2_TX_GBCNT	(MT7621_GDM1_TX_GBCNT + 0x40)
-
-#define GSW_REG_GDMA1_MAC_ADRL	0x508
-#define GSW_REG_GDMA1_MAC_ADRH	0x50C
-
-#define MT7621_FE_RST_GL	(FE_FE_OFFSET + 0x04)
-#define MT7620_FE_INT_STATUS2	(FE_FE_OFFSET + 0x08)
-
-/* FE_INT_STATUS reg on mt7620 define CNT_GDM1_AF at BIT(29)
- * but after test it should be BIT(13).
- */
-#define MT7620_FE_GDM1_AF	BIT(13)
-#define MT7621_FE_GDM1_AF	BIT(28)
-#define MT7621_FE_GDM2_AF	BIT(29)
-
-static const u16 mt7621_reg_table[FE_REG_COUNT] = {
-	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
-	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
-	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
-	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
-	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
-	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
-	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
-	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
-	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
-	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
-	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
-	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
-	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
-	[FE_REG_FE_DMA_VID_BASE] = 0,
-	[FE_REG_FE_COUNTER_BASE] = MT7621_GDM1_TX_GBCNT,
-	[FE_REG_FE_RST_GL] = MT7621_FE_RST_GL,
-	[FE_REG_FE_INT_STATUS2] = MT7620_FE_INT_STATUS2,
-};
-
-static int mt7621_gsw_config(struct fe_priv *priv)
-{
-	if (priv->mii_bus &&  mdiobus_get_phy(priv->mii_bus, 0x1f))
-		mt7530_probe(priv->dev, NULL, priv->mii_bus, 1);
-
-	return 0;
-}
-
-static void mt7621_fe_reset(void)
-{
-	fe_reset(MT7621_RESET_FE);
-}
-
-static void mt7621_rxcsum_config(bool enable)
-{
-	if (enable)
-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) | (GDMA_ICS_EN |
-					GDMA_TCS_EN | GDMA_UCS_EN),
-				MT7620A_GDMA1_FWD_CFG);
-	else
-		fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~(GDMA_ICS_EN |
-					GDMA_TCS_EN | GDMA_UCS_EN),
-				MT7620A_GDMA1_FWD_CFG);
-}
-
-static void mt7621_rxvlan_config(bool enable)
-{
-	if (enable)
-		fe_w32(1, MT7621_CDMP_EG_CTRL);
-	else
-		fe_w32(0, MT7621_CDMP_EG_CTRL);
-}
-
-static int mt7621_fwd_config(struct fe_priv *priv)
-{
-	struct net_device *dev = priv_netdev(priv);
-
-	fe_w32(fe_r32(MT7620A_GDMA1_FWD_CFG) & ~0xffff,
-	       MT7620A_GDMA1_FWD_CFG);
-
-	/* mt7621 doesn't have txcsum config */
-	mt7621_rxcsum_config((dev->features & NETIF_F_RXCSUM));
-	mt7621_rxvlan_config(priv->flags & FE_FLAG_RX_VLAN_CTAG);
-
-	return 0;
-}
-
-static void mt7621_tx_dma(struct fe_tx_dma *txd)
-{
-	txd->txd4 = MT7621_TX_DMA_FPORT;
-}
-
-static void mt7621_init_data(struct fe_soc_data *data,
-			     struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-
-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_RX_2B_OFFSET |
-		FE_FLAG_RX_SG_DMA | FE_FLAG_NAPI_WEIGHT |
-		FE_FLAG_HAS_SWITCH | FE_FLAG_JUMBO_FRAME;
-
-	netdev->hw_features = NETIF_F_IP_CSUM | NETIF_F_RXCSUM |
-		NETIF_F_HW_VLAN_CTAG_TX | NETIF_F_SG | NETIF_F_TSO |
-		NETIF_F_TSO6 | NETIF_F_IPV6_CSUM |
-		NETIF_F_TSO_MANGLEID;
-}
-
-static void mt7621_set_mac(struct fe_priv *priv, unsigned char *mac)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->page_lock, flags);
-	fe_w32((mac[0] << 8) | mac[1], GSW_REG_GDMA1_MAC_ADRH);
-	fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
-	       GSW_REG_GDMA1_MAC_ADRL);
-	spin_unlock_irqrestore(&priv->page_lock, flags);
-}
-
-static struct fe_soc_data mt7621_data = {
-	.init_data = mt7621_init_data,
-	.reset_fe = mt7621_fe_reset,
-	.set_mac = mt7621_set_mac,
-	.fwd_config = mt7621_fwd_config,
-	.tx_dma = mt7621_tx_dma,
-	.switch_init = mtk_gsw_init,
-	.switch_config = mt7621_gsw_config,
-	.reg_table = mt7621_reg_table,
-	.pdma_glo_cfg = FE_PDMA_SIZE_16DWORDS,
-	.rx_int = RT5350_RX_DONE_INT,
-	.tx_int = RT5350_TX_DONE_INT,
-	.status_int = (MT7621_FE_GDM1_AF | MT7621_FE_GDM2_AF),
-	.checksum_bit = MT7621_L4_VALID,
-	.has_carrier = mt7620_has_carrier,
-	.mdio_read = mt7620_mdio_read,
-	.mdio_write = mt7620_mdio_write,
-	.mdio_adjust_link = mt7620_mdio_link_adjust,
-};
-
-const struct of_device_id of_fe_match[] = {
-	{ .compatible = "mediatek,mt7621-eth", .data = &mt7621_data },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, of_fe_match);
diff --git a/drivers/net/ethernet/mediatek/soc_rt2880.c b/drivers/net/ethernet/mediatek/soc_rt2880.c
deleted file mode 100644
index 6c89c997d925..000000000000
--- a/drivers/net/ethernet/mediatek/soc_rt2880.c
+++ /dev/null
@@ -1,76 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-
-#include <asm/mach-ralink/ralink_regs.h>
-
-#include "mtk_eth_soc.h"
-#include "mdio_rt2880.h"
-
-#define RT2880_RESET_FE			BIT(18)
-
-static void rt2880_init_data(struct fe_soc_data *data,
-			     struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-
-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
-		FE_FLAG_JUMBO_FRAME | FE_FLAG_CALIBRATE_CLK;
-	netdev->hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_CTAG_TX;
-	/* this should work according to the datasheet but actually does not*/
-	/* netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_RXCSUM; */
-}
-
-void rt2880_fe_reset(void)
-{
-	fe_reset(RT2880_RESET_FE);
-}
-
-static int rt2880_fwd_config(struct fe_priv *priv)
-{
-	int ret;
-
-	ret = fe_set_clock_cycle(priv);
-	if (ret)
-		return ret;
-
-	fe_fwd_config(priv);
-	fe_w32(FE_PSE_FQFC_CFG_INIT, FE_PSE_FQ_CFG);
-	fe_csum_config(priv);
-
-	return ret;
-}
-
-struct fe_soc_data rt2880_data = {
-	.init_data = rt2880_init_data,
-	.reset_fe = rt2880_fe_reset,
-	.fwd_config = rt2880_fwd_config,
-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
-	.checksum_bit = RX_DMA_L4VALID,
-	.rx_int = FE_RX_DONE_INT,
-	.tx_int = FE_TX_DONE_INT,
-	.status_int = FE_CNT_GDM_AF,
-	.mdio_read = rt2880_mdio_read,
-	.mdio_write = rt2880_mdio_write,
-	.mdio_adjust_link = rt2880_mdio_link_adjust,
-	.port_init = rt2880_port_init,
-};
-
-const struct of_device_id of_fe_match[] = {
-	{ .compatible = "ralink,rt2880-eth", .data = &rt2880_data },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, of_fe_match);
diff --git a/drivers/net/ethernet/mediatek/soc_rt3050.c b/drivers/net/ethernet/mediatek/soc_rt3050.c
deleted file mode 100644
index 914b81410e5c..000000000000
--- a/drivers/net/ethernet/mediatek/soc_rt3050.c
+++ /dev/null
@@ -1,158 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-
-#include <asm/mach-ralink/ralink_regs.h>
-
-#include "mtk_eth_soc.h"
-#include "mdio_rt2880.h"
-
-#define RT305X_RESET_FE         BIT(21)
-#define RT305X_RESET_ESW        BIT(23)
-
-static const u16 rt5350_reg_table[FE_REG_COUNT] = {
-	[FE_REG_PDMA_GLO_CFG] = RT5350_PDMA_GLO_CFG,
-	[FE_REG_PDMA_RST_CFG] = RT5350_PDMA_RST_CFG,
-	[FE_REG_DLY_INT_CFG] = RT5350_DLY_INT_CFG,
-	[FE_REG_TX_BASE_PTR0] = RT5350_TX_BASE_PTR0,
-	[FE_REG_TX_MAX_CNT0] = RT5350_TX_MAX_CNT0,
-	[FE_REG_TX_CTX_IDX0] = RT5350_TX_CTX_IDX0,
-	[FE_REG_TX_DTX_IDX0] = RT5350_TX_DTX_IDX0,
-	[FE_REG_RX_BASE_PTR0] = RT5350_RX_BASE_PTR0,
-	[FE_REG_RX_MAX_CNT0] = RT5350_RX_MAX_CNT0,
-	[FE_REG_RX_CALC_IDX0] = RT5350_RX_CALC_IDX0,
-	[FE_REG_RX_DRX_IDX0] = RT5350_RX_DRX_IDX0,
-	[FE_REG_FE_INT_ENABLE] = RT5350_FE_INT_ENABLE,
-	[FE_REG_FE_INT_STATUS] = RT5350_FE_INT_STATUS,
-	[FE_REG_FE_RST_GL] = 0,
-	[FE_REG_FE_DMA_VID_BASE] = 0,
-};
-
-static void rt305x_init_data(struct fe_soc_data *data,
-			     struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-
-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
-		FE_FLAG_CALIBRATE_CLK | FE_FLAG_HAS_SWITCH;
-	netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
-		NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX;
-}
-
-static int rt3050_fwd_config(struct fe_priv *priv)
-{
-	int ret;
-
-	if (ralink_soc != RT305X_SOC_RT3052) {
-		ret = fe_set_clock_cycle(priv);
-		if (ret)
-			return ret;
-	}
-
-	fe_fwd_config(priv);
-	if (ralink_soc != RT305X_SOC_RT3352)
-		fe_w32(FE_PSE_FQFC_CFG_INIT, FE_PSE_FQ_CFG);
-	fe_csum_config(priv);
-
-	return 0;
-}
-
-static void rt305x_fe_reset(void)
-{
-	fe_reset(RT305X_RESET_FE);
-}
-
-static void rt5350_init_data(struct fe_soc_data *data,
-			     struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-
-	priv->flags = FE_FLAG_HAS_SWITCH;
-	netdev->hw_features = NETIF_F_SG | NETIF_F_RXCSUM;
-}
-
-static void rt5350_set_mac(struct fe_priv *priv, unsigned char *mac)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&priv->page_lock, flags);
-	fe_w32((mac[0] << 8) | mac[1], RT5350_SDM_MAC_ADRH);
-	fe_w32((mac[2] << 24) | (mac[3] << 16) | (mac[4] << 8) | mac[5],
-	       RT5350_SDM_MAC_ADRL);
-	spin_unlock_irqrestore(&priv->page_lock, flags);
-}
-
-static void rt5350_rxcsum_config(bool enable)
-{
-	if (enable)
-		fe_w32(fe_r32(RT5350_SDM_CFG) | (RT5350_SDM_ICS_EN |
-				RT5350_SDM_TCS_EN | RT5350_SDM_UCS_EN),
-				RT5350_SDM_CFG);
-	else
-		fe_w32(fe_r32(RT5350_SDM_CFG) & ~(RT5350_SDM_ICS_EN |
-				RT5350_SDM_TCS_EN | RT5350_SDM_UCS_EN),
-				RT5350_SDM_CFG);
-}
-
-static int rt5350_fwd_config(struct fe_priv *priv)
-{
-	struct net_device *dev = priv_netdev(priv);
-
-	rt5350_rxcsum_config((dev->features & NETIF_F_RXCSUM));
-
-	return 0;
-}
-
-static void rt5350_tx_dma(struct fe_tx_dma *txd)
-{
-	txd->txd4 = 0;
-}
-
-static void rt5350_fe_reset(void)
-{
-	fe_reset(RT305X_RESET_FE | RT305X_RESET_ESW);
-}
-
-static struct fe_soc_data rt3050_data = {
-	.init_data = rt305x_init_data,
-	.reset_fe = rt305x_fe_reset,
-	.fwd_config = rt3050_fwd_config,
-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
-	.checksum_bit = RX_DMA_L4VALID,
-	.rx_int = FE_RX_DONE_INT,
-	.tx_int = FE_TX_DONE_INT,
-	.status_int = FE_CNT_GDM_AF,
-};
-
-static struct fe_soc_data rt5350_data = {
-	.init_data = rt5350_init_data,
-	.reg_table = rt5350_reg_table,
-	.reset_fe = rt5350_fe_reset,
-	.set_mac = rt5350_set_mac,
-	.fwd_config = rt5350_fwd_config,
-	.tx_dma = rt5350_tx_dma,
-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
-	.checksum_bit = RX_DMA_L4VALID,
-	.rx_int = RT5350_RX_DONE_INT,
-	.tx_int = RT5350_TX_DONE_INT,
-};
-
-const struct of_device_id of_fe_match[] = {
-	{ .compatible = "ralink,rt3050-eth", .data = &rt3050_data },
-	{ .compatible = "ralink,rt5350-eth", .data = &rt5350_data },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, of_fe_match);
diff --git a/drivers/net/ethernet/mediatek/soc_rt3883.c b/drivers/net/ethernet/mediatek/soc_rt3883.c
deleted file mode 100644
index 4935b7fbd43e..000000000000
--- a/drivers/net/ethernet/mediatek/soc_rt3883.c
+++ /dev/null
@@ -1,75 +0,0 @@
-/*   This program is free software; you can redistribute it and/or modify
- *   it under the terms of the GNU General Public License as published by
- *   the Free Software Foundation; version 2 of the License
- *
- *   This program is distributed in the hope that it will be useful,
- *   but WITHOUT ANY WARRANTY; without even the implied warranty of
- *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *   GNU General Public License for more details.
- *
- *   Copyright (C) 2009-2015 John Crispin <blogic@openwrt.org>
- *   Copyright (C) 2009-2015 Felix Fietkau <nbd@nbd.name>
- *   Copyright (C) 2013-2015 Michael Lee <igvtee@gmail.com>
- */
-
-#include <linux/module.h>
-
-#include <asm/mach-ralink/ralink_regs.h>
-
-#include "mtk_eth_soc.h"
-#include "mdio_rt2880.h"
-
-#define RT3883_RSTCTRL_FE		BIT(21)
-
-static void rt3883_fe_reset(void)
-{
-	fe_reset(RT3883_RSTCTRL_FE);
-}
-
-static int rt3883_fwd_config(struct fe_priv *priv)
-{
-	int ret;
-
-	ret = fe_set_clock_cycle(priv);
-	if (ret)
-		return ret;
-
-	fe_fwd_config(priv);
-	fe_w32(FE_PSE_FQFC_CFG_256Q, FE_PSE_FQ_CFG);
-	fe_csum_config(priv);
-
-	return ret;
-}
-
-static void rt3883_init_data(struct fe_soc_data *data,
-			     struct net_device *netdev)
-{
-	struct fe_priv *priv = netdev_priv(netdev);
-
-	priv->flags = FE_FLAG_PADDING_64B | FE_FLAG_PADDING_BUG |
-		FE_FLAG_JUMBO_FRAME | FE_FLAG_CALIBRATE_CLK;
-	netdev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
-		NETIF_F_RXCSUM | NETIF_F_HW_VLAN_CTAG_TX;
-}
-
-static struct fe_soc_data rt3883_data = {
-	.init_data = rt3883_init_data,
-	.reset_fe = rt3883_fe_reset,
-	.fwd_config = rt3883_fwd_config,
-	.pdma_glo_cfg = FE_PDMA_SIZE_8DWORDS,
-	.rx_int = FE_RX_DONE_INT,
-	.tx_int = FE_TX_DONE_INT,
-	.status_int = FE_CNT_GDM_AF,
-	.checksum_bit = RX_DMA_L4VALID,
-	.mdio_read = rt2880_mdio_read,
-	.mdio_write = rt2880_mdio_write,
-	.mdio_adjust_link = rt2880_mdio_link_adjust,
-	.port_init = rt2880_port_init,
-};
-
-const struct of_device_id of_fe_match[] = {
-	{ .compatible = "ralink,rt3883-eth", .data = &rt3883_data },
-	{},
-};
-
-MODULE_DEVICE_TABLE(of, of_fe_match);
diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c
index 0bcf7099f1c2..fd8fec6d0249 100644
--- a/drivers/net/phy/phy.c
+++ b/drivers/net/phy/phy.c
@@ -980,10 +980,7 @@ void phy_state_machine(struct work_struct *work)
 		/* If the link is down, give up on negotiation for now */
 		if (!phydev->link) {
 			phydev->state = PHY_NOLINK;
-			if (!phydev->no_auto_carrier_off)
-				phy_link_down(phydev, true);
-			else
-				phy_link_down(phydev, false);
+			phy_link_down(phydev, true);
 			break;
 		}
 
@@ -1070,10 +1067,7 @@ void phy_state_machine(struct work_struct *work)
 			phy_link_up(phydev);
 		} else {
 			phydev->state = PHY_NOLINK;
-			if (!phydev->no_auto_carrier_off)
-				phy_link_down(phydev, true);
-			else
-				phy_link_down(phydev, false);
+			phy_link_down(phydev, true);
 		}
 
 		if (phy_interrupt_is_valid(phydev))
@@ -1083,10 +1077,7 @@ void phy_state_machine(struct work_struct *work)
 	case PHY_HALTED:
 		if (phydev->link) {
 			phydev->link = 0;
-			if (!phydev->no_auto_carrier_off)
-				phy_link_down(phydev, true);
-			else
-				phy_link_down(phydev, false);
+			phy_link_down(phydev, true);
 			do_suspend = true;
 		}
 		break;
diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c
index 5e55c22840f2..86e58398e58d 100644
--- a/drivers/net/phy/phy_device.c
+++ b/drivers/net/phy/phy_device.c
@@ -1929,7 +1929,7 @@ static struct phy_driver genphy_driver = {
 	.config_init	= genphy_config_init,
 	.features	= PHY_GBIT_FEATURES | SUPPORTED_MII |
 			  SUPPORTED_AUI | SUPPORTED_FIBRE |
-			  SUPPORTED_BNC,
+			  SUPPORTED_BNC | SUPPORTED_Pause | SUPPORTED_Asym_Pause,
 	.config_aneg	= genphy_config_aneg,
 	.aneg_done	= genphy_aneg_done,
 	.read_status	= genphy_read_status,
-- 
2.17.1

